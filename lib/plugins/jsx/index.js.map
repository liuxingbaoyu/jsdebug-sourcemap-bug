{"version":3,"names":["JsxErrors","ParseErrorEnum","AttributeIsEmpty","MissingClosingTagElement","openingTagName","MissingClosingTagFragment","UnexpectedSequenceExpression","UnexpectedToken","unexpected","HTMLEntity","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","isFragment","object","type","getQualifiedJSXName","name","namespace","property","Error","superClass","JSXParserMixin","jsxReadToken","out","chunkStart","state","pos","length","raise","at","startLoc","ch","input","charCodeAt","start","canStartJSXElement","finishToken","getTokenFromCode","slice","jsxReadEntity","process","env","BABEL_8_BREAKING","curPosition","isNewLine","jsxReadNewLine","normalizeCRLF","String","fromCharCode","curLine","lineStart","jsxReadString","quote","Errors","UnterminatedString","startPos","codePointAtPos","radix","codePoint","readInt","undefined","fromCodePoint","count","semi","desc","entity","XHTMLEntities","jsxReadWord","isIdentifierChar","jsxParseIdentifier","node","startNode","match","value","tokenIsKeyword","tokenLabelName","next","finishNode","jsxParseNamespacedName","eat","startNodeAt","jsxParseElementName","newNode","jsxParseAttributeValue","setContext","tc","brace","jsxParseExpressionContainer","j_oTag","expression","parseExprAtom","jsxParseEmptyExpression","lastTokEndLoc","index","finishNodeAt","jsxParseSpreadChild","parseExpression","expect","previousContext","extra","parenthesized","expressions","jsxParseAttribute","argument","parseMaybeAssignAllowIn","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","attributes","push","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","j_expr","openingFragment","closingFragment","jsxParseElement","newContext","context","refExpressionErrors","parseLiteral","replaceToken","skipSpace","curContext","preserveSpace","code","j_cTag","isIdentifierStart","updateContext","prevType","splice","pop","tokenComesBeforeExpression"],"sources":["../../../src/plugins/jsx/index.ts"],"sourcesContent":["import * as charCodes from \"charcodes\";\n\nimport XHTMLEntities from \"./xhtml\";\nimport type Parser from \"../../parser\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport {\n  tokenComesBeforeExpression,\n  tokenIsKeyword,\n  tokenLabelName,\n  type TokenType,\n  tt,\n} from \"../../tokenizer/types\";\nimport { TokContext, types as tc } from \"../../tokenizer/context\";\nimport * as N from \"../../types\";\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier\";\nimport type { Position } from \"../../util/location\";\nimport { isNewLine } from \"../../util/whitespace\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error\";\nimport { type Undone } from \"../../parser/node\";\n\n/* eslint sort-keys: \"error\" */\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty:\n    \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({ openingTagName }: { openingTagName: string }) =>\n    `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression:\n    \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  // FIXME: Unify with Errors.UnexpectedToken\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity,\n  }: {\n    unexpected: string;\n    HTMLEntity: string;\n  }) =>\n    `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue:\n    \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements:\n    \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\",\n});\n\n/* eslint-disable sort-keys */\n\nfunction isFragment(object?: N.JSXElement | null): boolean {\n  return object\n    ? object.type === \"JSXOpeningFragment\" ||\n        object.type === \"JSXClosingFragment\"\n    : false;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\n): string {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return (\n      getQualifiedJSXName(object.object) +\n      \".\" +\n      getQualifiedJSXName(object.property)\n    );\n  }\n\n  // istanbul ignore next\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nexport interface IJSXParserMixin {\n  jsxParseOpeningElementAfterName(\n    node: N.JSXOpeningElement,\n  ): N.JSXOpeningElement;\n}\n\nexport default (superClass: typeof Parser) =>\n  class JSXParserMixin extends superClass implements Parser, IJSXParserMixin {\n    // Reads inline JSX contents token.\n\n    jsxReadToken(): void {\n      let out = \"\";\n      let chunkStart = this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(JsxErrors.UnterminatedJsxContent, {\n            at: this.state.startLoc,\n          });\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case charCodes.lessThan:\n          case charCodes.leftCurlyBrace:\n            if (this.state.pos === this.state.start) {\n              if (ch === charCodes.lessThan && this.state.canStartJSXElement) {\n                ++this.state.pos;\n                return this.finishToken(tt.jsxTagStart);\n              }\n              return super.getTokenFromCode(ch);\n            }\n            out += this.input.slice(chunkStart, this.state.pos);\n            return this.finishToken(tt.jsxText, out);\n\n          case charCodes.ampersand:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          case charCodes.greaterThan:\n          case charCodes.rightCurlyBrace:\n            if (process.env.BABEL_8_BREAKING) {\n              this.raise(JsxErrors.UnexpectedToken, {\n                at: this.state.curPosition(),\n                unexpected: this.input[this.state.pos],\n                HTMLEntity:\n                  ch === charCodes.rightCurlyBrace ? \"&rbrace;\" : \"&gt;\",\n              });\n            }\n          /* falls through */\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n        }\n      }\n    }\n\n    jsxReadNewLine(normalizeCRLF: boolean): string {\n      const ch = this.input.charCodeAt(this.state.pos);\n      let out;\n      ++this.state.pos;\n      if (\n        ch === charCodes.carriageReturn &&\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\n      ) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n\n      return out;\n    }\n\n    jsxReadString(quote: number): void {\n      let out = \"\";\n      let chunkStart = ++this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(Errors.UnterminatedString, {\n            at: this.state.startLoc,\n          });\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n        if (ch === charCodes.ampersand) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.state.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsxReadEntity(): string {\n      const startPos = ++this.state.pos;\n      if (this.codePointAtPos(this.state.pos) === charCodes.numberSign) {\n        ++this.state.pos;\n\n        let radix = 10;\n        if (this.codePointAtPos(this.state.pos) === charCodes.lowercaseX) {\n          radix = 16;\n          ++this.state.pos;\n        }\n\n        const codePoint = this.readInt(\n          radix,\n          /* len */ undefined,\n          /* forceLen */ false,\n          /* allowNumSeparator */ \"bail\",\n        );\n        if (\n          codePoint !== null &&\n          this.codePointAtPos(this.state.pos) === charCodes.semicolon\n        ) {\n          ++this.state.pos;\n          return String.fromCodePoint(codePoint);\n        }\n      } else {\n        let count = 0;\n        let semi = false;\n        while (\n          count++ < 10 &&\n          this.state.pos < this.length &&\n          !(semi = this.codePointAtPos(this.state.pos) == charCodes.semicolon)\n        ) {\n          ++this.state.pos;\n        }\n\n        if (semi) {\n          const desc = this.input.slice(startPos, this.state.pos);\n          const entity = XHTMLEntities[desc];\n          ++this.state.pos;\n\n          if (entity) {\n            return entity;\n          }\n        }\n      }\n\n      // Not a valid entity\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can\"t contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsxReadWord(): void {\n      let ch;\n      const start = this.state.pos;\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\n      return this.finishToken(\n        tt.jsxName,\n        this.input.slice(start, this.state.pos),\n      );\n    }\n\n    // Parse next token as JSX identifier\n\n    jsxParseIdentifier(): N.JSXIdentifier {\n      const node = this.startNode();\n      if (this.match(tt.jsxName)) {\n        node.name = this.state.value;\n      } else if (tokenIsKeyword(this.state.type)) {\n        node.name = tokenLabelName(this.state.type);\n      } else {\n        this.unexpected();\n      }\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n\n    // Parse namespaced identifier.\n\n    jsxParseNamespacedName(): N.JSXNamespacedName {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const name = this.jsxParseIdentifier();\n      if (!this.eat(tt.colon)) return name;\n\n      const node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsxParseElementName():\n      | N.JSXIdentifier\n      | N.JSXNamespacedName\n      | N.JSXMemberExpression {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let node = this.jsxParseNamespacedName();\n      if (node.type === \"JSXNamespacedName\") {\n        return node;\n      }\n      while (this.eat(tt.dot)) {\n        const newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsxParseAttributeValue(): N.Expression {\n      let node;\n      switch (this.state.type) {\n        case tt.braceL:\n          node = this.startNode();\n          this.setContext(tc.brace);\n          this.next();\n          node = this.jsxParseExpressionContainer(node, tc.j_oTag);\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            this.raise(JsxErrors.AttributeIsEmpty, { at: node });\n          }\n          return node;\n\n        case tt.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          throw this.raise(JsxErrors.UnsupportedJsxValue, {\n            at: this.state.startLoc,\n          });\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\n      const node = this.startNodeAt(\n        this.state.lastTokEndLoc.index,\n        this.state.lastTokEndLoc,\n      );\n      return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n    }\n\n    // Parse JSX spread child\n\n    jsxParseSpreadChild(node: Undone<N.JSXSpreadChild>): N.JSXSpreadChild {\n      this.next(); // ellipsis\n      node.expression = this.parseExpression();\n      this.setContext(tc.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXSpreadChild\");\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsxParseExpressionContainer(\n      node: Undone<N.JSXExpressionContainer>,\n      previousContext: TokContext,\n    ): N.JSXExpressionContainer {\n      if (this.match(tt.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        const expression = this.parseExpression();\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            expression.type === \"SequenceExpression\" &&\n            !expression.extra?.parenthesized\n          ) {\n            this.raise(JsxErrors.UnexpectedSequenceExpression, {\n              at: expression.expressions[1],\n            });\n          }\n        }\n\n        node.expression = expression;\n      }\n      this.setContext(previousContext);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsxParseAttribute(): N.JSXAttribute {\n      const node = this.startNode();\n      if (this.match(tt.braceL)) {\n        this.setContext(tc.brace);\n        this.next();\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssignAllowIn();\n        this.setContext(tc.j_oTag);\n        this.state.canStartJSXElement = true;\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n\n    // Parses JSX opening tag starting after \"<\".\n\n    jsxParseOpeningElementAt(\n      startPos: number,\n      startLoc: Position,\n    ): N.JSXOpeningElement {\n      const node = this.startNodeAt<N.JSXOpeningElement | N.JSXOpeningFragment>(\n        startPos,\n        startLoc,\n      );\n      if (this.eat(tt.jsxTagEnd)) {\n        // @ts-expect-error migrate to Babel types\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      return this.jsxParseOpeningElementAfterName(\n        node as Undone<N.JSXOpeningElement>,\n      );\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: Undone<N.JSXOpeningElement>,\n    ): N.JSXOpeningElement {\n      const attributes: N.JSXAttribute[] = [];\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\n        attributes.push(this.jsxParseAttribute());\n      }\n      node.attributes = attributes;\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    }\n\n    // Parses JSX closing tag starting after \"</\".\n\n    jsxParseClosingElementAt(\n      startPos: number,\n      startLoc: Position,\n    ): N.JSXClosingElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      if (this.eat(tt.jsxTagEnd)) {\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    }\n\n    // Parses entire JSX element, including it\"s opening tag\n    // (starting after \"<\"), attributes, contents and closing tag.\n\n    jsxParseElementAt(startPos: number, startLoc: Position): N.JSXElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      const children = [];\n      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case tt.jsxTagStart:\n              startPos = this.state.start;\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsxParseClosingElementAt(\n                  startPos,\n                  startLoc,\n                );\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startPos, startLoc));\n              break;\n\n            case tt.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL: {\n              const node = this.startNode<\n                N.JSXSpreadChild | N.JSXExpressionContainer\n              >();\n              this.setContext(tc.brace);\n              this.next();\n              if (this.match(tt.ellipsis)) {\n                children.push(\n                  this.jsxParseSpreadChild(node as Undone<N.JSXSpreadChild>),\n                );\n              } else {\n                children.push(\n                  this.jsxParseExpressionContainer(\n                    node as Undone<N.JSXExpressionContainer>,\n                    tc.j_expr,\n                  ),\n                );\n              }\n\n              break;\n            }\n            // istanbul ignore next - should never happen\n            default:\n              throw this.unexpected();\n          }\n        }\n\n        if (\n          isFragment(openingElement) &&\n          !isFragment(closingElement) &&\n          closingElement !== null\n        ) {\n          this.raise(JsxErrors.MissingClosingTagFragment, {\n            at: closingElement,\n          });\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name),\n          });\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (\n            getQualifiedJSXName(closingElement.name) !==\n            getQualifiedJSXName(openingElement.name)\n          ) {\n            this.raise(JsxErrors.MissingClosingTagElement, {\n              at: closingElement,\n              openingTagName: getQualifiedJSXName(openingElement.name),\n            });\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n      node.children = children;\n      if (this.match(tt.lt)) {\n        throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n          at: this.state.startLoc,\n        });\n      }\n\n      return isFragment(openingElement)\n        ? this.finishNode(node, \"JSXFragment\")\n        : this.finishNode(node, \"JSXElement\");\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsxParseElement(): N.JSXElement {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startPos, startLoc);\n    }\n\n    setContext(newContext: TokContext) {\n      const { context } = this.state;\n      context[context.length - 1] = newContext;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {\n      if (this.match(tt.jsxText)) {\n        return this.parseLiteral(this.state.value, \"JSXText\");\n      } else if (this.match(tt.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else if (\n        this.match(tt.lt) &&\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\n      ) {\n        // In case we encounter an lt token here it will always be the start of\n        // jsx as the lt sign is not allowed in places that expect an expression\n        this.replaceToken(tt.jsxTagStart);\n        return this.jsxParseElement();\n      } else {\n        return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    skipSpace() {\n      const curContext = this.curContext();\n      if (!curContext.preserveSpace) super.skipSpace();\n    }\n\n    getTokenFromCode(code: number): void {\n      const context = this.curContext();\n\n      if (context === tc.j_expr) {\n        return this.jsxReadToken();\n      }\n\n      if (context === tc.j_oTag || context === tc.j_cTag) {\n        if (isIdentifierStart(code)) {\n          return this.jsxReadWord();\n        }\n\n        if (code === charCodes.greaterThan) {\n          ++this.state.pos;\n          return this.finishToken(tt.jsxTagEnd);\n        }\n\n        if (\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\n          context === tc.j_oTag\n        ) {\n          return this.jsxReadString(code);\n        }\n      }\n\n      if (\n        code === charCodes.lessThan &&\n        this.state.canStartJSXElement &&\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\n      ) {\n        ++this.state.pos;\n        return this.finishToken(tt.jsxTagStart);\n      }\n\n      return super.getTokenFromCode(code);\n    }\n\n    updateContext(prevType: TokenType): void {\n      const { context, type } = this.state;\n      if (type === tt.slash && prevType === tt.jsxTagStart) {\n        // do not consider JSX expr -> JSX open tag -> ... anymore\n        // reconsider as closing tag context\n        context.splice(-2, 2, tc.j_cTag);\n        this.state.canStartJSXElement = false;\n      } else if (type === tt.jsxTagStart) {\n        // start opening tag context\n        context.push(tc.j_oTag);\n      } else if (type === tt.jsxTagEnd) {\n        const out = context[context.length - 1];\n        if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\n          context.pop();\n          this.state.canStartJSXElement =\n            context[context.length - 1] === tc.j_expr;\n        } else {\n          this.setContext(tc.j_expr);\n          this.state.canStartJSXElement = true;\n        }\n      } else {\n        this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n      }\n    }\n  };\n"],"mappings":"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"}