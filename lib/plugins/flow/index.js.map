{"version":3,"names":["reservedTypes","Set","FlowErrors","ParseErrorEnum","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","reservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","memberName","enumName","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","invalidEnumType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","explicitType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","suggestion","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","GetterMayNotHaveThisParam","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","PatternIsOptional","message","process","env","BABEL_8_BREAKING","reasonCode","SetterMayNotHaveThisParam","SpreadVariance","ThisParamAnnotationRequired","ThisParamBannedInConstructor","ThisParamMayNotBeOptional","ThisParamMustBeFirst","ThisParamNoDefault","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","unsupportedExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","isEsModuleType","bodyElement","type","declaration","hasTypeImportKind","node","importKind","isMaybeDefaultImport","tokenIsKeywordOrIdentifier","exportSuggestions","const","let","interface","partition","list","test","list1","list2","i","length","push","FLOW_PRAGMA_REGEX","superClass","FlowParserMixin","flowPragma","undefined","getScopeHandler","FlowScopeHandler","shouldParseTypes","getPluginOption","shouldParseEnums","finishToken","val","addComment","comment","matches","exec","value","Error","flowParseTypeInitialiser","tok","oldInType","state","inType","expect","flowParseType","flowParsePredicate","startNode","moduloLoc","startLoc","next","expectContextual","lastTokStart","index","raise","at","eat","parseExpression","finishNode","flowParseTypeAndPredicateInitialiser","predicate","match","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","id","parseIdentifier","typeNode","typeContainer","typeParameters","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","params","rest","this","_this","returnType","typeAnnotation","resetEndLocation","semicolon","scope","declareName","name","BIND_FLOW_DECLARE_FN","loc","start","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","lastTokStartLoc","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","unexpected","flowParseTypeAnnotatableIdentifier","BIND_VAR","enter","SCOPE_OTHER","parseExprAtom","bodyNode","body","parseImport","exit","kind","hasModuleExport","forEach","default","isLet","label","parseExport","exportKind","flowParseTypeAnnotation","finished","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","BIND_FUNCTION","BIND_LEXICAL","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","word","checkReservedType","has","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStartLoc","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","key","flowParseObjectTypeInternalSlot","method","optional","flowParseObjectTypeMethodish","startNodeAt","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","nodeStart","callProperties","properties","indexers","internalSlots","endDelim","exact","inexact","protoStartLoc","inexactStartLoc","tokenIsLiteralPropertyName","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","out","isInexactToken","argument","proto","flowCheckGetterSetterParams","property","paramCount","Errors","BadGetterArity","BadSetterArity","BadSetterRestParameter","startPos","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","types","pos","first","lh","isThis","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","tokenIsIdentifier","token","parseLiteral","parseLiteralAtNode","tokenIsKeyword","tokenLabelName","createIdentifier","flowParsePostfixType","seenOptionalIndexedAccess","canInsertSemicolon","elementType","objectType","indexType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","expression","end","parseFunctionBody","allowExpressionBody","isMethod","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatement","context","topLevel","strict","flowParseEnumDeclaration","stmt","isValidDirective","parseExpressionStatement","expr","shouldParseExportDeclaration","tokenIsFlowInterfaceOrTypeOrOpaque","containsEsc","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","refExpressionErrors","maybeInArrowParameters","nextCh","lookaheadCharCode","setOptionalParametersError","clone","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","parseMaybeAssignAllowIn","pop","disallowInvalid","stack","arrows","finishArrowValidation","every","isAssignable","toAssignableList","extra","trailingCommaLoc","SCOPE_FUNCTION","SCOPE_ARROW","checkParams","parse","result","indexOf","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","specifiers","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","parseClassMember","classBody","member","parseClassMemberFromModifier","isIterator","readIterator","readWord1","fullWord","InvalidIdentifier","curPosition","identifierName","getTokenFromCode","code","input","charCodeAt","finishOp","isIteratorStart","isBinding","toAssignable","isLHS","left","exprList","toReferencedList","isParenthesizedExpr","parenthesized","parseArrayLike","close","canBePattern","isTuple","elements","isValidLVal","isParenthesized","binding","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassMethod","isGenerator","isAsync","isConstructor","allowsDirectSuper","isThisParam","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","checkGetterSetterParams","getObjectOrClassMethodParams","parsePropertyNamePrefixOperator","parseObjPropValue","prop","isPattern","isAccessor","parseAssignableListItemTypes","parseMaybeDefault","shouldParseDefaultImport","parseImportSpecifierLocal","specifier","local","finishImportSpecifier","maybeParseDefaultImportSpecifier","parseImportSpecifier","importedIsString","isInTypeOnlyImport","isMaybeTypeOnly","firstIdent","imported","specifierTypeKind","isLookaheadContextual","as_ident","cloneIdentifier","ImportBindingIsString","importName","specifierIsTypeImport","checkReservedWord","parseBindingAtom","parseFunctionParams","allowModifiers","parseVarId","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","jsx","hasPlugin","tryParse","error","currentContext","tc","j_oTag","j_expr","arrow","abort","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","failState","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","strictModeChanged","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","base","noCalls","callee","arguments","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","parseSubscript","subscriptState","isLookaheadToken_lt","optionalChainMember","stop","typeArguments","finishCallExpression","parseNewCallee","targs","parseArrowExpression","readToken_mult_modulo","hasFlowComment","nextToken","readToken_pipe_amp","parseTopLevel","file","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","commentSkip","UnterminatedComment","shiftToFirstNonWhiteSpace","includes","ch2","ch3","slice","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorInvalidMemberInitializer","enumContext","flowEnumErrorNumberMemberNotInitialized","flowEnumErrorStringMemberInconsistentlyInitailized","flowEnumMemberInit","endOfInit","literal","parseNumericLiteral","parseStringLiteral","parseBooleanLiteral","flowEnumMemberRaw","init","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","hasUnknownMembers","memberNode","toUpperCase","add","flowEnumStringMembers","initializedMembers","flowEnumParseExplicitType","flowEnumBody","nameLoc","empty","boolsLen","numsLen","strsLen","defaultedLen","nextTokenStart","afterNext"],"sources":["../../../src/plugins/flow/index.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport type Parser from \"../../parser\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeyword,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n  tokenIsFlowInterfaceOrTypeOrOpaque,\n} from \"../../tokenizer/types\";\nimport * as N from \"../../types\";\nimport { Position } from \"../../util/location\";\nimport { types as tc } from \"../../tokenizer/context\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart } from \"../../util/identifier\";\nimport FlowScopeHandler from \"./scope\";\nimport {\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  BIND_FLOW_DECLARE_FN,\n  SCOPE_ARROW,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n  type BindingTypes,\n} from \"../../util/scopeflags\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow:\n    \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind:\n    \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  // TODO: When we get proper string enums in typescript make this ReservedType.\n  // Not really worth it to do the whole $Values dance with reservedTypes set.\n  AssignReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement:\n    \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer:\n    \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports:\n    \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({ enumName }: { enumName: string }) =>\n    `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName,\n  }: {\n    invalidEnumType: string;\n    enumName: string;\n  }) =>\n    `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n\n  // TODO: When moving to typescript, we should either have each of the\n  // following errors only accept the specific strings they want:\n  //\n  // ...PrimaryType: explicitType: \"string\" | \"number\" | \"boolean\"\n  // ...SymbolType: explicitType: \"symbol\"\n  // ...UnknownType: explicitType: null\n  //\n  // Or, alternatively, merge these three errors together into one\n  // `EnumInvalidMemberInitializer` error that can accept `EnumExplicitType`\n  // without alteration, and then just have its message change based on the\n  // explicitType.\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion,\n  }: {\n    enumName: string;\n    memberName: string;\n    suggestion: string;\n  }) =>\n    `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n  }) =>\n    `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitailized: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportTypeShorthandOnlyInPureImport:\n    \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact:\n    \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject:\n    \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule:\n    \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault:\n    \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule:\n    \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: {\n    message:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    // For consistency in TypeScript and Flow error codes\n    ...(!process.env.BABEL_8_BREAKING\n      ? { reasonCode: \"OptionalBindingPattern\" }\n      : {}),\n  },\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired:\n    \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor:\n    \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst:\n    \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern:\n    \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject:\n    \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore:\n    \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks:\n    \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType:\n    \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand:\n    'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter:\n    \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction:\n    \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion,\n  }: {\n    unsupportedExportKind: string;\n    suggestion: string;\n  }) =>\n    `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule:\n    \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\",\n});\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(node: N.Node): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(type: TokenType): boolean {\n  return tokenIsKeywordOrIdentifier(type) && type !== tt._from;\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (c: T, b: number, a: T[]) => boolean | undefined | null,\n): [T[], T[]] {\n  const list1: T[] = [];\n  const list2: T[] = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\n\ntype EnumContext = {\n  enumName: string;\n  explicitType: EnumExplicitType;\n  memberName: string;\n};\n\ntype EnumMemberInit =\n  | {\n      type: \"number\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"string\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"boolean\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"invalid\";\n      loc: Position;\n    }\n  | {\n      type: \"none\";\n      loc: Position;\n    };\n\nexport default (superClass: typeof Parser) =>\n  class FlowParserMixin extends superClass implements Parser {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): {\n      new (...args: any): FlowScopeHandler;\n    } {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums(): boolean {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      return super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      return super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowPredicate {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      this.next(); // eat `%`\n      this.expectContextual(tt._checks);\n      // Force '%' and 'checks' to be adjacent\n      if (this.state.lastTokStart > moduloLoc.index + 1) {\n        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n          at: moduloLoc,\n        });\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = super.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [\n      N.FlowType | undefined | null,\n      N.FlowPredicate | undefined | null,\n    ] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(\n      node: Undone<N.FlowDeclareClass>,\n    ): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: Undone<N.FlowDeclareFunction>,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode<N.TypeAnnotation>();\n\n      if (this.match(tt.lt)) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [typeNode.returnType, node.predicate] =\n        this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(\n        node.id.name,\n        BIND_FLOW_DECLARE_FN,\n        node.id.loc.start,\n      );\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: Undone<N.FlowDeclare>,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(tt._module)) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(FlowErrors.NestedDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(tt._type)) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(tt._opaque)) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(tt._interface)) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: Undone<N.FlowDeclareVariable>,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(\n      node: Undone<N.FlowDeclareModule>,\n    ): N.FlowDeclareModule {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = super.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode());\n      // @ts-expect-error refine typings\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode<N.ImportDeclaration>();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(tt._type) && !this.match(tt._typeof)) {\n            this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          super.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            tt._declare,\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n          // @ts-expect-error refine typings\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind: \"CommonJS\" | \"ES\" | null = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n              at: bodyElement,\n            });\n          }\n          if (kind === \"ES\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n              at: bodyElement,\n            });\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: Undone<N.FlowDeclareExportDeclaration>,\n      insideModule?: boolean | null,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(tt._type) || this.isContextual(tt._interface)) &&\n            !insideModule)\n        ) {\n          const label = this.state.value as\n            | \"const\"\n            | \"let\"\n            | \"type\"\n            | \"interface\";\n          throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n            at: this.state.startLoc,\n            unsupportedExportKind: label,\n            suggestion: exportSuggestions[label],\n          });\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(tt._opaque) // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(tt._interface) || // declare export interface ...\n          this.isContextual(tt._type) || // declare export type ...\n          this.isContextual(tt._opaque) // declare export opaque type ...\n        ) {\n          node = this.parseExport(\n            node as Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n          );\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n\n          return node as N.Node;\n        }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: Undone<N.FlowDeclareModuleExports>,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(tt._exports);\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: Undone<N.FlowDeclareTypeAlias>,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      const finished = this.flowParseTypeAlias(node);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareTypeAlias\";\n      return finished;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: Undone<N.FlowDeclareOpaqueType>,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      const finished = this.flowParseOpaqueType(node, true);\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareOpaqueType\";\n      return finished;\n    }\n\n    flowParseDeclareInterface(\n      node: Undone<N.FlowDeclareInterface>,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(\n      node: Undone<N.FlowDeclare>,\n      isClass: boolean = false,\n    ): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BIND_FUNCTION : BIND_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.implements = [];\n      node.mixins = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (this.isContextual(tt._mixins)) {\n        this.next();\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: Undone<N.FlowInterface>): N.FlowInterface {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n          at: this.state.startLoc,\n        });\n      }\n    }\n\n    checkReservedType(word: string, startLoc: Position, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        {\n          at: startLoc,\n          reservedType: word,\n        },\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(\n        this.state.value,\n        this.state.startLoc,\n        declaration,\n      );\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: Undone<N.FlowTypeAlias>): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: Undone<N.FlowOpaqueType>,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(tt._type);\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault: boolean = false): N.TypeParameter {\n      const nodeStartLoc = this.state.startLoc;\n\n      const node = this.startNode<N.TypeParameter>();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      // @ts-expect-error migrate to Babel types\n      node.variance = variance;\n      // @ts-expect-error migrate to Babel types\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        // @ts-expect-error migrate to Babel types\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(FlowErrors.MissingTypeParamDefault, { at: nodeStartLoc });\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode<N.TypeParameterDeclaration>();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      } while (!this.match(tt.gt));\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode<N.FlowInterfaceType>();\n      this.expectContextual(tt._interface);\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? super.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: Undone<N.FlowObjectTypeIndexer>,\n      isStatic: boolean,\n      variance?: N.FlowVariance | null,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: Undone<N.FlowObjectTypeInternalSlot>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.match(tt.lt) || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.start, node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: Undone<N.FlowFunctionTypeAnnotation>,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: Undone<N.FlowObjectTypeCallProperty>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean;\n      allowExact: boolean;\n      allowSpread: boolean;\n      allowProto: boolean;\n      allowInexact: boolean;\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStartLoc: Position | undefined | null = null;\n        let inexactStartLoc: Position | undefined | null = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(tt._proto)) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStartLoc = this.state.startLoc;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(tt._static)) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.loc.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.match(tt.lt)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(tt._get) || this.isContextual(tt._set)) {\n            const lookahead = this.lookahead();\n            if (tokenIsLiteralPropertyName(lookahead.type)) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStartLoc,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStartLoc = this.state.lastTokStartLoc;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStartLoc &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n            at: inexactStartLoc,\n          });\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: Undone<N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty>,\n      isStatic: boolean,\n      protoStartLoc: Position | undefined | null,\n      variance: N.FlowVariance | undefined | null,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(FlowErrors.InexactInsideNonObject, {\n              at: this.state.lastTokStartLoc,\n            });\n          } else if (!allowInexact) {\n            this.raise(FlowErrors.InexactInsideExact, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (variance) {\n            this.raise(FlowErrors.InexactVariance, { at: variance });\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(FlowErrors.UnexpectedSpreadType, {\n            at: this.state.lastTokStartLoc,\n          });\n        }\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.SpreadVariance, { at: variance });\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStartLoc != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.match(tt.lt) || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.start, node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(FlowErrors.ThisParamBannedInConstructor, {\n              at: node.value.this,\n            });\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: Undone<\n        N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty\n      >,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n          { at: property.value.this },\n        );\n      }\n\n      if (length !== paramCount) {\n        this.raise(\n          property.kind === \"get\"\n            ? Errors.BadGetterArity\n            : Errors.BadSetterArity,\n          { at: property },\n        );\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(Errors.BadSetterRestParameter, { at: property });\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startPos?: number,\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      let node: N.Identifier | N.FlowQualifiedTypeIdentifier =\n        id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt<N.FlowQualifiedTypeIdentifier>(\n          startPos,\n          startLoc,\n        );\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startPos: number,\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt(startPos, startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode<N.FlowFunctionTypeParam>();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node });\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: node });\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {\n      params: N.FlowFunctionTypeParam[];\n      rest: N.FlowFunctionTypeParam | undefined | null;\n      _this: N.FlowFunctionTypeParam | undefined | null;\n    } {\n      let rest: N.FlowFunctionTypeParam | undefined | null = null;\n      let _this: N.FlowFunctionTypeParam | undefined | null = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startPos: number,\n      startLoc: Position,\n      node: Undone<N.FlowTypeAnnotation>,\n      id: N.Identifier,\n    ): N.FlowTypeAnnotation {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.lt:\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(tt.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.parenL:\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.string:\n          return this.parseLiteral<N.StringLiteralTypeAnnotation>(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode(\n            node as Undone<N.BooleanLiteralTypeAnnotation>,\n            \"BooleanLiteralTypeAnnotation\",\n          );\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteralAtNode<N.NumberLiteralTypeAnnotation>(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteralAtNode<N.BigIntLiteralTypeAnnotation>(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n              at: this.state.startLoc,\n            });\n          }\n\n          throw this.unexpected();\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        case tt._typeof:\n          return this.flowParseTypeofType();\n\n        default:\n          if (tokenIsKeyword(this.state.type)) {\n            const label = tokenLabelName(this.state.type);\n            this.next();\n            return super.createIdentifier(node as Undone<N.Identifier>, label);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            if (this.isContextual(tt._interface)) {\n              return this.flowParseInterfaceType();\n            }\n\n            return this.flowIdentToTypeAnnotation(\n              startPos,\n              startLoc,\n              node,\n              this.parseIdentifier(),\n            );\n          }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowTypeAnnotation {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      let seenOptionalIndexedAccess = false;\n      while (\n        (this.match(tt.bracketL) || this.match(tt.questionDot)) &&\n        !this.canInsertSemicolon()\n      ) {\n        const node = this.startNodeAt(startPos, startLoc);\n        const optional = this.eat(tt.questionDot);\n        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n        this.expect(tt.bracketL);\n        if (!optional && this.match(tt.bracketR)) {\n          node.elementType = type;\n          this.next(); // eat `]`\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        } else {\n          node.objectType = type;\n          node.indexType = this.flowParseType();\n          this.expect(tt.bracketR);\n          if (seenOptionalIndexedAccess) {\n            node.optional = optional;\n            type = this.finishNode<N.FlowOptionalIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"OptionalIndexedAccessType\",\n            );\n          } else {\n            type = this.finishNode<N.FlowIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"IndexedAccessType\",\n            );\n          }\n        }\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startPos, startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\n      const node = this.startNode<N.FlowTypeAnnotation>();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.Node): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    flowParseVariance(): N.FlowVariance | undefined | null {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode<N.FlowVariance>();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        return this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n      }\n\n      return super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode<N.TypeAnnotation>();\n\n        [\n          typeNode.typeAnnotation,\n          // @ts-expect-error predicate may not exist\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatement(context?: string | null, topLevel?: boolean): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.isContextual(tt._interface)) {\n        const lookahead = this.lookahead();\n        if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n          const node = this.startNode<N.FlowInterface>();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatement(context, topLevel);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            tokenIsIdentifier(this.state.type) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            // @ts-expect-error: refine typings\n            return this.flowParseDeclare(node);\n          }\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (expr.name === \"interface\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return !this.state.containsEsc;\n      }\n      return super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return this.state.containsEsc;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startPos, startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(FlowErrors.AmbiguousConditionalArrow, {\n            at: state.startLoc,\n          });\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          noArrowAt.push(valid[0].start);\n          this.state.noArrowAt = noArrowAt;\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression;\n      failed: boolean;\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            // @ts-expect-error: refine typings\n            this.finishArrowValidation(node);\n          } else {\n            // @ts-expect-error: refine typings\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        node.params as any as N.Expression[],\n        node.extra?.trailingCommaLoc,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(\n      node: Undone<N.Node>,\n      parse: () => T,\n    ): T {\n      let result: T;\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(\n      node: N.Expression,\n      startPos: number,\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startPos, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(\n      node: Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n    ): N.AnyExport {\n      const decl = super.parseExport(node);\n      if (\n        decl.type === \"ExportNamedDeclaration\" ||\n        decl.type === \"ExportAllDeclaration\"\n      ) {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n      return decl;\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (this.isContextual(tt._type)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers(\n            /* isInTypeExport */ true,\n          );\n          super.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          // @ts-expect-error: refine typings\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(tt._opaque)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        // @ts-expect-error: refine typings\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(tt._interface)) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node: N.Node): boolean {\n      if (super.eatExportStar(node)) return true;\n\n      if (this.isContextual(tt._type) && this.lookahead().type === tt.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n      const { startLoc } = this.state;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(startLoc);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n    ) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const { startLoc } = this.state;\n      if (this.isContextual(tt._declare)) {\n        if (super.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(FlowErrors.DeclareClassElement, { at: startLoc });\n        } else if (member.value) {\n          this.raise(FlowErrors.DeclareClassFieldInitializer, {\n            at: member.value,\n          });\n        }\n      }\n    }\n\n    isIterator(word: string): boolean {\n      return word === \"iterator\" || word === \"asyncIterator\";\n    }\n\n    readIterator(): void {\n      const word = super.readWord1();\n      const fullWord = \"@@\" + word;\n\n      // Allow @@iterator and @@asyncIterator as a identifier only inside type\n      if (!this.isIterator(word) || !this.state.inType) {\n        this.raise(Errors.InvalidIdentifier, {\n          at: this.state.curPosition(),\n          identifierName: fullWord,\n        });\n      }\n\n      this.finishToken(tt.name, fullWord);\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        return this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        return this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        if (next === charCodes.dot) {\n          return this.finishOp(tt.questionDot, 2);\n        }\n        // allow double nullable types in Flow: ??string\n        return this.finishOp(tt.question, 1);\n      } else if (\n        isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))\n      ) {\n        this.state.pos += 2; // eat \"@@\"\n        return this.readIterator();\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node.type === \"TypeCastExpression\") {\n        return this.isAssignable(node.expression, isBinding);\n      } else {\n        return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (\n        !isLHS &&\n        node.type === \"AssignmentExpression\" &&\n        node.left.type === \"TypeCastExpression\"\n      ) {\n        node.left = this.typeCastToParameter(node.left);\n      }\n      super.toAssignable(node, isLHS);\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList: ReadonlyArray<N.Expression | undefined | null>,\n      isParenthesizedExpr?: boolean,\n    ): ReadonlyArray<N.Expression | undefined | null> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(FlowErrors.TypeCastInPattern, {\n            at: expr.typeAnnotation,\n          });\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {\n      return (\n        type === \"TypeCastExpression\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error refine typings\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n        // estree support\n      } else if (\n        // @ts-expect-error TS does not know about the face that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        // @ts-expect-error estree\n        method.value.params\n      ) {\n        // @ts-expect-error estree\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, { at: method });\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.match(tt.lt)) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(FlowErrors.GetterMayNotHaveThisParam, { at: param });\n        } else if (this.isThisParam(param)) {\n          this.raise(FlowErrors.SetterMayNotHaveThisParam, { at: param });\n        }\n      }\n    }\n\n    parsePropertyNamePrefixOperator(\n      node: N.ObjectOrClassMember | N.ClassMember,\n    ): void {\n      node.variance = this.flowParseVariance();\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startPos: number | undefined | null,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectMethod | N.ObjectProperty {\n      if ((prop as any).variance) {\n        this.unexpected((prop as any).variance.loc.start);\n      }\n      delete (prop as any).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.match(tt.lt) && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      const result = super.parseObjPropValue(\n        prop,\n        startPos,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        (result.value || result).typeParameters = typeParameters;\n      }\n      return result;\n    }\n\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(FlowErrors.PatternIsOptional, { at: param });\n        }\n        if (this.isThisParam(param)) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, { at: param });\n        }\n\n        (param as any as N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamAnnotationRequired, { at: param });\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamNoDefault, { at: param });\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startPos?: number | null,\n      startLoc?: Position | null,\n      left?: N.Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(FlowErrors.TypeBeforeInitializer, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state.type);\n    }\n\n    parseImportSpecifierLocal<\n      T extends\n        | N.ImportSpecifier\n        | N.ImportDefaultSpecifier\n        | N.ImportNamespaceSpecifier,\n    >(node: N.ImportDeclaration, specifier: Undone<T>, type: T[\"type\"]): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      node.specifiers.push(this.finishImportSpecifier(specifier, type));\n    }\n\n    // parse typeof and type imports\n    maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\n      node.importKind = \"value\";\n\n      let kind = null;\n      if (this.match(tt._typeof)) {\n        kind = \"typeof\" as const;\n      } else if (this.isContextual(tt._type)) {\n        kind = \"type\" as const;\n      }\n      if (kind) {\n        const lh = this.lookahead();\n        const { type } = lh;\n\n        // import type * is not allowed\n        if (kind === \"type\" && type === tt.star) {\n          // FIXME: lh.start?\n          this.unexpected(null, lh.type);\n        }\n\n        if (\n          isMaybeDefaultImport(type) ||\n          type === tt.braceL ||\n          type === tt.star\n        ) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isMaybeTypeOnly: boolean,\n    ): N.ImportSpecifier {\n      const firstIdent = specifier.imported;\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(tt._as) && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = cloneIdentifier(as_ident);\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else {\n        if (\n          specifierTypeKind !== null &&\n          tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n        } else {\n          if (importedIsString) {\n            /*:: invariant(firstIdent instanceof N.StringLiteral) */\n            throw this.raise(Errors.ImportBindingIsString, {\n              at: specifier,\n              importName: firstIdent.value,\n            });\n          }\n          /*:: invariant(firstIdent instanceof N.Node) */\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n        }\n\n        if (this.eatContextual(tt._as)) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = cloneIdentifier(specifier.imported);\n        }\n      }\n\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (isInTypeOnlyImport && specifierIsTypeImport) {\n        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n          at: specifier,\n        });\n      }\n\n      if (isInTypeOnlyImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.loc.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.loc.start,\n          true,\n          true,\n        );\n      }\n\n      return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(\n      node: Undone<N.Function>,\n      allowModifiers?: boolean,\n    ): void {\n      // @ts-expect-error\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        // @ts-expect-error: refine typings\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        // @ts-expect-error refine typings\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (jsx?.error || this.match(tt.lt)) {\n        state = state || this.state.clone();\n\n        let typeParameters: N.TypeParameterDeclaration;\n\n        const arrow = this.tryParse(abort => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {});\n          // <T>(() => {}: any);\n          if (arrowExpression.extra?.parenthesized) abort();\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          // (<T>() => {}: any);\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n\n          if (expr.type !== \"ArrowFunctionExpression\") abort();\n\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression:\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n          | undefined\n          | null = null;\n\n        if (\n          arrow.node &&\n          // @ts-expect-error: refine tryParse typings\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            // @ts-expect-error: refine tryParse typings\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n                { at: typeParameters },\n              );\n            }\n            // @ts-expect-error: refine tryParse typings\n            return arrow.node;\n          }\n\n          // @ts-expect-error: refine typings\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n          at: typeParameters,\n        });\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    // handle return types for arrow functions\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error todo(flow->ts)\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode<N.TypeAnnotation>();\n\n          [\n            typeNode.typeAnnotation,\n            // @ts-expect-error (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        // @ts-expect-error todo(flow->ts)\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(params: Array<N.Node>): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow(params);\n    }\n\n    setArrowFunctionParameters(\n      node: N.ArrowFunctionExpression,\n      params: N.Pattern[],\n    ): void {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction?: boolean | null,\n      strictModeChanged: boolean = true,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, { at: node.params[i] });\n        }\n      }\n\n      return super.checkParams(\n        node,\n        allowDuplicates,\n        isArrowFunction,\n        strictModeChanged,\n      );\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls?: boolean | null,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.indexOf(startPos) !== -1\n      ) {\n        this.next();\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.match(tt.lt)\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort =>\n            this.parseAsyncArrowWithTypeParameters(startPos, startLoc) ||\n            abort(),\n          state,\n        );\n\n        /*:: invariant(arrow.node != null) */\n        // @ts-expect-error: refine tryParse typings\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startPos, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          // @ts-expect-error: refine tryParse typings\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node = this.startNodeAt<N.OptionalCallExpression>(\n          startPos,\n          startLoc,\n        );\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(tt.parenL);\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (!noCalls && this.shouldParseTypes() && this.match(tt.lt)) {\n        const node = this.startNodeAt<\n          N.OptionalCallExpression | N.CallExpression\n        >(startPos, startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = super.parseCallExpressionArguments(tt.parenR, false);\n          if (subscriptState.optionalChainMember) {\n            (node as Undone<N.OptionalCallExpression>).optional = false;\n          }\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n        startPos,\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      let targs = null;\n      if (this.shouldParseTypes() && this.match(tt.lt)) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startPos: number,\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined | null {\n      const node = this.startNodeAt<N.ArrowFunctionExpression>(\n        startPos,\n        startLoc,\n      );\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return super.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(FlowErrors.UnterminatedFlowComment, {\n          at: this.state.curPosition(),\n        });\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): N.CommentBlock | undefined {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          throw this.raise(FlowErrors.NestedFlowComment, {\n            at: this.state.startLoc,\n          });\n        }\n        this.hasFlowCommentCompletion();\n        const commentSkip = this.skipFlowComment();\n        if (commentSkip) {\n          this.state.pos += commentSkip;\n          this.state.hasFlowComment = true;\n        }\n        return;\n      }\n\n      if (this.state.hasFlowComment) {\n        const end = this.input.indexOf(\"*-/\", this.state.pos + 2);\n        if (end === -1) {\n          throw this.raise(Errors.UnterminatedComment, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos = end + 2 + 3;\n        return;\n      }\n\n      return super.skipBlockComment();\n    }\n\n    skipFlowComment(): number | false {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          // @ts-expect-error testing whether a number is included\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, {\n          at: this.state.curPosition(),\n        });\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n        at: loc,\n        memberName,\n        enumName,\n      });\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      loc: Position,\n      enumContext: EnumContext,\n    ) {\n      return this.raise(\n        !enumContext.explicitType\n          ? FlowErrors.EnumInvalidMemberInitializerUnknownType\n          : enumContext.explicitType === \"symbol\"\n          ? FlowErrors.EnumInvalidMemberInitializerSymbolType\n          : FlowErrors.EnumInvalidMemberInitializerPrimaryType,\n        {\n          at: loc,\n          ...enumContext,\n        },\n      );\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n        at: loc,\n        enumName,\n        memberName,\n      });\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(\n      node: N.Node,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {\n        at: node,\n        enumName,\n      });\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startLoc = this.state.startLoc;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"number\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt.string: {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"string\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral(this.match(tt._true));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        default:\n          return { type: \"invalid\", loc: startLoc };\n      }\n    }\n\n    flowEnumMemberRaw(): {\n      id: N.Node;\n      init: EnumMemberInit;\n    } {\n      const loc = this.state.startLoc;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\" as const, loc };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      loc: Position,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(loc, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string;\n      explicitType: EnumExplicitType;\n    }): {\n      members: {\n        booleanMembers: Array<N.Node>;\n        numberMembers: Array<N.Node>;\n        stringMembers: Array<N.Node>;\n        defaultedMembers: Array<N.Node>;\n      };\n      hasUnknownMembers: boolean;\n    } {\n      const seenNames = new Set();\n      const members = {\n        // @ts-expect-error: migrate to Babel types\n        booleanMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        numberMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        stringMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.raise(FlowErrors.EnumInvalidMemberName, {\n            at: id,\n            memberName,\n            suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n            enumName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.raise(FlowErrors.EnumDuplicateMemberName, {\n            at: id,\n            memberName,\n            enumName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.loc,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.loc,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n            enumName,\n          });\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n            enumName,\n          });\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string;\n    }): EnumExplicitType {\n      if (!this.eatContextual(tt._of)) return null;\n\n      if (!tokenIsIdentifier(this.state.type)) {\n        throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n          at: this.state.startLoc,\n          enumName,\n        });\n      }\n\n      const { value } = this.state;\n      this.next();\n\n      if (\n        value !== \"boolean\" &&\n        value !== \"number\" &&\n        value !== \"string\" &&\n        value !== \"symbol\"\n      ) {\n        this.raise(FlowErrors.EnumInvalidExplicitType, {\n          at: this.state.startLoc,\n          enumName,\n          invalidEnumType: value,\n        });\n      }\n\n      return value;\n    }\n\n    flowEnumBody(node: Undone<N.Node>, id: N.Node): N.Node {\n      const enumName = id.name;\n      const nameLoc = id.loc.start;\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName,\n            });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(node: Undone<N.Node>): N.Node {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), id);\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    // check if the next token is a tt.lt\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n"],"mappings":"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"}