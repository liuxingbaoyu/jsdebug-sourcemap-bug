{"version":3,"names":["PlaceholderErrors","ParseErrorEnum","ClassNameIsRequired","UnexpectedSpace","superClass","PlaceholdersParserMixin","parsePlaceholder","expectedNode","match","node","startNode","next","assertNoSpace","name","parseIdentifier","expect","finishPlaceholder","isFinished","type","finishNode","getTokenFromCode","code","input","charCodeAt","state","pos","finishOp","parseExprAtom","refExpressionErrors","liberal","checkReservedWord","word","startLoc","checkKeywords","isBinding","undefined","parseBindingAtom","isValidLVal","isParenthesized","binding","toAssignable","isLHS","isLet","context","isContextual","nextToken","lookahead","verifyBreakContinue","isBreak","label","parseExpressionStatement","expr","extra","parenthesized","stmt","body","parseStatement","semicolon","parseBlock","allowDirectives","createNewLexicalScope","afterBlockParse","parseFunctionId","requireId","parseClass","isStatement","optionalId","takeDecorators","oldStrict","strict","placeholder","id","raise","at","parseClassId","parseClassSuper","parseClassBody","parseExport","specifiers","source","declaration","expectPlugin","specifier","exported","isExportDefaultSpecifier","nextTokenStart","isUnparsedContextual","startsWith","tokenLabelName","nextTokenStartSince","maybeParseExportDefaultSpecifier","length","checkExport","filter","parseImport","startNodeAtNode","local","push","eat","hasStarImport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","expectContextual","parseImportSource","start","lastTokEndLoc","index"],"sources":["../../src/plugins/placeholders.ts"],"sourcesContent":["import * as charCodes from \"charcodes\";\n\nimport { tokenLabelName, tt } from \"../tokenizer/types\";\nimport type Parser from \"../parser\";\nimport * as N from \"../types\";\nimport { ParseErrorEnum } from \"../parse-error\";\nimport type { Undone } from \"../parser/node\";\nimport type { ExpressionErrors } from \"../parser/util\";\nimport type { BindingTypes } from \"../util/scopeflags\";\nimport type { Position } from \"../util/location\";\n\ntype PossiblePlaceholedrs = {\n  Identifier: N.Identifier;\n  StringLiteral: N.StringLiteral;\n  Expression: N.Expression;\n  Statement: N.Statement;\n  Declaration: N.Declaration;\n  BlockStatement: N.BlockStatement;\n  ClassBody: N.ClassBody;\n  Pattern: N.Pattern;\n};\nexport type PlaceholderTypes = keyof PossiblePlaceholedrs;\n\ntype NodeOf<T extends keyof PossiblePlaceholedrs> = PossiblePlaceholedrs[T];\n// todo: when there  is proper union type for Node\n// type NodeOf<T extends PlaceholderTypes> = Extract<N.Node, { type: T }>;\n\n// todo: Placeholder<T> breaks everything, because its type is incompatible with\n// the substituted nodes.\ntype MaybePlaceholder<T extends PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\n\n/* eslint sort-keys: \"error\" */\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\",\n});\n\n/* eslint-disable sort-keys */\n\nexport default (superClass: typeof Parser) =>\n  class PlaceholdersParserMixin extends superClass implements Parser {\n    parsePlaceholder<T extends PlaceholderTypes>(\n      expectedNode: T,\n    ): /*?N.Placeholder<T>*/ MaybePlaceholder<T> | undefined | null {\n      if (this.match(tt.placeholder)) {\n        const node = this.startNode();\n        this.next();\n        this.assertNoSpace();\n\n        // We can't use this.parseIdentifier because\n        // we don't want nested placeholders.\n        node.name = super.parseIdentifier(/* liberal */ true);\n\n        this.assertNoSpace();\n        this.expect(tt.placeholder);\n        // @ts-expect-error placeholder typings\n        return this.finishPlaceholder(node, expectedNode);\n      }\n    }\n\n    finishPlaceholder<T extends PlaceholderTypes>(\n      node: N.Node,\n      expectedNode: T,\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\n      const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n      node.expectedNode = expectedNode;\n\n      // @ts-expect-error todo(flow->ts)\n      return isFinished ? node : this.finishNode(node, \"Placeholder\");\n    }\n\n    /* ============================================================ *\n     * tokenizer/index.js                                           *\n     * ============================================================ */\n\n    getTokenFromCode(code: number) {\n      if (\n        code === charCodes.percentSign &&\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\n      ) {\n        return this.finishOp(tt.placeholder, 2);\n      }\n\n      return super.getTokenFromCode(code);\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(\n      refExpressionErrors?: ExpressionErrors | null,\n    ): MaybePlaceholder<\"Expression\"> {\n      return (\n        this.parsePlaceholder(\"Expression\") ||\n        super.parseExprAtom(refExpressionErrors)\n      );\n    }\n\n    parseIdentifier(liberal?: boolean): MaybePlaceholder<\"Identifier\"> {\n      // NOTE: This function only handles identifiers outside of\n      // expressions and binding patterns, since they are already\n      // handled by the parseExprAtom and parseBindingAtom functions.\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal)\n      );\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ) {\n      // Sometimes we call #checkReservedWord(node.name), expecting\n      // that node is an Identifier. If it is a Placeholder, name\n      // will be undefined.\n      if (word !== undefined) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/lval.js                                               *\n     * ============================================================ */\n\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\n      return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingTypes) {\n      return (\n        type === \"Placeholder\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean): void {\n      if (\n        node &&\n        node.type === \"Placeholder\" &&\n        node.expectedNode === \"Expression\"\n      ) {\n        node.expectedNode = \"Pattern\";\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/statement.js                                          *\n     * ============================================================ */\n\n    isLet(context?: string | null): boolean {\n      if (super.isLet(context)) {\n        return true;\n      }\n\n      // Replicate the original checks that lead to looking ahead for an\n      // identifier.\n      if (!this.isContextual(tt._let)) {\n        return false;\n      }\n      if (context) return false;\n\n      // Accept \"let %%\" as the start of \"let %%placeholder%%\", as though the\n      // placeholder were an identifier.\n      const nextToken = this.lookahead();\n      if (nextToken.type === tt.placeholder) {\n        return true;\n      }\n\n      return false;\n    }\n\n    verifyBreakContinue(\n      node: N.BreakStatement | N.ContinueStatement,\n      isBreak: boolean,\n    ) {\n      // @ts-expect-error: node.label could be Placeholder\n      if (node.label && node.label.type === \"Placeholder\") return;\n      super.verifyBreakContinue(node, isBreak);\n    }\n\n    // @ts-expect-error Plugin will override parser interface\n    parseExpressionStatement(\n      node: MaybePlaceholder<\"Statement\">,\n      expr: N.Expression,\n    ): MaybePlaceholder<\"Statement\"> {\n      if (\n        expr.type !== \"Placeholder\" ||\n        (expr.extra && expr.extra.parenthesized)\n      ) {\n        // @ts-expect-error placeholder typings\n        return super.parseExpressionStatement(node, expr);\n      }\n\n      if (this.match(tt.colon)) {\n        // @ts-expect-error\n        const stmt: N.LabeledStatement = node;\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n        this.next();\n        stmt.body = super.parseStatement(\"label\");\n        return this.finishNode(stmt, \"LabeledStatement\");\n      }\n\n      this.semicolon();\n      node.name = expr.name;\n      return this.finishPlaceholder(node, \"Statement\");\n    }\n\n    parseBlock(\n      allowDirectives?: boolean,\n      createNewLexicalScope?: boolean,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): MaybePlaceholder<\"BlockStatement\"> {\n      return (\n        this.parsePlaceholder(\"BlockStatement\") ||\n        super.parseBlock(\n          allowDirectives,\n          createNewLexicalScope,\n          afterBlockParse,\n        )\n      );\n    }\n\n    parseFunctionId(\n      requireId?: boolean,\n    ): MaybePlaceholder<\"Identifier\"> | undefined | null {\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId)\n      );\n    }\n    // @ts-expect-error Plugin will override parser interface\n    parseClass<T extends N.Class>(\n      node: T,\n      isStatement: /* T === ClassDeclaration */ boolean,\n      optionalId?: boolean,\n    ): T {\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n\n      this.next();\n      this.takeDecorators(node);\n      const oldStrict = this.state.strict;\n\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (placeholder) {\n        if (\n          this.match(tt._extends) ||\n          this.match(tt.placeholder) ||\n          this.match(tt.braceL)\n        ) {\n          node.id = placeholder;\n        } else if (optionalId || !isStatement) {\n          node.id = null;\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n          return this.finishNode(node, type);\n        } else {\n          throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n            at: this.state.startLoc,\n          });\n        }\n      } else {\n        this.parseClassId(node, isStatement, optionalId);\n      }\n\n      super.parseClassSuper(node);\n      node.body =\n        this.parsePlaceholder(\"ClassBody\") ||\n        super.parseClassBody(!!node.superClass, oldStrict);\n      return this.finishNode(node, type);\n    }\n\n    parseExport(node: N.Node): N.AnyExport {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseExport(node);\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // export %%DECL%%;\n        node.specifiers = [];\n        node.source = null;\n        node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n\n      // export %%NAME%% from \"foo\";\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = placeholder;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n\n      return super.parseExport(node);\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.match(tt._default)) {\n        const next = this.nextTokenStart();\n        if (this.isUnparsedContextual(next, \"from\")) {\n          if (\n            this.input.startsWith(\n              tokenLabelName(tt.placeholder),\n              this.nextTokenStartSince(next + 4),\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n      return super.isExportDefaultSpecifier();\n    }\n\n    maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n      if (node.specifiers && node.specifiers.length > 0) {\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\n        return true;\n      }\n      return super.maybeParseExportDefaultSpecifier(node);\n    }\n\n    checkExport(node: N.ExportNamedDeclaration): void {\n      const { specifiers } = node;\n      if (specifiers?.length) {\n        node.specifiers = specifiers.filter(\n          // @ts-expect-error placeholder typings\n          node => node.exported.type === \"Placeholder\",\n        );\n      }\n      super.checkExport(node);\n      node.specifiers = specifiers;\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration>,\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseImport(node);\n\n      node.specifiers = [];\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // import %%STRING%%;\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n\n      // import %%DEFAULT%% ...\n      const specifier =\n        this.startNodeAtNode<N.ImportDefaultSpecifier>(placeholder);\n      specifier.local = placeholder;\n      node.specifiers.push(\n        this.finishNode(specifier, \"ImportDefaultSpecifier\"),\n      );\n\n      if (this.eat(tt.comma)) {\n        // import %%DEFAULT%%, * as ...\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n        // import %%DEFAULT%%, { ...\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n      }\n\n      this.expectContextual(tt._from);\n      node.source = this.parseImportSource();\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\n      // import ... from %%STRING%%;\n\n      return (\n        this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource()\n      );\n    }\n\n    // Throws if the current token and the prev one are separated by a space.\n    assertNoSpace(): void {\n      if (this.state.start > this.state.lastTokEndLoc.index) {\n        this.raise(PlaceholderErrors.UnexpectedSpace, {\n          at: this.state.lastTokEndLoc,\n        });\n      }\n    }\n  };\n"],"mappings":"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"}