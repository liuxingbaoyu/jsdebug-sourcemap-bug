{"version":3,"names":["getOwn","object","key","Object","hasOwnProperty","call","nonNull","x","Error","assert","TSErrors","ParseErrorEnum","AbstractMethodHasImplementation","methodName","AbstractPropertyHasInitializer","propertyName","AccesorCannotDeclareThisParameter","AccesorCannotHaveTypeParameters","CannotFindName","name","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference","ConstructorHasTypeParameters","DeclareAccessor","kind","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateAccessibilityModifier","modifier","DuplicateModifier","EmptyHeritageClauseType","token","EmptyTypeArguments","EmptyTypeParameters","ExpectedAmbientAfterExportDeclare","ImportAliasHasImportType","IncompatibleModifiers","modifiers","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasDeclare","IndexSignatureHasOverride","IndexSignatureHasStatic","InitializerNotAllowedInAmbientContext","InvalidModifierOnTypeMember","InvalidModifierOnTypeParameter","InvalidModifierOnTypeParameterPositions","InvalidModifiersOrder","orderedModifiers","InvalidPropertyAccessAfterInstantiationExpression","InvalidTupleMemberLabel","MissingInterfaceName","MixedLabeledAndUnlabeledElements","NonAbstractClassHasAbstractMethod","NonClassMethodPropertyHasAbstractModifer","OptionalTypeBeforeRequired","OverrideNotInSubClass","PatternIsOptional","PrivateElementHasAbstract","PrivateElementHasAccessibility","ReadonlyForMethodSignature","ReservedArrowTypeParam","ReservedTypeAssertion","SetAccesorCannotHaveOptionalParameter","SetAccesorCannotHaveRestParameter","SetAccesorCannotHaveReturnType","SingleTypeParameterWithoutTrailingComma","typeParameterName","StaticBlockCannotHaveModifier","TypeAnnotationAfterAssign","TypeImportCannotSpecifyDefaultAndNamed","TypeModifierIsUsedInTypeExports","TypeModifierIsUsedInTypeImports","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","type","keywordTypeFromName","value","undefined","tsIsAccessModifier","tsIsVarianceAnnotations","superClass","TypeScriptParserMixin","getScopeHandler","TypeScriptScopeHandler","tsIsIdentifier","tokenIsIdentifier","state","tsTokenCanFollowModifier","match","isLiteralPropertyName","hasPrecedingLineBreak","tsNextTokenCanFollowModifier","next","tsParseModifier","allowedModifiers","stopOnStartOfClassStaticBlock","indexOf","tsIsStartOfStaticBlocks","tsTryParse","bind","tsParseModifiers","modified","disallowedModifiers","errorTemplate","enforceOrder","loc","before","after","raise","at","incompatible","mod1","mod2","startLoc","concat","accessibility","includes","tsIsListTerminator","tsParseList","parseElement","result","push","tsParseDelimitedList","refTrailingCommaPos","tsParseDelimitedListWorker","expectSuccess","trailingCommaPos","element","eat","lastTokStart","expect","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","node","startNode","argument","parseExprAtom","qualifier","tsParseEntityName","typeParameters","tsParseTypeArguments","finishNode","allowReservedWords","entity","parseIdentifier","startNodeAtNode","left","right","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","typeAnnotation","tsParseTypeAnnotation","asserts","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseInOutModifiers","tsParseNoneModifiers","tsParseTypeParameter","parseModifiers","tsParseTypeParameterName","constraint","tsEatThenParseType","default","tsTryParseTypeParameters","tsParseTypeParameters","unexpected","params","length","addExtra","tsTryNextParseConstantContext","lookahead","typeReference","tsFillSignature","returnToken","signature","returnTokenRequired","paramsKey","process","env","BABEL_8_BREAKING","returnTypeKey","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","map","pattern","tsParseTypeMemberSemicolon","isLineTerminator","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","id","resetEndLocation","parameters","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","optional","nodeAny","method","curPosition","Errors","BadGetterArity","isThisParam","BadSetterArity","firstParameter","property","tsParseTypeMember","createIdentifier","idx","parsePropertyName","computed","tsParseTypeLiteral","members","tsParseObjectTypeMembers","tsIsStartOfMappedType","isContextual","tsParseMappedTypeParameter","tsExpectThenParseType","tsParseMappedType","expectContextual","eatContextual","typeParameter","nameType","tsParseType","tsTryParseType","semicolon","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","labeledElements","forEach","elementNode","checkType","isLabeled","start","startPos","rest","labeled","labeledNode","label","elementType","optionalTypeNode","restNode","startNodeAt","tsParseParenthesizedType","tsParseFunctionOrConstructorType","abstract","tsInAllowConditionalTypesContext","tsParseLiteralTypeNode","literal","tsParseTemplateLiteralType","parseTemplate","parseTemplateSubstitution","inType","tsParseThisTypeOrThisTypePredicate","thisKeyword","tsParseNonArrayType","nextToken","parseMaybeUnary","options","createParenthesizedExpressions","nodeType","lookaheadCharCode","tsParseArrayTypeOrHigher","objectType","indexType","tsParseTypeOperator","operator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","tsParseConstraintForInferType","tsInDisallowConditionalTypesContext","inDisallowConditionalTypesContext","isTypeOperator","tokenIsTSTypeOperator","containsEsc","tsParseUnionOrIntersectionType","parseConstituentType","hasLeadingOperator","types","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","errors","previousErrorCount","parseObjectLike","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","resetStartLocationFromNode","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","InvalidEscapedReservedWord","lastTokStartLoc","reservedWord","eatColon","tsParseNonConditionalType","extendsType","trueType","falseType","isAbstractConstructorSignature","tsParseTypeAssertion","getPluginOption","_const","tsNextThenParseType","expression","tsParseHeritageClause","originalStartLoc","delimitedList","tsParseInterfaceDeclaration","properties","hasFollowingLineBreak","declare","checkIdentifier","BIND_TS_INTERFACE","extends","body","tsParseTypeAliasDeclaration","BIND_TS_TYPE","tsInNoContext","cb","oldContext","context","oldInType","oldInDisallowConditionalTypesContext","tsDoThenParseType","tsParseEnumMember","parseStringLiteral","initializer","parseMaybeAssignAllowIn","tsParseEnumDeclaration","const","BIND_TS_CONST_ENUM","BIND_TS_ENUM","tsParseModuleBlock","scope","enter","SCOPE_OTHER","parseBlockOrModuleBlockBody","exit","tsParseModuleOrNamespaceDeclaration","nested","BIND_TS_NAMESPACE","inner","SCOPE_TS_MODULE","prodParam","PARAM","tsParseAmbientExternalModuleDeclaration","global","tsParseImportEqualsDeclaration","isExport","BIND_LEXICAL","moduleReference","tsParseModuleReference","importKind","tsIsExternalModuleReference","tsParseExternalModuleReference","f","clone","res","tsTryParseAndCatch","tryParse","abort","aborted","error","failState","tsTryParseDeclare","nany","starttype","tsInAmbientContext","parseFunctionStatement","parseClass","isLookaheadContextual","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","expr","declaration","mod","tsCheckLineTerminator","tsParseAbstractDeclaration","tsTryParseGenericAsyncArrowFunction","oldMaybeInArrowParameters","maybeInArrowParameters","parseFunctionParams","returnType","parseArrowExpression","tsParseTypeArgumentsInExpression","reScan_lt","tsIsDeclarationStart","tokenIsTSDeclarationStart","isExportDefaultSpecifier","parseAssignableListItem","allowModifiers","decorators","override","parseMaybeDefault","parseAssignableListItemTypes","elt","pp","parameter","isSimpleParameter","parseFunctionBodyAndFinish","isMethod","bodilessType","isAmbientContext","registerFunctionStatementId","BIND_TS_AMBIENT","tsCheckForInvalidTypeCasts","items","toReferencedList","exprList","isInParens","parseArrayLike","close","canBePattern","isTuple","refExpressionErrors","elements","parseSubscript","base","noCalls","canStartJSXElement","nonNullExpression","isOptionalCall","stop","optionalChainMember","missingParenErrorLoc","atPossibleAsyncArrow","asyncArrowFn","typeArguments","tokenIsTemplate","parseTaggedTemplateExpression","callee","arguments","parseCallExpressionArguments","finishCallExpression","tokenType","tokenCanStartExpression","parseNewCallee","extra","parenthesized","parseExprOp","leftStartPos","leftStartLoc","minPrec","tokenOperatorPrecedence","reScan_lt_gt","checkReservedWord","word","checkKeywords","isBinding","checkDuplicateExports","parseImport","ahead","importNode","specifiers","parseExport","assign","parseExpression","decl","exportKind","isAbstractClass","parseExportDefaultExpression","cls","allowMissingInitializer","init","declarations","expressions","isPossiblyLiteralEnum","parseStatementContent","topLevel","parseAccessModifier","tsHasSomeModifiers","member","some","parseClassMember","classBody","callParseClassMemberWithIsStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","static","isStatic","inAbstractClass","hadSuperClass","parsePostMemberNameModifiers","methodOrProp","parseExpressionStatement","shouldParseExportDeclaration","parseConditional","setOptionalParametersError","parseParenItem","typeCastNode","parseExportDeclaration","isDeclare","isIdentifier","resetStartLocation","parseClassId","isStatement","optionalId","bindingType","BIND_CLASS","parseClassPropertyAnnotation","definite","parseClassProperty","input","slice","end","parseClassPrivateProperty","pushClassMethod","isGenerator","isAsync","isConstructor","allowsDirectSuper","pushClassPrivateMethod","declareClassPrivateMethodInScope","parseClassSuper","superTypeParameters","implements","parseObjPropValue","prop","isPattern","isAccessor","parseVarId","parseAsyncArrowFromCallExpression","parseMaybeAssign","afterLeftParse","jsx","typeCast","hasPlugin","currentContext","tc","j_oTag","j_expr","pop","arrow","trailingComma","createPositionWithColumnOffset","reportReservedArrowTypeParam","thrown","sawUnary","parseArrow","canInsertSemicolon","param","isAssignable","toAssignable","isLHS","toAssignableParenthesizedExpression","expressionScope","recordArrowParemeterBindingError","typeCastToParameter","checkToRestConversion","allowPattern","isValidLVal","isUnparenthesizedInAssign","binding","TSTypeCastExpression","TSParameterProperty","TSNonNullExpression","TSAsExpression","BIND_NONE","TSTypeAssertion","parseBindingAtom","parseMaybeDecoratorArguments","checkCommaAfterRest","isClassMethod","isClassProperty","getTokenFromCode","code","finishOp","pos","readToken_lt","readToken_gt","toAssignableList","trailingCommaLoc","i","shouldParseArrow","every","shouldParseAsyncArrow","canHaveLeadingDecorator","jsxParseOpeningElementAfterName","getGetterSetterExpectedParamCount","baseCount","getObjectOrClassMethodParams","firstParam","hasContextParam","parseCatchClauseParam","oldIsAmbientContext","oldInAbstractClass","parseMethod","allowDirectSuper","inClassScope","hasBody","shouldParseAsAmbientContext","parse","getExpression","parseExportSpecifier","isString","isInTypeExport","isMaybeTypeOnly","parseTypeOnlyImportExportSpecifier","parseImportSpecifier","specifier","importedIsString","isInTypeOnlyImport","BIND_TS_TYPE_IMPORT","BIND_FLAGS_TS_IMPORT","isImport","isInTypeOnlyImportExport","leftOfAsKey","rightOfAsKey","leftOfAs","rightOfAs","hasTypeSpecifier","canParseAsKeyword","firstAs","secondAs","tokenIsKeywordOrIdentifier","parseModuleExportName","kindKey","cloneIdentifier","isUncomputedMemberExpressionChain"],"sources":["../../../src/plugins/typescript/index.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport type State from \"../../tokenizer/state\";\nimport {\n  tokenIsIdentifier,\n  tokenIsTSDeclarationStart,\n  tokenIsTSTypeOperator,\n  tokenOperatorPrecedence,\n  tokenIsKeywordOrIdentifier,\n  tt,\n  type TokenType,\n  tokenIsTemplate,\n  tokenCanStartExpression,\n} from \"../../tokenizer/types\";\nimport { types as tc } from \"../../tokenizer/context\";\nimport * as N from \"../../types\";\nimport { Position, createPositionWithColumnOffset } from \"../../util/location\";\nimport type Parser from \"../../parser\";\nimport {\n  type BindingTypes,\n  SCOPE_TS_MODULE,\n  SCOPE_OTHER,\n  BIND_TS_ENUM,\n  BIND_TS_CONST_ENUM,\n  BIND_TS_TYPE,\n  BIND_TS_INTERFACE,\n  BIND_TS_AMBIENT,\n  BIND_TS_NAMESPACE,\n  BIND_TS_TYPE_IMPORT,\n  BIND_CLASS,\n  BIND_LEXICAL,\n  BIND_NONE,\n  BIND_FLAGS_TS_IMPORT,\n} from \"../../util/scopeflags\";\nimport TypeScriptScopeHandler from \"./scope\";\nimport * as charCodes from \"charcodes\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { PARAM } from \"../../util/production-parameter\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node\";\nimport type { Pattern } from \"../../types\";\nimport type { Expression } from \"../../types\";\nimport type { IJSXParserMixin } from \"../jsx\";\n\nconst getOwn = <T extends {}>(object: T, key: keyof T) =>\n  Object.hasOwnProperty.call(object, key) && object[key];\n\ntype TsModifier =\n  | \"readonly\"\n  | \"abstract\"\n  | \"declare\"\n  | \"static\"\n  | \"override\"\n  | N.Accessibility\n  | N.VarianceAnnotations;\n\nfunction nonNull<T>(x?: T | null): T {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\n\nfunction assert(x: boolean): void {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\ntype ParsingContext =\n  | \"EnumMembers\"\n  | \"HeritageClauseElement\"\n  | \"TupleElementTypes\"\n  | \"TypeMembers\"\n  | \"TypeParametersOrArguments\";\n\ntype ModifierBase = {\n  accessibility?: N.Accessibility;\n} & {\n  [key in TsModifier]?: boolean | undefined | null;\n};\n\n/* eslint sort-keys: \"error\" */\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({ methodName }: { methodName: string }) =>\n    `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName,\n  }: {\n    propertyName: string;\n  }) =>\n    `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter:\n    \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  CannotFindName: ({ name }: { name: string }) => `Cannot find name '${name}'.`,\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:\n    \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters:\n    \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({ kind }: { kind: \"get\" | \"set\" }) =>\n    `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer:\n    \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation:\n    \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier:\n    // `Accessibility modifier already seen: ${modifier}` would be more helpful.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ({ modifier }: { modifier: N.Accessibility }) =>\n      `Accessibility modifier already seen.`,\n  DuplicateModifier: ({ modifier }: { modifier: TsModifier }) =>\n    `Duplicate modifier: '${modifier}'.`,\n  // `token` matches the terminology used by typescript:\n  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915\n  EmptyHeritageClauseType: ({ token }: { token: \"extends\" | \"implements\" }) =>\n    `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare:\n    \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  IncompatibleModifiers: ({\n    modifiers,\n  }: {\n    modifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract:\n    \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare:\n    \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride:\n    \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic:\n    \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext:\n    \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier,\n  }: {\n    modifier: TsModifier;\n  }) =>\n    `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers,\n  }: {\n    orderedModifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression:\n    \"Invalid property access after an instantiation expression. \" +\n    \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel:\n    \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName:\n    \"'interface' declarations must be followed by an identifier.\",\n  MixedLabeledAndUnlabeledElements:\n    \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod:\n    \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer:\n    \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired:\n    \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass:\n    \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional:\n    \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract:\n    \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature:\n    \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam:\n    \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion:\n    \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter:\n    \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter:\n    \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType:\n    \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName,\n  }: {\n    typeParameterName: string;\n  }) =>\n    `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier:\n    \"Static class blocks cannot have any modifier.\",\n  TypeAnnotationAfterAssign:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed:\n    \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports:\n    \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports:\n    \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier:\n    \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly:\n    \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument:\n    \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind:\n    \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({ type }: { type: string }) =>\n    `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n});\n\n/* eslint-disable sort-keys */\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\n// It also doesn't handle \"intrinsic\", since usually it's not a keyword.\nfunction keywordTypeFromName(\n  value: string,\n): N.TsKeywordTypeType | typeof undefined {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier: string): modifier is N.Accessibility {\n  return (\n    modifier === \"private\" || modifier === \"public\" || modifier === \"protected\"\n  );\n}\n\nfunction tsIsVarianceAnnotations(\n  modifier: string,\n): modifier is N.VarianceAnnotations {\n  return modifier === \"in\" || modifier === \"out\";\n}\n\ntype ClassWithMixin<\n  T extends new (...args: any) => any,\n  M extends object,\n> = T extends new (...args: infer P) => infer I\n  ? new (...args: P) => I & M\n  : never;\n\nexport default (superClass: ClassWithMixin<typeof Parser, IJSXParserMixin>) =>\n  class TypeScriptParserMixin extends superClass implements Parser {\n    getScopeHandler(): {\n      new (...args: any): TypeScriptScopeHandler;\n    } {\n      return TypeScriptScopeHandler;\n    }\n\n    tsIsIdentifier(): boolean {\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n      // See https://github.com/Microsoft/TypeScript/issues/15008\n      return tokenIsIdentifier(this.state.type);\n    }\n\n    tsTokenCanFollowModifier() {\n      return (\n        (this.match(tt.bracketL) ||\n          this.match(tt.braceL) ||\n          this.match(tt.star) ||\n          this.match(tt.ellipsis) ||\n          this.match(tt.privateName) ||\n          this.isLiteralPropertyName()) &&\n        !this.hasPrecedingLineBreak()\n      );\n    }\n\n    tsNextTokenCanFollowModifier() {\n      // Note: TypeScript's implementation is much more complicated because\n      // more things are considered modifiers there.\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\n      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n\n    /** Parses a modifier matching one the given modifier names. */\n    tsParseModifier<T extends TsModifier>(\n      allowedModifiers: T[],\n      stopOnStartOfClassStaticBlock?: boolean,\n    ): T | undefined | null {\n      if (!tokenIsIdentifier(this.state.type) && this.state.type !== tt._in) {\n        return undefined;\n      }\n\n      const modifier = this.state.value;\n      if (allowedModifiers.indexOf(modifier) !== -1) {\n        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n          return undefined;\n        }\n        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n          return modifier;\n        }\n      }\n      return undefined;\n    }\n\n    /** Parses a list of modifiers, in any order.\n     *  If you need a specific order, you must call this function multiple times:\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"public\"] });\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"abstract\", \"readonly\"] });\n     */\n    tsParseModifiers({\n      modified,\n      allowedModifiers,\n      disallowedModifiers,\n      stopOnStartOfClassStaticBlock,\n      errorTemplate = TSErrors.InvalidModifierOnTypeMember,\n    }: {\n      modified: ModifierBase;\n      allowedModifiers: readonly TsModifier[];\n      disallowedModifiers?: TsModifier[];\n      stopOnStartOfClassStaticBlock?: boolean;\n      // FIXME: make sure errorTemplate can receive `modifier`\n      errorTemplate?: any;\n    }): void {\n      const enforceOrder = (\n        loc: Position,\n        modifier: TsModifier,\n        before: TsModifier,\n        after: TsModifier,\n      ) => {\n        if (modifier === before && modified[after]) {\n          this.raise(TSErrors.InvalidModifiersOrder, {\n            at: loc,\n            orderedModifiers: [before, after],\n          });\n        }\n      };\n      const incompatible = (\n        loc: Position,\n        modifier: TsModifier,\n        mod1: TsModifier,\n        mod2: TsModifier,\n      ) => {\n        if (\n          (modified[mod1] && modifier === mod2) ||\n          (modified[mod2] && modifier === mod1)\n        ) {\n          this.raise(TSErrors.IncompatibleModifiers, {\n            at: loc,\n            modifiers: [mod1, mod2],\n          });\n        }\n      };\n\n      for (;;) {\n        const { startLoc } = this.state;\n        const modifier: TsModifier | undefined | null = this.tsParseModifier(\n          allowedModifiers.concat(disallowedModifiers ?? []),\n          stopOnStartOfClassStaticBlock,\n        );\n\n        if (!modifier) break;\n\n        if (tsIsAccessModifier(modifier)) {\n          if (modified.accessibility) {\n            this.raise(TSErrors.DuplicateAccessibilityModifier, {\n              at: startLoc,\n              modifier,\n            });\n          } else {\n            enforceOrder(startLoc, modifier, modifier, \"override\");\n            enforceOrder(startLoc, modifier, modifier, \"static\");\n            enforceOrder(startLoc, modifier, modifier, \"readonly\");\n\n            modified.accessibility = modifier;\n          }\n        } else if (tsIsVarianceAnnotations(modifier)) {\n          if (modified[modifier]) {\n            this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });\n          }\n          modified[modifier] = true;\n\n          enforceOrder(startLoc, modifier, \"in\", \"out\");\n        } else {\n          if (Object.hasOwnProperty.call(modified, modifier)) {\n            this.raise(TSErrors.DuplicateModifier, { at: startLoc, modifier });\n          } else {\n            enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"static\", \"override\");\n            enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n\n            incompatible(startLoc, modifier, \"declare\", \"override\");\n            incompatible(startLoc, modifier, \"static\", \"abstract\");\n          }\n          modified[modifier] = true;\n        }\n\n        if (disallowedModifiers?.includes(modifier)) {\n          this.raise(errorTemplate, {\n            at: startLoc,\n            modifier,\n          });\n        }\n      }\n    }\n\n    tsIsListTerminator(kind: ParsingContext): boolean {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(tt.braceR);\n        case \"HeritageClauseElement\":\n          return this.match(tt.braceL);\n        case \"TupleElementTypes\":\n          return this.match(tt.bracketR);\n        case \"TypeParametersOrArguments\":\n          return this.match(tt.gt);\n      }\n\n      throw new Error(\"Unreachable\");\n    }\n\n    tsParseList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n    ): T[] {\n      const result: T[] = [];\n      while (!this.tsIsListTerminator(kind)) {\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n        result.push(parseElement());\n      }\n      return result;\n    }\n\n    tsParseDelimitedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      return nonNull(\n        this.tsParseDelimitedListWorker(\n          kind,\n          parseElement,\n          /* expectSuccess */ true,\n          refTrailingCommaPos,\n        ),\n      );\n    }\n\n    /**\n     * If !expectSuccess, returns undefined instead of failing to parse.\n     * If expectSuccess, parseElement should always return a defined value.\n     */\n    tsParseDelimitedListWorker<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T | undefined | null,\n      expectSuccess: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] | undefined | null {\n      const result = [];\n      let trailingCommaPos = -1;\n\n      for (;;) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n        trailingCommaPos = -1;\n\n        const element = parseElement();\n        if (element == null) {\n          return undefined;\n        }\n        result.push(element);\n\n        if (this.eat(tt.comma)) {\n          trailingCommaPos = this.state.lastTokStart;\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          // This will fail with an error about a missing comma\n          this.expect(tt.comma);\n        }\n        return undefined;\n      }\n\n      if (refTrailingCommaPos) {\n        refTrailingCommaPos.value = trailingCommaPos;\n      }\n\n      return result;\n    }\n\n    tsParseBracketedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      bracket: boolean,\n      skipFirstToken: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(tt.bracketL);\n        } else {\n          this.expect(tt.lt);\n        }\n      }\n\n      const result = this.tsParseDelimitedList(\n        kind,\n        parseElement,\n        refTrailingCommaPos,\n      );\n\n      if (bracket) {\n        this.expect(tt.bracketR);\n      } else {\n        this.expect(tt.gt);\n      }\n\n      return result;\n    }\n\n    tsParseImportType(): N.TsImportType {\n      const node = this.startNode<N.TsImportType>();\n      this.expect(tt._import);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.raise(TSErrors.UnsupportedImportTypeArgument, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.argument = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n\n      if (this.eat(tt.dot)) {\n        // In this instance, the entity name will actually itself be a\n        // qualifier, so allow it to be a reserved word as well.\n        node.qualifier = this.tsParseEntityName();\n      }\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSImportType\");\n    }\n\n    tsParseEntityName(allowReservedWords: boolean = true): N.TsEntityName {\n      let entity: N.TsEntityName = this.parseIdentifier(allowReservedWords);\n      while (this.eat(tt.dot)) {\n        const node: Undone<N.TsQualifiedName> =\n          this.startNodeAtNode<N.TsQualifiedName>(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(allowReservedWords);\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n      return entity;\n    }\n\n    tsParseTypeReference(): N.TsTypeReference {\n      const node = this.startNode<N.TsTypeReference>();\n      node.typeName = this.tsParseEntityName();\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeReference\");\n    }\n\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\n      this.next();\n      const node = this.startNodeAtNode<N.TsTypePredicate>(lhs);\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\n      node.asserts = false;\n      return this.finishNode(node, \"TSTypePredicate\");\n    }\n\n    tsParseThisTypeNode(): N.TsThisType {\n      const node = this.startNode<N.TsThisType>();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    }\n\n    tsParseTypeQuery(): N.TsTypeQuery {\n      const node = this.startNode<N.TsTypeQuery>();\n      this.expect(tt._typeof);\n      if (this.match(tt._import)) {\n        node.exprName = this.tsParseImportType();\n      } else {\n        node.exprName = this.tsParseEntityName();\n      }\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeQuery\");\n    }\n\n    tsParseInOutModifiers(node: N.TsTypeParameter) {\n      this.tsParseModifiers({\n        modified: node,\n        allowedModifiers: [\"in\", \"out\"],\n        disallowedModifiers: [\n          \"public\",\n          \"private\",\n          \"protected\",\n          \"readonly\",\n          \"declare\",\n          \"abstract\",\n          \"override\",\n        ],\n        errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n      });\n    }\n\n    // for better error recover\n    tsParseNoneModifiers(node: N.TsTypeParameter) {\n      this.tsParseModifiers({\n        modified: node,\n        allowedModifiers: [],\n        disallowedModifiers: [\"in\", \"out\"],\n        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n      });\n    }\n\n    tsParseTypeParameter(\n      parseModifiers: (\n        node: Undone<N.TsTypeParameter>,\n      ) => void = this.tsParseNoneModifiers.bind(this),\n    ): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n\n      parseModifiers(node);\n\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsEatThenParseType(tt._extends);\n      node.default = this.tsEatThenParseType(tt.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsTryParseTypeParameters(\n      parseModifiers?: ((node: N.TsTypeParameter) => void) | null,\n    ): N.TsTypeParameterDeclaration | undefined | null {\n      if (this.match(tt.lt)) {\n        return this.tsParseTypeParameters(parseModifiers);\n      }\n    }\n\n    tsParseTypeParameters(\n      parseModifiers?: ((node: N.TsTypeParameter) => void) | null,\n    ) {\n      const node = this.startNode<N.TsTypeParameterDeclaration>();\n\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      const refTrailingCommaPos = { value: -1 };\n\n      node.params = this.tsParseBracketedList(\n        \"TypeParametersOrArguments\",\n        // @ts-expect-error refine typings\n        this.tsParseTypeParameter.bind(this, parseModifiers),\n        /* bracket */ false,\n        /* skipFirstToken */ true,\n        refTrailingCommaPos,\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeParameters, { at: node });\n      }\n      if (refTrailingCommaPos.value !== -1) {\n        this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n      }\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    }\n\n    tsTryNextParseConstantContext(): N.TsTypeReference | undefined | null {\n      if (this.lookahead().type !== tt._const) return null;\n\n      this.next();\n      const typeReference = this.tsParseTypeReference();\n\n      // If the type reference has type parameters, then you are using it as a\n      // type and not as a const signifier. We'll *never* be able to find this\n      // name, since const isn't allowed as a type name. So in this instance we\n      // get to pretend we're the type checker.\n      if (typeReference.typeParameters) {\n        this.raise(TSErrors.CannotFindName, {\n          at: typeReference.typeName,\n          name: \"const\",\n        });\n      }\n\n      return typeReference;\n    }\n\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n    // but here it's always false, because this is only used for types.\n    tsFillSignature(\n      returnToken: TokenType,\n      signature: Undone<N.TsSignatureDeclaration>,\n    ): void {\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n      const returnTokenRequired = returnToken === tt.arrow;\n\n      // https://github.com/babel/babel/issues/9231\n      const paramsKey = process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\";\n      const returnTypeKey = process.env.BABEL_8_BREAKING\n        ? \"returnType\"\n        : \"typeAnnotation\";\n\n      signature.typeParameters = this.tsTryParseTypeParameters();\n      this.expect(tt.parenL);\n      signature[paramsKey] = this.tsParseBindingListForSignature();\n      if (returnTokenRequired) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      } else if (this.match(returnToken)) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      }\n    }\n\n    tsParseBindingListForSignature(): Array<\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern\n    > {\n      return super\n        .parseBindingList(tt.parenR, charCodes.rightParenthesis)\n        .map(pattern => {\n          if (\n            pattern.type !== \"Identifier\" &&\n            pattern.type !== \"RestElement\" &&\n            pattern.type !== \"ObjectPattern\" &&\n            pattern.type !== \"ArrayPattern\"\n          ) {\n            this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n              at: pattern,\n              type: pattern.type,\n            });\n          }\n          return pattern as any;\n        });\n    }\n\n    tsParseTypeMemberSemicolon(): void {\n      if (!this.eat(tt.comma) && !this.isLineTerminator()) {\n        this.expect(tt.semi);\n      }\n    }\n\n    tsParseSignatureMember(\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\n      node: Undone<\n        N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration\n      >,\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\n      this.tsFillSignature(tt.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    }\n\n    tsIsUnambiguouslyIndexSignature() {\n      this.next(); // Skip '{'\n      if (tokenIsIdentifier(this.state.type)) {\n        this.next();\n        return this.match(tt.colon);\n      }\n      return false;\n    }\n\n    tsTryParseIndexSignature(\n      node: Undone<N.TsIndexSignature>,\n    ): N.TsIndexSignature | undefined | null {\n      if (\n        !(\n          this.match(tt.bracketL) &&\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\n        )\n      ) {\n        return undefined;\n      }\n\n      this.expect(tt.bracketL);\n      const id = this.parseIdentifier();\n      id.typeAnnotation = this.tsParseTypeAnnotation();\n      this.resetEndLocation(id); // set end position to end of type\n\n      this.expect(tt.bracketR);\n      node.parameters = [id];\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    }\n\n    tsParsePropertyOrMethodSignature(\n      node: N.TsPropertySignature | N.TsMethodSignature,\n      readonly: boolean,\n    ): N.TsPropertySignature | N.TsMethodSignature {\n      if (this.eat(tt.question)) node.optional = true;\n      const nodeAny: any = node;\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        if (readonly) {\n          this.raise(TSErrors.ReadonlyForMethodSignature, { at: node });\n        }\n        const method: N.TsMethodSignature = nodeAny;\n        if (method.kind && this.match(tt.lt)) {\n          this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.tsFillSignature(tt.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        const paramsKey = process.env.BABEL_8_BREAKING\n          ? \"params\"\n          : \"parameters\";\n        const returnTypeKey = process.env.BABEL_8_BREAKING\n          ? \"returnType\"\n          : \"typeAnnotation\";\n        if (method.kind === \"get\") {\n          if (method[paramsKey].length > 0) {\n            this.raise(Errors.BadGetterArity, { at: this.state.curPosition() });\n            if (this.isThisParam(method[paramsKey][0])) {\n              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n          }\n        } else if (method.kind === \"set\") {\n          if (method[paramsKey].length !== 1) {\n            this.raise(Errors.BadSetterArity, { at: this.state.curPosition() });\n          } else {\n            const firstParameter = method[paramsKey][0];\n            if (this.isThisParam(firstParameter)) {\n              this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n            if (\n              firstParameter.type === \"Identifier\" &&\n              firstParameter.optional\n            ) {\n              this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n            if (firstParameter.type === \"RestElement\") {\n              this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n                at: this.state.curPosition(),\n              });\n            }\n          }\n          if (method[returnTypeKey]) {\n            this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n              at: method[returnTypeKey],\n            });\n          }\n        } else {\n          method.kind = \"method\";\n        }\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        const property: N.TsPropertySignature = nodeAny;\n        if (readonly) property.readonly = true;\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    }\n\n    tsParseTypeMember(): N.TsTypeElement {\n      const node: any = this.startNode();\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n      }\n\n      if (this.match(tt._new)) {\n        const id = this.startNode<N.Identifier>();\n        this.next();\n        if (this.match(tt.parenL) || this.match(tt.lt)) {\n          return this.tsParseSignatureMember(\n            \"TSConstructSignatureDeclaration\",\n            node,\n          );\n        } else {\n          node.key = this.createIdentifier(id, \"new\");\n          return this.tsParsePropertyOrMethodSignature(node, false);\n        }\n      }\n\n      this.tsParseModifiers({\n        modified: node,\n        allowedModifiers: [\"readonly\"],\n        disallowedModifiers: [\n          \"declare\",\n          \"abstract\",\n          \"private\",\n          \"protected\",\n          \"public\",\n          \"static\",\n          \"override\",\n        ],\n      });\n\n      const idx = this.tsTryParseIndexSignature(node);\n      if (idx) {\n        return idx;\n      }\n\n      super.parsePropertyName(node);\n      if (\n        !node.computed &&\n        node.key.type === \"Identifier\" &&\n        (node.key.name === \"get\" || node.key.name === \"set\") &&\n        this.tsTokenCanFollowModifier()\n      ) {\n        node.kind = node.key.name;\n        super.parsePropertyName(node);\n      }\n      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n    }\n\n    tsParseTypeLiteral(): N.TsTypeLiteral {\n      const node = this.startNode<N.TsTypeLiteral>();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    }\n\n    tsParseObjectTypeMembers(): Array<N.TsTypeElement> {\n      this.expect(tt.braceL);\n      const members = this.tsParseList(\n        \"TypeMembers\",\n        this.tsParseTypeMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return members;\n    }\n\n    tsIsStartOfMappedType(): boolean {\n      this.next();\n      if (this.eat(tt.plusMin)) {\n        return this.isContextual(tt._readonly);\n      }\n      if (this.isContextual(tt._readonly)) {\n        this.next();\n      }\n      if (!this.match(tt.bracketL)) {\n        return false;\n      }\n      this.next();\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n      this.next();\n      return this.match(tt._in);\n    }\n\n    tsParseMappedTypeParameter(): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsExpectThenParseType(tt._in);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsParseMappedType(): N.TsMappedType {\n      const node = this.startNode<N.TsMappedType>();\n\n      this.expect(tt.braceL);\n\n      if (this.match(tt.plusMin)) {\n        node.readonly = this.state.value;\n        this.next();\n        this.expectContextual(tt._readonly);\n      } else if (this.eatContextual(tt._readonly)) {\n        node.readonly = true;\n      }\n\n      this.expect(tt.bracketL);\n      node.typeParameter = this.tsParseMappedTypeParameter();\n      node.nameType = this.eatContextual(tt._as) ? this.tsParseType() : null;\n\n      this.expect(tt.bracketR);\n\n      if (this.match(tt.plusMin)) {\n        node.optional = this.state.value;\n        this.next();\n        this.expect(tt.question);\n      } else if (this.eat(tt.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"TSMappedType\");\n    }\n\n    tsParseTupleType(): N.TsTupleType {\n      const node = this.startNode<N.TsTupleType>();\n      node.elementTypes = this.tsParseBracketedList(\n        \"TupleElementTypes\",\n        this.tsParseTupleElementType.bind(this),\n        /* bracket */ true,\n        /* skipFirstToken */ false,\n      );\n\n      // Validate the elementTypes to ensure that no mandatory elements\n      // follow optional elements\n      let seenOptionalElement = false;\n      let labeledElements: boolean | null = null;\n      node.elementTypes.forEach(elementNode => {\n        const { type } = elementNode;\n\n        if (\n          seenOptionalElement &&\n          type !== \"TSRestType\" &&\n          type !== \"TSOptionalType\" &&\n          !(type === \"TSNamedTupleMember\" && elementNode.optional)\n        ) {\n          this.raise(TSErrors.OptionalTypeBeforeRequired, {\n            at: elementNode,\n          });\n        }\n\n        seenOptionalElement ||=\n          (type === \"TSNamedTupleMember\" && elementNode.optional) ||\n          type === \"TSOptionalType\";\n\n        // When checking labels, check the argument of the spread operator\n        let checkType = type;\n        if (type === \"TSRestType\") {\n          elementNode = elementNode.typeAnnotation;\n          checkType = elementNode.type;\n        }\n\n        const isLabeled = checkType === \"TSNamedTupleMember\";\n        labeledElements ??= isLabeled;\n        if (labeledElements !== isLabeled) {\n          this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {\n            at: elementNode,\n          });\n        }\n      });\n\n      return this.finishNode(node, \"TSTupleType\");\n    }\n\n    tsParseTupleElementType(): N.TsType | N.TsNamedTupleMember {\n      // parses `...TsType[]`\n\n      const { start: startPos, startLoc } = this.state;\n\n      const rest = this.eat(tt.ellipsis);\n      let type: N.TsType | N.TsNamedTupleMember = this.tsParseType();\n      const optional = this.eat(tt.question);\n      const labeled = this.eat(tt.colon);\n\n      if (labeled) {\n        const labeledNode = this.startNodeAtNode<N.TsNamedTupleMember>(type);\n        labeledNode.optional = optional;\n\n        if (\n          type.type === \"TSTypeReference\" &&\n          !type.typeParameters &&\n          type.typeName.type === \"Identifier\"\n        ) {\n          labeledNode.label = type.typeName as N.Identifier;\n        } else {\n          this.raise(TSErrors.InvalidTupleMemberLabel, { at: type });\n          // This produces an invalid AST, but at least we don't drop\n          // nodes representing the invalid source.\n          // @ts-expect-error\n          labeledNode.label = type;\n        }\n\n        labeledNode.elementType = this.tsParseType();\n        type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n      } else if (optional) {\n        const optionalTypeNode = this.startNodeAtNode<N.TsOptionalType>(type);\n        optionalTypeNode.typeAnnotation = type;\n        type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n      }\n\n      if (rest) {\n        const restNode = this.startNodeAt<N.TsRestType>(startPos, startLoc);\n        restNode.typeAnnotation = type;\n        type = this.finishNode(restNode, \"TSRestType\");\n      }\n\n      return type;\n    }\n\n    tsParseParenthesizedType(): N.TsParenthesizedType {\n      const node = this.startNode<N.TsParenthesizedType>();\n      this.expect(tt.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    }\n\n    tsParseFunctionOrConstructorType(\n      type: \"TSFunctionType\" | \"TSConstructorType\",\n      abstract?: boolean,\n    ): N.TsFunctionOrConstructorType {\n      const node = this.startNode<\n        N.TsFunctionOrConstructorType | N.TsConstructorType\n      >();\n      if (type === \"TSConstructorType\") {\n        // @ts-expect-error\n        node.abstract = !!abstract;\n        if (abstract) this.next();\n        this.next(); // eat `new`\n      }\n      this.tsInAllowConditionalTypesContext(() =>\n        this.tsFillSignature(tt.arrow, node),\n      );\n      return this.finishNode(node, type);\n    }\n\n    tsParseLiteralTypeNode(): N.TsLiteralType {\n      const node = this.startNode<N.TsLiteralType>();\n      // @ts-expect-error refine typings\n      node.literal = (() => {\n        switch (this.state.type) {\n          case tt.num:\n          case tt.bigint:\n          case tt.string:\n          case tt._true:\n          case tt._false:\n            // For compatibility to estree we cannot call parseLiteral directly here\n            return super.parseExprAtom();\n          default:\n            throw this.unexpected();\n        }\n      })();\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    tsParseTemplateLiteralType(): N.TsType {\n      const node = this.startNode<N.TsLiteralType>();\n      node.literal = super.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    parseTemplateSubstitution(): N.TsType | N.Node {\n      if (this.state.inType) return this.tsParseType();\n      return super.parseTemplateSubstitution();\n    }\n\n    tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {\n      const thisKeyword = this.tsParseThisTypeNode();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        return this.tsParseThisTypePredicate(thisKeyword);\n      } else {\n        return thisKeyword;\n      }\n    }\n\n    tsParseNonArrayType(): N.TsType {\n      switch (this.state.type) {\n        case tt.string:\n        case tt.num:\n        case tt.bigint:\n        case tt._true:\n        case tt._false:\n          return this.tsParseLiteralTypeNode();\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            const node = this.startNode<N.TsLiteralType>();\n            const nextToken = this.lookahead();\n            if (nextToken.type !== tt.num && nextToken.type !== tt.bigint) {\n              throw this.unexpected();\n            }\n            // @ts-expect-error: parseMaybeUnary must returns unary expression\n            node.literal = this.parseMaybeUnary();\n            return this.finishNode(node, \"TSLiteralType\");\n          }\n          break;\n        case tt._this:\n          return this.tsParseThisTypeOrThisTypePredicate();\n        case tt._typeof:\n          return this.tsParseTypeQuery();\n        case tt._import:\n          return this.tsParseImportType();\n        case tt.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\n            ? this.tsParseMappedType()\n            : this.tsParseTypeLiteral();\n        case tt.bracketL:\n          return this.tsParseTupleType();\n        case tt.parenL:\n          if (process.env.BABEL_8_BREAKING) {\n            if (!this.options.createParenthesizedExpressions) {\n              const startPos = this.state.start;\n              this.next();\n              const type = this.tsParseType();\n              this.expect(tt.parenR);\n              this.addExtra(type, \"parenthesized\", true);\n              this.addExtra(type, \"parenStart\", startPos);\n              return type;\n            }\n          }\n\n          return this.tsParseParenthesizedType();\n        case tt.templateNonTail:\n        case tt.templateTail:\n          return this.tsParseTemplateLiteralType();\n        default: {\n          const { type } = this.state;\n          if (\n            tokenIsIdentifier(type) ||\n            type === tt._void ||\n            type === tt._null\n          ) {\n            const nodeType =\n              type === tt._void\n                ? \"TSVoidKeyword\"\n                : type === tt._null\n                ? \"TSNullKeyword\"\n                : keywordTypeFromName(this.state.value);\n            if (\n              nodeType !== undefined &&\n              this.lookaheadCharCode() !== charCodes.dot\n            ) {\n              const node = this.startNode<N.TsKeywordType>();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n      }\n\n      throw this.unexpected();\n    }\n\n    tsParseArrayTypeOrHigher(): N.TsType {\n      let type = this.tsParseNonArrayType();\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n        if (this.match(tt.bracketR)) {\n          const node = this.startNodeAtNode<N.TsArrayType>(type);\n          node.elementType = type;\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          const node = this.startNodeAtNode<N.TsIndexedAccessType>(type);\n          node.objectType = type;\n          node.indexType = this.tsParseType();\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSIndexedAccessType\");\n        }\n      }\n      return type;\n    }\n\n    tsParseTypeOperator(): N.TsTypeOperator {\n      const node = this.startNode<N.TsTypeOperator>();\n      const operator = this.state.value;\n      this.next(); // eat operator\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n      if (operator === \"readonly\") {\n        this.tsCheckTypeAnnotationForReadOnly(\n          // @ts-expect-error todo(flow->ts)\n          node,\n        );\n      }\n\n      return this.finishNode(node, \"TSTypeOperator\");\n    }\n\n    tsCheckTypeAnnotationForReadOnly(node: N.Node) {\n      switch (node.typeAnnotation.type) {\n        case \"TSTupleType\":\n        case \"TSArrayType\":\n          return;\n        default:\n          this.raise(TSErrors.UnexpectedReadonly, { at: node });\n      }\n    }\n\n    tsParseInferType(): N.TsInferType {\n      const node = this.startNode<N.TsInferType>();\n      this.expectContextual(tt._infer);\n      const typeParameter = this.startNode<N.TsTypeParameter>();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsTryParse(() =>\n        this.tsParseConstraintForInferType(),\n      );\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    }\n\n    tsParseConstraintForInferType() {\n      if (this.eat(tt._extends)) {\n        const constraint = this.tsInDisallowConditionalTypesContext(() =>\n          this.tsParseType(),\n        );\n        if (\n          this.state.inDisallowConditionalTypesContext ||\n          !this.match(tt.question)\n        ) {\n          return constraint;\n        }\n      }\n    }\n\n    tsParseTypeOperatorOrHigher(): N.TsType {\n      const isTypeOperator =\n        tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n      return isTypeOperator\n        ? this.tsParseTypeOperator()\n        : this.isContextual(tt._infer)\n        ? this.tsParseInferType()\n        : this.tsInAllowConditionalTypesContext(() =>\n            this.tsParseArrayTypeOrHigher(),\n          );\n    }\n\n    tsParseUnionOrIntersectionType(\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\n      parseConstituentType: () => N.TsType,\n      operator: TokenType,\n    ): N.TsType {\n      const node = this.startNode<N.TsUnionType | N.TsIntersectionType>();\n      const hasLeadingOperator = this.eat(operator);\n      const types = [];\n      do {\n        types.push(parseConstituentType());\n      } while (this.eat(operator));\n      if (types.length === 1 && !hasLeadingOperator) {\n        return types[0];\n      }\n      node.types = types;\n      return this.finishNode(node, kind);\n    }\n\n    tsParseIntersectionTypeOrHigher(): N.TsType {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSIntersectionType\",\n        this.tsParseTypeOperatorOrHigher.bind(this),\n        tt.bitwiseAND,\n      );\n    }\n\n    tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSUnionType\",\n        this.tsParseIntersectionTypeOrHigher.bind(this),\n        tt.bitwiseOR,\n      );\n    }\n\n    tsIsStartOfFunctionType() {\n      if (this.match(tt.lt)) {\n        return true;\n      }\n      return (\n        this.match(tt.parenL) &&\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\n      );\n    }\n\n    tsSkipParameterStart(): boolean {\n      if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n        this.next();\n        return true;\n      }\n\n      if (this.match(tt.braceL)) {\n        // Return true if we can parse an object pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          this.parseObjectLike(tt.braceR, true);\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      if (this.match(tt.bracketL)) {\n        this.next();\n        // Return true if we can parse an array pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          super.parseBindingList(\n            tt.bracketR,\n            charCodes.rightSquareBracket,\n            true,\n          );\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\n      this.next();\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n        // ( )\n        // ( ...\n        return true;\n      }\n      if (this.tsSkipParameterStart()) {\n        if (\n          this.match(tt.colon) ||\n          this.match(tt.comma) ||\n          this.match(tt.question) ||\n          this.match(tt.eq)\n        ) {\n          // ( xxx :\n          // ( xxx ,\n          // ( xxx ?\n          // ( xxx =\n          return true;\n        }\n        if (this.match(tt.parenR)) {\n          this.next();\n          if (this.match(tt.arrow)) {\n            // ( xxx ) =>\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    tsParseTypeOrTypePredicateAnnotation(\n      returnToken: TokenType,\n    ): N.TsTypeAnnotation {\n      return this.tsInType(() => {\n        const t = this.startNode<N.TsTypeAnnotation>();\n        this.expect(returnToken);\n\n        const node = this.startNode<N.TsTypePredicate>();\n\n        const asserts = !!this.tsTryParse(\n          this.tsParseTypePredicateAsserts.bind(this),\n        );\n\n        if (asserts && this.match(tt._this)) {\n          // When asserts is false, thisKeyword is handled by tsParseNonArrayType\n          // : asserts this is type\n          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n          // if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`\n          // : asserts this\n          if (thisTypePredicate.type === \"TSThisType\") {\n            node.parameterName = thisTypePredicate as N.TsThisType;\n            node.asserts = true;\n            (node as N.TsTypePredicate).typeAnnotation = null;\n            thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n          } else {\n            this.resetStartLocationFromNode(thisTypePredicate, node);\n            (thisTypePredicate as N.TsTypePredicate).asserts = true;\n          }\n          t.typeAnnotation = thisTypePredicate;\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        const typePredicateVariable =\n          this.tsIsIdentifier() &&\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          if (!asserts) {\n            // : type\n            return this.tsParseTypeAnnotation(/* eatColon */ false, t);\n          }\n\n          // : asserts foo\n          node.parameterName = this.parseIdentifier();\n          node.asserts = asserts;\n          (node as N.TsTypePredicate).typeAnnotation = null;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        // : asserts foo is type\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      });\n    }\n\n    tsTryParseTypeOrTypePredicateAnnotation():\n      | N.TsTypeAnnotation\n      | undefined\n      | null {\n      return this.match(tt.colon)\n        ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon)\n        : undefined;\n    }\n\n    tsTryParseTypeAnnotation(): N.TsTypeAnnotation | undefined | null {\n      return this.match(tt.colon) ? this.tsParseTypeAnnotation() : undefined;\n    }\n\n    tsTryParseType(): N.TsType | undefined | null {\n      return this.tsEatThenParseType(tt.colon);\n    }\n\n    tsParseTypePredicatePrefix(): N.Identifier | undefined | null {\n      const id = this.parseIdentifier();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    }\n\n    tsParseTypePredicateAsserts(): boolean {\n      if (this.state.type !== tt._asserts) {\n        return false;\n      }\n      const containsEsc = this.state.containsEsc;\n      this.next();\n      if (!tokenIsIdentifier(this.state.type) && !this.match(tt._this)) {\n        return false;\n      }\n\n      if (containsEsc) {\n        this.raise(Errors.InvalidEscapedReservedWord, {\n          at: this.state.lastTokStartLoc,\n          reservedWord: \"asserts\",\n        });\n      }\n\n      return true;\n    }\n\n    tsParseTypeAnnotation(\n      eatColon = true,\n      t: Undone<N.TsTypeAnnotation> = this.startNode<N.TsTypeAnnotation>(),\n    ): N.TsTypeAnnotation {\n      this.tsInType(() => {\n        if (eatColon) this.expect(tt.colon);\n        t.typeAnnotation = this.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    }\n\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\n    tsParseType(): N.TsType {\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\n      assert(this.state.inType);\n      const type = this.tsParseNonConditionalType();\n\n      if (\n        this.state.inDisallowConditionalTypesContext ||\n        this.hasPrecedingLineBreak() ||\n        !this.eat(tt._extends)\n      ) {\n        return type;\n      }\n      const node = this.startNodeAtNode<N.TsConditionalType>(type);\n      node.checkType = type;\n\n      node.extendsType = this.tsInDisallowConditionalTypesContext(() =>\n        this.tsParseNonConditionalType(),\n      );\n\n      this.expect(tt.question);\n      node.trueType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      this.expect(tt.colon);\n      node.falseType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      return this.finishNode(node, \"TSConditionalType\");\n    }\n\n    isAbstractConstructorSignature(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._new\n      );\n    }\n\n    tsParseNonConditionalType(): N.TsType {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n      if (this.match(tt._new)) {\n        // As in `new () => Date`\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      } else if (this.isAbstractConstructorSignature()) {\n        // As in `abstract new () => Date`\n        return this.tsParseFunctionOrConstructorType(\n          \"TSConstructorType\",\n          /* abstract */ true,\n        );\n      }\n      return this.tsParseUnionTypeOrHigher();\n    }\n\n    tsParseTypeAssertion(): N.TsTypeAssertion {\n      if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n        this.raise(TSErrors.ReservedTypeAssertion, { at: this.state.startLoc });\n      }\n\n      const node = this.startNode<N.TsTypeAssertion>();\n      const _const = this.tsTryNextParseConstantContext();\n      node.typeAnnotation = _const || this.tsNextThenParseType();\n      this.expect(tt.gt);\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    }\n\n    tsParseHeritageClause(\n      token: \"extends\" | \"implements\",\n    ): Array<N.TsExpressionWithTypeArguments> {\n      const originalStartLoc = this.state.startLoc;\n\n      const delimitedList = this.tsParseDelimitedList(\n        \"HeritageClauseElement\",\n        () => {\n          const node = this.startNode<N.TsExpressionWithTypeArguments>();\n          node.expression = this.tsParseEntityName();\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.tsParseTypeArguments();\n          }\n\n          return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n        },\n      );\n\n      if (!delimitedList.length) {\n        this.raise(TSErrors.EmptyHeritageClauseType, {\n          at: originalStartLoc,\n          token,\n        });\n      }\n\n      return delimitedList;\n    }\n\n    tsParseInterfaceDeclaration(\n      node: Undone<N.TsInterfaceDeclaration>,\n      properties: {\n        declare?: true;\n      } = {},\n    ): N.TsInterfaceDeclaration | undefined | null {\n      if (this.hasFollowingLineBreak()) return null;\n      this.expectContextual(tt._interface);\n      if (properties.declare) node.declare = true;\n      if (tokenIsIdentifier(this.state.type)) {\n        node.id = this.parseIdentifier();\n        this.checkIdentifier(node.id, BIND_TS_INTERFACE);\n      } else {\n        node.id = null;\n        this.raise(TSErrors.MissingInterfaceName, { at: this.state.startLoc });\n      }\n\n      node.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutModifiers.bind(this),\n      );\n      if (this.eat(tt._extends)) {\n        node.extends = this.tsParseHeritageClause(\"extends\");\n      }\n      const body = this.startNode<N.TSInterfaceBody>();\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    }\n\n    tsParseTypeAliasDeclaration(\n      node: N.TsTypeAliasDeclaration,\n    ): N.TsTypeAliasDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BIND_TS_TYPE);\n\n      node.typeAnnotation = this.tsInType(() => {\n        node.typeParameters = this.tsTryParseTypeParameters(\n          this.tsParseInOutModifiers.bind(this),\n        );\n\n        this.expect(tt.eq);\n\n        if (\n          this.isContextual(tt._intrinsic) &&\n          this.lookahead().type !== tt.dot\n        ) {\n          const node = this.startNode<N.TsKeywordType>();\n          this.next();\n          return this.finishNode(node, \"TSIntrinsicKeyword\");\n        }\n\n        return this.tsParseType();\n      });\n\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    }\n\n    tsInNoContext<T>(cb: () => T): T {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    }\n\n    /**\n     * Runs `cb` in a type context.\n     * This should be called one token *before* the first type token,\n     * so that the call to `next()` is run in type context.\n     */\n    tsInType<T>(cb: () => T): T {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    }\n\n    tsInDisallowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsInAllowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = false;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsEatThenParseType(token: TokenType): N.TsType | typeof undefined {\n      return !this.match(token) ? undefined : this.tsNextThenParseType();\n    }\n\n    tsExpectThenParseType(token: TokenType): N.TsType {\n      return this.tsDoThenParseType(() => this.expect(token));\n    }\n\n    tsNextThenParseType(): N.TsType {\n      return this.tsDoThenParseType(() => this.next());\n    }\n\n    tsDoThenParseType(cb: () => void): N.TsType {\n      return this.tsInType(() => {\n        cb();\n        return this.tsParseType();\n      });\n    }\n\n    tsParseEnumMember(): N.TsEnumMember {\n      const node = this.startNode<N.TsEnumMember>();\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n      node.id = this.match(tt.string)\n        ? super.parseStringLiteral(this.state.value)\n        : this.parseIdentifier(/* liberal */ true);\n      if (this.eat(tt.eq)) {\n        node.initializer = super.parseMaybeAssignAllowIn();\n      }\n      return this.finishNode(node, \"TSEnumMember\");\n    }\n\n    tsParseEnumDeclaration(\n      node: Undone<N.TsEnumDeclaration>,\n      properties: {\n        const?: true;\n        declare?: true;\n      } = {},\n    ): N.TsEnumDeclaration {\n      if (properties.const) node.const = true;\n      if (properties.declare) node.declare = true;\n      this.expectContextual(tt._enum);\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(\n        node.id,\n        node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM,\n      );\n\n      this.expect(tt.braceL);\n      node.members = this.tsParseDelimitedList(\n        \"EnumMembers\",\n        this.tsParseEnumMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    }\n\n    tsParseModuleBlock(): N.TsModuleBlock {\n      const node = this.startNode<N.TsModuleBlock>();\n      this.scope.enter(SCOPE_OTHER);\n\n      this.expect(tt.braceL);\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n      super.parseBlockOrModuleBlockBody(\n        (node.body = []),\n        /* directives */ undefined,\n        /* topLevel */ true,\n        /* end */ tt.braceR,\n      );\n      this.scope.exit();\n      return this.finishNode(node, \"TSModuleBlock\");\n    }\n\n    tsParseModuleOrNamespaceDeclaration(\n      node: Undone<N.TsModuleDeclaration>,\n      nested: boolean = false,\n    ): N.TsModuleDeclaration {\n      node.id = this.parseIdentifier();\n\n      if (!nested) {\n        this.checkIdentifier(node.id, BIND_TS_NAMESPACE);\n      }\n\n      if (this.eat(tt.dot)) {\n        const inner = this.startNode<N.TsModuleDeclaration>();\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\n        // @ts-expect-error Fixme: refine typings\n        node.body = inner;\n      } else {\n        this.scope.enter(SCOPE_TS_MODULE);\n        this.prodParam.enter(PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      }\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseAmbientExternalModuleDeclaration(\n      node: N.TsModuleDeclaration,\n    ): N.TsModuleDeclaration {\n      if (this.isContextual(tt._global)) {\n        node.global = true;\n        node.id = this.parseIdentifier();\n      } else if (this.match(tt.string)) {\n        node.id = super.parseStringLiteral(this.state.value);\n      } else {\n        this.unexpected();\n      }\n      if (this.match(tt.braceL)) {\n        this.scope.enter(SCOPE_TS_MODULE);\n        this.prodParam.enter(PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseImportEqualsDeclaration(\n      node: Undone<N.TsImportEqualsDeclaration>,\n      isExport?: boolean,\n    ): N.TsImportEqualsDeclaration {\n      node.isExport = isExport || false;\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BIND_LEXICAL);\n      this.expect(tt.eq);\n      const moduleReference = this.tsParseModuleReference();\n      if (\n        node.importKind === \"type\" &&\n        moduleReference.type !== \"TSExternalModuleReference\"\n      ) {\n        this.raise(TSErrors.ImportAliasHasImportType, {\n          at: moduleReference,\n        });\n      }\n      node.moduleReference = moduleReference;\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    }\n\n    tsIsExternalModuleReference(): boolean {\n      return (\n        this.isContextual(tt._require) &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      );\n    }\n\n    tsParseModuleReference(): N.TsModuleReference {\n      return this.tsIsExternalModuleReference()\n        ? this.tsParseExternalModuleReference()\n        : this.tsParseEntityName(/* allowReservedWords */ false);\n    }\n\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\n      const node = this.startNode<N.TsExternalModuleReference>();\n      this.expectContextual(tt._require);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        throw this.unexpected();\n      }\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.expression = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    }\n\n    // Utilities\n\n    tsLookAhead<T>(f: () => T): T {\n      const state = this.state.clone();\n      const res = f();\n      this.state = state;\n      return res;\n    }\n\n    tsTryParseAndCatch<T extends N.NodeBase | undefined | null>(\n      f: () => T,\n    ): T | undefined | null {\n      const result = this.tryParse(\n        abort =>\n          // @ts-expect-error todo(flow->ts)\n          f() || abort(),\n      );\n\n      if (result.aborted || !result.node) return undefined;\n      if (result.error) this.state = result.failState;\n      // @ts-expect-error refine typings\n      return result.node;\n    }\n\n    tsTryParse<T>(f: () => T | undefined | false): T | undefined {\n      const state = this.state.clone();\n      const result = f();\n      if (result !== undefined && result !== false) {\n        return result;\n      } else {\n        this.state = state;\n        return undefined;\n      }\n    }\n\n    tsTryParseDeclare(nany: any): N.Declaration | undefined | null {\n      if (this.isLineTerminator()) {\n        return;\n      }\n      let starttype = this.state.type;\n      let kind: \"let\" | null;\n\n      if (this.isContextual(tt._let)) {\n        starttype = tt._var;\n        kind = \"let\" as const;\n      }\n\n      // @ts-expect-error refine typings\n      return this.tsInAmbientContext(() => {\n        if (starttype === tt._function) {\n          nany.declare = true;\n          return super.parseFunctionStatement(\n            nany,\n            /* async */ false,\n            /* declarationPosition */ true,\n          );\n        }\n\n        if (starttype === tt._class) {\n          // While this is also set by tsParseExpressionStatement, we need to set it\n          // before parsing the class declaration to know how to register it in the scope.\n          nany.declare = true;\n          return this.parseClass(\n            nany,\n            /* isStatement */ true,\n            /* optionalId */ false,\n          );\n        }\n\n        if (starttype === tt._enum) {\n          return this.tsParseEnumDeclaration(nany, { declare: true });\n        }\n\n        if (starttype === tt._global) {\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n        }\n\n        if (starttype === tt._const || starttype === tt._var) {\n          if (!this.match(tt._const) || !this.isLookaheadContextual(\"enum\")) {\n            nany.declare = true;\n            return this.parseVarStatement(nany, kind || this.state.value, true);\n          }\n\n          // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n          this.expect(tt._const);\n          return this.tsParseEnumDeclaration(nany, {\n            const: true,\n            declare: true,\n          });\n        }\n\n        if (starttype === tt._interface) {\n          const result = this.tsParseInterfaceDeclaration(nany, {\n            declare: true,\n          });\n          if (result) return result;\n        }\n\n        if (tokenIsIdentifier(starttype)) {\n          return this.tsParseDeclaration(\n            nany,\n            this.state.value,\n            /* next */ true,\n          );\n        }\n      });\n    }\n\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n    tsTryParseExportDeclaration(): N.Declaration | undefined | null {\n      return this.tsParseDeclaration(\n        this.startNode(),\n        this.state.value,\n        /* next */ true,\n      );\n    }\n\n    tsParseExpressionStatement(\n      node: Undone<N.TsModuleDeclaration>,\n      expr: N.Identifier,\n    ): N.Declaration | undefined | null {\n      switch (expr.name) {\n        case \"declare\": {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n          break;\n        }\n        case \"global\":\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n          if (this.match(tt.braceL)) {\n            this.scope.enter(SCOPE_TS_MODULE);\n            this.prodParam.enter(PARAM);\n            const mod = node as Undone<N.TsModuleDeclaration>;\n            mod.global = true;\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            this.scope.exit();\n            this.prodParam.exit();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n          break;\n\n        default:\n          return this.tsParseDeclaration(node, expr.name, /* next */ false);\n      }\n    }\n\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n    tsParseDeclaration(\n      node: any,\n      value: string,\n      next: boolean,\n    ): N.Declaration | undefined | null {\n      // no declaration apart from enum can be followed by a line break.\n      switch (value) {\n        case \"abstract\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            (this.match(tt._class) || tokenIsIdentifier(this.state.type))\n          ) {\n            return this.tsParseAbstractDeclaration(node);\n          }\n          break;\n\n        case \"module\":\n          if (this.tsCheckLineTerminator(next)) {\n            if (this.match(tt.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (tokenIsIdentifier(this.state.type)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n          }\n          break;\n\n        case \"namespace\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n          break;\n\n        case \"type\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n          break;\n      }\n    }\n\n    tsCheckLineTerminator(next: boolean) {\n      if (next) {\n        if (this.hasFollowingLineBreak()) return false;\n        this.next();\n        return true;\n      }\n      return !this.isLineTerminator();\n    }\n\n    tsTryParseGenericAsyncArrowFunction(\n      startPos: number,\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined | null {\n      if (!this.match(tt.lt)) {\n        return undefined;\n      }\n\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      this.state.maybeInArrowParameters = true;\n\n      const res: Undone<N.ArrowFunctionExpression> | undefined | null =\n        this.tsTryParseAndCatch(() => {\n          const node = this.startNodeAt<N.ArrowFunctionExpression>(\n            startPos,\n            startLoc,\n          );\n          node.typeParameters = this.tsParseTypeParameters();\n          // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n          super.parseFunctionParams(node);\n          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n          this.expect(tt.arrow);\n          return node;\n        });\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n      if (!res) {\n        return undefined;\n      }\n\n      return super.parseArrowExpression(\n        res,\n        /* params are already set */ null,\n        /* async */ true,\n      );\n    }\n\n    // Used when parsing type arguments from ES productions, where the first token\n    // has been created without state.inType. Thus we need to rescan the lt token.\n    tsParseTypeArgumentsInExpression(): N.TsTypeParameterInstantiation | void {\n      if (this.reScan_lt() !== tt.lt) {\n        return undefined;\n      }\n      return this.tsParseTypeArguments();\n    }\n\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\n      const node = this.startNode<N.TsTypeParameterInstantiation>();\n      node.params = this.tsInType(() =>\n        // Temporarily remove a JSX parsing context, which makes us scan different tokens.\n        this.tsInNoContext(() => {\n          this.expect(tt.lt);\n          return this.tsParseDelimitedList(\n            \"TypeParametersOrArguments\",\n            this.tsParseType.bind(this),\n          );\n        }),\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeArguments, { at: node });\n      }\n      this.expect(tt.gt);\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    }\n\n    tsIsDeclarationStart(): boolean {\n      return tokenIsTSDeclarationStart(this.state.type);\n    }\n\n    // ======================================================\n    // OVERRIDES\n    // ======================================================\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.tsIsDeclarationStart()) return false;\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseAssignableListItem(\n      allowModifiers: boolean | undefined | null,\n      decorators: N.Decorator[],\n    ): N.Pattern | N.TSParameterProperty {\n      // Store original location/position to include modifiers in range\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n\n      let accessibility: N.Accessibility | undefined | null;\n      let readonly = false;\n      let override = false;\n      if (allowModifiers !== undefined) {\n        const modified: ModifierBase = {};\n        this.tsParseModifiers({\n          modified,\n          allowedModifiers: [\n            \"public\",\n            \"private\",\n            \"protected\",\n            \"override\",\n            \"readonly\",\n          ],\n        });\n        accessibility = modified.accessibility;\n        override = modified.override;\n        readonly = modified.readonly;\n        if (\n          allowModifiers === false &&\n          (accessibility || readonly || override)\n        ) {\n          this.raise(TSErrors.UnexpectedParameterModifier, { at: startLoc });\n        }\n      }\n\n      const left = this.parseMaybeDefault();\n      this.parseAssignableListItemTypes(left);\n      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n      if (accessibility || readonly || override) {\n        const pp = this.startNodeAt<N.TSParameterProperty>(startPos, startLoc);\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n        if (override) pp.override = override;\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          this.raise(TSErrors.UnsupportedParameterPropertyKind, { at: pp });\n        }\n        pp.parameter = elt as any as N.Identifier | N.AssignmentPattern;\n        return this.finishNode(pp, \"TSParameterProperty\");\n      }\n\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n\n      return elt;\n    }\n\n    isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {\n      return (\n        (node.type === \"TSParameterProperty\" &&\n          super.isSimpleParameter(node.parameter)) ||\n        super.isSimpleParameter(node)\n      );\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n\n      const bodilessType =\n        type === \"FunctionDeclaration\"\n          ? \"TSDeclareFunction\"\n          : type === \"ClassMethod\" || type === \"ClassPrivateMethod\"\n          ? \"TSDeclareMethod\"\n          : undefined;\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n        return this.finishNode(node, bodilessType);\n      }\n      if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n        this.raise(TSErrors.DeclareFunctionHasImplementation, { at: node });\n        if (\n          // @ts-expect-error\n          node.declare\n        ) {\n          return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        }\n      }\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    registerFunctionStatementId(node: N.Function): void {\n      if (!node.body && node.id) {\n        // Function ids are validated after parsing their body.\n        // For bodyless function, we need to do it here.\n        this.checkIdentifier(node.id, BIND_TS_AMBIENT);\n      } else {\n        super.registerFunctionStatementId(node);\n      }\n    }\n\n    tsCheckForInvalidTypeCasts(items: Array<N.Expression | undefined | null>) {\n      items.forEach(node => {\n        if (node?.type === \"TSTypeCastExpression\") {\n          this.raise(TSErrors.UnexpectedTypeAnnotation, {\n            at: node.typeAnnotation,\n          });\n        }\n      });\n    }\n\n    toReferencedList(\n      exprList: Array<N.Expression | undefined | null>,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isInParens?: boolean,\n    ): Array<N.Expression | undefined | null> {\n      // Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.\n      //\n      // Note that `f<T>(a:b)` goes through a different path and is handled\n      // in `parseSubscript` directly.\n      this.tsCheckForInvalidTypeCasts(exprList);\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      if (node.type === \"ArrayExpression\") {\n        this.tsCheckForInvalidTypeCasts(node.elements);\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\n        // When ! is consumed as a postfix operator (non-null assertion),\n        // disallow JSX tag forming after. e.g. When parsing `p! < n.p!`\n        // `<n.p` can not be a start of JSX tag\n        this.state.canStartJSXElement = false;\n        this.next();\n\n        const nonNullExpression = this.startNodeAt<N.TsNonNullExpression>(\n          startPos,\n          startLoc,\n        );\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      let isOptionalCall = false;\n      if (\n        this.match(tt.questionDot) &&\n        this.lookaheadCharCode() === charCodes.lessThan\n      ) {\n        if (noCalls) {\n          state.stop = true;\n          return base;\n        }\n        state.optionalChainMember = isOptionalCall = true;\n        this.next();\n      }\n\n      // handles 'f<<T>'\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        let missingParenErrorLoc;\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\n        // tagged template expressions. If any of them fail, walk it back and continue.\n        const result = this.tsTryParseAndCatch(() => {\n          if (!noCalls && this.atPossibleAsyncArrow(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(\n              startPos,\n              startLoc,\n            );\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          const typeArguments = this.tsParseTypeArgumentsInExpression();\n          if (!typeArguments) return;\n\n          if (isOptionalCall && !this.match(tt.parenL)) {\n            missingParenErrorLoc = this.state.curPosition();\n            return;\n          }\n\n          if (tokenIsTemplate(this.state.type)) {\n            const result = super.parseTaggedTemplateExpression(\n              base,\n              startPos,\n              startLoc,\n              state,\n            );\n            result.typeParameters = typeArguments;\n            return result;\n          }\n\n          if (!noCalls && this.eat(tt.parenL)) {\n            const node = this.startNodeAt<N.CallExpression>(startPos, startLoc);\n            node.callee = base;\n            // possibleAsync always false here, because we would have handled it above.\n            // @ts-expect-error (won't be any undefined arguments)\n            node.arguments = this.parseCallExpressionArguments(\n              tt.parenR,\n              /* possibleAsync */ false,\n            );\n\n            // Handles invalid case: `f<T>(a:b)`\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n\n            node.typeParameters = typeArguments;\n            if (state.optionalChainMember) {\n              // @ts-expect-error\n              node.optional = isOptionalCall;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          }\n\n          const tokenType = this.state.type;\n          if (\n            // a<b>>c is not (a<b>)>c, but a<(b>>c)\n            tokenType === tt.gt ||\n            // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)\n            tokenType === tt.bitShiftR ||\n            // a<b>c is (a<b)>c\n            (tokenType !== tt.parenL &&\n              tokenCanStartExpression(tokenType) &&\n              !this.hasPrecedingLineBreak())\n          ) {\n            // Bail out.\n            return;\n          }\n\n          const node = this.startNodeAt<N.TsInstantiationExpression>(\n            startPos,\n            startLoc,\n          );\n          node.expression = base;\n          node.typeParameters = typeArguments;\n          return this.finishNode(node, \"TSInstantiationExpression\");\n        });\n\n        if (missingParenErrorLoc) {\n          this.unexpected(missingParenErrorLoc, tt.parenL);\n        }\n\n        if (result) {\n          if (\n            result.type === \"TSInstantiationExpression\" &&\n            (this.match(tt.dot) ||\n              (this.match(tt.questionDot) &&\n                this.lookaheadCharCode() !== charCodes.leftParenthesis))\n          ) {\n            this.raise(\n              TSErrors.InvalidPropertyAccessAfterInstantiationExpression,\n              { at: this.state.startLoc },\n            );\n          }\n          return result;\n        }\n      }\n\n      return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      const { callee } = node;\n      if (\n        callee.type === \"TSInstantiationExpression\" &&\n        !callee.extra?.parenthesized\n      ) {\n        node.typeParameters = callee.typeParameters;\n        node.callee = callee.expression;\n      }\n    }\n\n    parseExprOp(\n      left: N.Expression,\n      leftStartPos: number,\n      leftStartLoc: Position,\n      minPrec: number,\n    ): N.Expression {\n      if (\n        tokenOperatorPrecedence(tt._in) > minPrec &&\n        !this.hasPrecedingLineBreak() &&\n        this.isContextual(tt._as)\n      ) {\n        const node = this.startNodeAt<N.TsAsExpression>(\n          leftStartPos,\n          leftStartLoc,\n        );\n        node.expression = left;\n        const _const = this.tsTryNextParseConstantContext();\n        if (_const) {\n          node.typeAnnotation = _const;\n        } else {\n          node.typeAnnotation = this.tsNextThenParseType();\n        }\n        this.finishNode(node, \"TSAsExpression\");\n        // rescan `<`, `>` because they were scanned when this.state.inType was true\n        this.reScan_lt_gt();\n        return this.parseExprOp(\n          // @ts-expect-error todo(flow->ts)\n          node,\n          leftStartPos,\n          leftStartLoc,\n          minPrec,\n        );\n      }\n\n      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ): void {\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n      if (!this.state.isAmbientContext) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    /*\n    Don't bother doing this check in TypeScript code because:\n    1. We may have a nested export statement with the same name:\n      export const x = 0;\n      export namespace N {\n        export const x = 1;\n      }\n    2. We have a type checker to warn us about this sort of thing.\n    */\n    checkDuplicateExports() {}\n\n    parseImport(\n      node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    ): N.AnyImport {\n      node.importKind = \"value\";\n      if (\n        tokenIsIdentifier(this.state.type) ||\n        this.match(tt.star) ||\n        this.match(tt.braceL)\n      ) {\n        let ahead = this.lookahead();\n\n        if (\n          this.isContextual(tt._type) &&\n          // import type, { a } from \"b\";\n          ahead.type !== tt.comma &&\n          // import type from \"a\";\n          ahead.type !== tt._from &&\n          // import type = require(\"a\");\n          ahead.type !== tt.eq\n        ) {\n          node.importKind = \"type\";\n          this.next();\n          ahead = this.lookahead();\n        }\n\n        if (tokenIsIdentifier(this.state.type) && ahead.type === tt.eq) {\n          return this.tsParseImportEqualsDeclaration(\n            node as Undone<N.TsImportEqualsDeclaration>,\n          );\n        }\n      }\n\n      const importNode = super.parseImport(node as Undone<N.ImportDeclaration>);\n      /*:: invariant(importNode.type !== \"TSImportEqualsDeclaration\") */\n\n      // `import type` can only be used on imports with named imports or with a\n      // default import - but not both\n      if (\n        importNode.importKind === \"type\" &&\n        // @ts-expect-error refine typings\n        importNode.specifiers.length > 1 &&\n        // @ts-expect-error refine typings\n        importNode.specifiers[0].type === \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n          at: importNode,\n        });\n      }\n\n      return importNode;\n    }\n\n    parseExport(node: Undone<N.Node>): N.AnyExport {\n      if (this.match(tt._import)) {\n        // `export import A = B;`\n        this.next(); // eat `tt._import`\n        if (\n          this.isContextual(tt._type) &&\n          this.lookaheadCharCode() !== charCodes.equalsTo\n        ) {\n          node.importKind = \"type\";\n          this.next(); // eat \"type\"\n        } else {\n          node.importKind = \"value\";\n        }\n        return this.tsParseImportEqualsDeclaration(\n          node as Undone<N.TsImportEqualsDeclaration>,\n          /* isExport */ true,\n        );\n      } else if (this.eat(tt.eq)) {\n        // `export = x;`\n        const assign = node as Undone<N.TsExportAssignment>;\n        assign.expression = super.parseExpression();\n        this.semicolon();\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(tt._as)) {\n        // `export as namespace A;`\n        const decl = node as Undone<N.TsNamespaceExportDeclaration>;\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n        this.expectContextual(tt._namespace);\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        if (\n          this.isContextual(tt._type) &&\n          this.lookahead().type === tt.braceL\n        ) {\n          this.next();\n          node.exportKind = \"type\";\n        } else {\n          node.exportKind = \"value\";\n        }\n\n        return super.parseExport(\n          node as Undone<N.ExportAllDeclaration | N.ExportDefaultDeclaration>,\n        );\n      }\n    }\n\n    isAbstractClass(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._class\n      );\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.isAbstractClass()) {\n        const cls = this.startNode<N.Class>();\n        this.next(); // Skip \"abstract\"\n        cls.abstract = true;\n        return this.parseClass(cls, true, true);\n      }\n\n      // export default interface allowed in:\n      // https://github.com/Microsoft/TypeScript/pull/16040\n      if (this.match(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(\n          this.startNode<N.TsInterfaceDeclaration>(),\n        );\n        if (result) return result;\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseVarStatement(\n      node: N.VariableDeclaration,\n      kind: \"var\" | \"let\" | \"const\",\n      allowMissingInitializer: boolean = false,\n    ) {\n      const { isAmbientContext } = this.state;\n      const declaration = super.parseVarStatement(\n        node,\n        kind,\n        allowMissingInitializer || isAmbientContext,\n      );\n\n      if (!isAmbientContext) return declaration;\n\n      for (const { id, init } of declaration.declarations) {\n        // Empty initializer is the easy case that we want.\n        if (!init) continue;\n\n        // var and let aren't ever allowed initializers.\n        //\n        // If a const declaration has no type annotation and is initiailized to\n        // a string literal, numeric literal, or enum reference, then it is\n        // allowed. In an ideal world, we'd check whether init was *actually* an\n        // enum reference, but we allow anything that \"could be\" a literal enum\n        // in `isPossiblyLiteralEnum` since we don't have all the information\n        // that the typescript compiler has.\n        if (kind !== \"const\" || !!id.typeAnnotation) {\n          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n            at: init,\n          });\n        } else if (\n          init.type !== \"StringLiteral\" &&\n          init.type !== \"BooleanLiteral\" &&\n          init.type !== \"NumericLiteral\" &&\n          init.type !== \"BigIntLiteral\" &&\n          (init.type !== \"TemplateLiteral\" || init.expressions.length > 0) &&\n          !isPossiblyLiteralEnum(init)\n        ) {\n          this.raise(\n            TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,\n            { at: init },\n          );\n        }\n      }\n\n      return declaration;\n    }\n\n    parseStatementContent(\n      context?: string | null,\n      topLevel?: boolean | null,\n    ): N.Statement {\n      if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n        const node = this.startNode<N.TsEnumDeclaration>();\n        this.expect(tt._const); // eat 'const'\n        return this.tsParseEnumDeclaration(node, { const: true });\n      }\n\n      if (this.isContextual(tt._enum)) {\n        return this.tsParseEnumDeclaration(\n          this.startNode<N.TsEnumDeclaration>(),\n        );\n      }\n\n      if (this.isContextual(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(this.startNode());\n        if (result) return result;\n      }\n\n      return super.parseStatementContent(context, topLevel);\n    }\n\n    parseAccessModifier(): N.Accessibility | undefined | null {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    }\n\n    tsHasSomeModifiers(member: any, modifiers: readonly TsModifier[]): boolean {\n      return modifiers.some(modifier => {\n        if (tsIsAccessModifier(modifier)) {\n          return member.accessibility === modifier;\n        }\n        return !!member[modifier];\n      });\n    }\n\n    tsIsStartOfStaticBlocks() {\n      return (\n        this.isContextual(tt._static) &&\n        this.lookaheadCharCode() === charCodes.leftCurlyBrace\n      );\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const modifiers = [\n        \"declare\",\n        \"private\",\n        \"public\",\n        \"protected\",\n        \"override\",\n        \"abstract\",\n        \"readonly\",\n        \"static\",\n      ] as const;\n      this.tsParseModifiers({\n        modified: member,\n        allowedModifiers: modifiers,\n        disallowedModifiers: [\"in\", \"out\"],\n        stopOnStartOfClassStaticBlock: true,\n        errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n      });\n\n      const callParseClassMemberWithIsStatic = () => {\n        if (this.tsIsStartOfStaticBlocks()) {\n          this.next(); // eat \"static\"\n          this.next(); // eat \"{\"\n          if (this.tsHasSomeModifiers(member, modifiers)) {\n            this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n              at: this.state.curPosition(),\n            });\n          }\n          super.parseClassStaticBlock(\n            classBody,\n            member as any as N.StaticBlock,\n          );\n        } else {\n          this.parseClassMemberWithIsStatic(\n            classBody,\n            member,\n            state,\n            !!member.static,\n          );\n        }\n      };\n      if (member.declare) {\n        this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n      } else {\n        callParseClassMemberWithIsStatic();\n      }\n    }\n\n    parseClassMemberWithIsStatic(\n      classBody: N.ClassBody,\n      member: Undone<N.ClassMember | N.TsIndexSignature>,\n      state: N.ParseClassMemberState,\n      isStatic: boolean,\n    ): void {\n      const idx = this.tsTryParseIndexSignature(\n        member as Undone<N.TsIndexSignature>,\n      );\n      if (idx) {\n        classBody.body.push(idx);\n\n        if ((member as any).abstract) {\n          this.raise(TSErrors.IndexSignatureHasAbstract, { at: member });\n        }\n        if ((member as any).accessibility) {\n          this.raise(TSErrors.IndexSignatureHasAccessibility, {\n            at: member,\n            modifier: (member as any).accessibility,\n          });\n        }\n        if ((member as any).declare) {\n          this.raise(TSErrors.IndexSignatureHasDeclare, { at: member });\n        }\n        if ((member as any).override) {\n          this.raise(TSErrors.IndexSignatureHasOverride, { at: member });\n        }\n\n        return;\n      }\n\n      if (!this.state.inAbstractClass && (member as any).abstract) {\n        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n          at: member,\n        });\n      }\n\n      if ((member as any).override) {\n        if (!state.hadSuperClass) {\n          this.raise(TSErrors.OverrideNotInSubClass, { at: member });\n        }\n      }\n\n      /*:: invariant(member.type !== \"TSIndexSignature\") */\n\n      super.parseClassMemberWithIsStatic(\n        classBody,\n        member as Undone<N.ClassMember>,\n        state,\n        isStatic,\n      );\n    }\n\n    parsePostMemberNameModifiers(\n      methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      const optional = this.eat(tt.question);\n      if (optional) methodOrProp.optional = true;\n\n      if ((methodOrProp as any).readonly && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasReadonly, { at: methodOrProp });\n      }\n\n      if ((methodOrProp as any).declare && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasDeclare, { at: methodOrProp });\n      }\n    }\n\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\n    // by parsing the rest.\n    // @ts-expect-error plugin overrides interfaces\n    parseExpressionStatement(\n      node: Undone<N.ExpressionStatement>,\n      expr: N.Expression,\n    ): N.Statement {\n      const decl =\n        expr.type === \"Identifier\"\n          ? // @ts-expect-error refine typings\n            this.tsParseExpressionStatement(node, expr)\n          : undefined;\n      return decl || super.parseExpressionStatement(node, expr);\n    }\n\n    // export type\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n    shouldParseExportDeclaration(): boolean {\n      if (this.tsIsDeclarationStart()) return true;\n      return super.shouldParseExportDeclaration();\n    }\n\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\n    parseConditional(\n      expr: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (!this.state.maybeInArrowParameters || !this.match(tt.question)) {\n        return super.parseConditional(\n          expr,\n          startPos,\n          startLoc,\n          refExpressionErrors,\n        );\n      }\n\n      const result = this.tryParse(() =>\n        super.parseConditional(expr, startPos, startLoc),\n      );\n\n      if (!result.node) {\n        if (result.error) {\n          /*:: invariant(refExpressionErrors != null) */\n          super.setOptionalParametersError(refExpressionErrors, result.error);\n        }\n\n        return expr;\n      }\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    // Note: These \"type casts\" are *not* valid TS expressions.\n    // But we parse them here and change them when completing the arrow function.\n    parseParenItem(\n      node: N.Expression,\n      startPos: number,\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startPos, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt<N.TsTypeCastExpression>(\n          startPos,\n          startLoc,\n        );\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (!this.state.isAmbientContext && this.isContextual(tt._declare)) {\n        return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n      }\n\n      // Store original location/position\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n\n      const isDeclare = this.eatContextual(tt._declare);\n\n      if (\n        isDeclare &&\n        (this.isContextual(tt._declare) || !this.shouldParseExportDeclaration())\n      ) {\n        throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n          at: this.state.startLoc,\n        });\n      }\n\n      const isIdentifier = tokenIsIdentifier(this.state.type);\n      const declaration: N.Declaration | undefined | null =\n        (isIdentifier && this.tsTryParseExportDeclaration()) ||\n        super.parseExportDeclaration(node);\n\n      if (!declaration) return null;\n\n      if (\n        declaration.type === \"TSInterfaceDeclaration\" ||\n        declaration.type === \"TSTypeAliasDeclaration\" ||\n        isDeclare\n      ) {\n        node.exportKind = \"type\";\n      }\n\n      if (isDeclare) {\n        // Reset location to include `declare` in range\n        this.resetStartLocation(declaration, startPos, startLoc);\n\n        declaration.declare = true;\n      }\n\n      return declaration;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType?: BindingTypes,\n    ): void {\n      if ((!isStatement || optionalId) && this.isContextual(tt._implements)) {\n        return;\n      }\n\n      super.parseClassId(\n        node,\n        isStatement,\n        optionalId,\n        (node as any).declare ? BIND_TS_AMBIENT : BIND_CLASS,\n      );\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutModifiers.bind(this),\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n    }\n\n    parseClassPropertyAnnotation(\n      node: N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      if (!node.optional && this.eat(tt.bang)) {\n        node.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n    }\n\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      this.parseClassPropertyAnnotation(node);\n\n      if (\n        this.state.isAmbientContext &&\n        !(node.readonly && !node.typeAnnotation) &&\n        this.match(tt.eq)\n      ) {\n        this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n          at: this.state.startLoc,\n        });\n      }\n      if (node.abstract && this.match(tt.eq)) {\n        const { key } = node;\n        this.raise(TSErrors.AbstractPropertyHasInitializer, {\n          at: this.state.startLoc,\n          propertyName:\n            key.type === \"Identifier\" && !node.computed\n              ? key.name\n              : `[${this.input.slice(key.start, key.end)}]`,\n        });\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      // @ts-expect-error\n      if (node.abstract) {\n        this.raise(TSErrors.PrivateElementHasAbstract, { at: node });\n      }\n\n      // @ts-expect-error\n      if (node.accessibility) {\n        this.raise(TSErrors.PrivateElementHasAccessibility, {\n          at: node,\n          // @ts-expect-error refine typings\n          modifier: node.accessibility,\n        });\n      }\n\n      this.parseClassPropertyAnnotation(node);\n      return super.parseClassPrivateProperty(node);\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters && isConstructor) {\n        this.raise(TSErrors.ConstructorHasTypeParameters, {\n          at: typeParameters,\n        });\n      }\n\n      // @ts-expect-error\n      const { declare = false, kind } = method;\n\n      if (declare && (kind === \"get\" || kind === \"set\")) {\n        this.raise(TSErrors.DeclareAccessor, { at: method, kind });\n      }\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    declareClassPrivateMethodInScope(\n      node: N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod,\n      kind: number,\n    ) {\n      if (node.type === \"TSDeclareMethod\") return;\n      // This happens when using the \"estree\" plugin.\n      if (node.type === \"MethodDefinition\" && !node.value.body) return;\n\n      super.declareClassPrivateMethodInScope(node, kind);\n    }\n\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      // handle `extends f<<T>\n      if (node.superClass && (this.match(tt.lt) || this.match(tt.bitShiftL))) {\n        // @ts-expect-error refine typings\n        node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n      }\n      if (this.eatContextual(tt._implements)) {\n        node.implements = this.tsParseHeritageClause(\"implements\");\n      }\n    }\n\n    parseObjPropValue(\n      prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n      startPos: number | undefined | null,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ) {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) prop.typeParameters = typeParameters;\n\n      return super.parseObjPropValue(\n        prop,\n        startPos,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n    }\n\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    // `let x: number;`\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (\n        decl.id.type === \"Identifier\" &&\n        !this.hasPrecedingLineBreak() &&\n        this.eat(tt.bang)\n      ) {\n        decl.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n\n      let state: State | undefined | null;\n      let jsx;\n      let typeCast;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        // Prefer to parse JSX if possible. But may be an arrow fn.\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` or `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (!jsx?.error && !this.match(tt.lt)) {\n        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      }\n\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n      // If the state was cloned in the JSX parsing branch above but there\n      // have been any error in the tryParse call, this.state is set to state\n      // so we still need to clone it.\n      if (!state || state === this.state) state = this.state.clone();\n\n      let typeParameters: N.TsTypeParameterDeclaration | undefined | null;\n      const arrow = this.tryParse(abort => {\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n        typeParameters = this.tsParseTypeParameters();\n        const expr = super.parseMaybeAssign(\n          refExpressionErrors,\n          afterLeftParse,\n        );\n\n        if (\n          expr.type !== \"ArrowFunctionExpression\" ||\n          expr.extra?.parenthesized\n        ) {\n          abort();\n        }\n\n        // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n        if (typeParameters?.params.length !== 0) {\n          this.resetStartLocationFromNode(expr, typeParameters);\n        }\n        expr.typeParameters = typeParameters;\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            this.hasPlugin(\"jsx\") &&\n            expr.typeParameters.params.length === 1 &&\n            !expr.typeParameters.extra?.trailingComma\n          ) {\n            // report error if single type parameter used without trailing comma.\n            const parameter = expr.typeParameters.params[0];\n            if (!parameter.constraint) {\n              // A single type parameter must either have constraints\n              // or a trailing comma, otherwise it's ambiguous with JSX.\n              this.raise(TSErrors.SingleTypeParameterWithoutTrailingComma, {\n                at: createPositionWithColumnOffset(parameter.loc.end, 1),\n                typeParameterName: parameter.name.name,\n              });\n            }\n          }\n        }\n\n        return expr;\n      }, state);\n\n      /*:: invariant(arrow.node != null) */\n      if (!arrow.error && !arrow.aborted) {\n        // This error is reported outside of the this.tryParse call so that\n        // in case of <T>(x) => 2, we don't consider <T>(x) as a type assertion\n        // because of this error.\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        // @ts-expect-error refine typings\n        return arrow.node;\n      }\n\n      if (!jsx) {\n        // Try parsing a type cast instead of an arrow function.\n        // This will never happen outside of JSX.\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n        assert(!this.hasPlugin(\"jsx\"));\n\n        // This will start with a type assertion (via parseMaybeUnary).\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n        typeCast = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n        /*:: invariant(!typeCast.aborted) */\n        /*:: invariant(typeCast.node != null) */\n        if (!typeCast.error) return typeCast.node;\n      }\n\n      if (jsx?.node) {\n        /*:: invariant(jsx.failState) */\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrow.node) {\n        /*:: invariant(arrow.failState) */\n        this.state = arrow.failState;\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        // @ts-expect-error refine typings\n        return arrow.node;\n      }\n\n      if (typeCast?.node) {\n        /*:: invariant(typeCast.failState) */\n        this.state = typeCast.failState;\n        return typeCast.node;\n      }\n\n      if (jsx?.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      if (typeCast?.thrown) throw typeCast.error;\n\n      throw jsx?.error || arrow.error || typeCast?.error;\n    }\n\n    reportReservedArrowTypeParam(node: any) {\n      if (\n        node.params.length === 1 &&\n        !node.extra?.trailingComma &&\n        this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")\n      ) {\n        this.raise(TSErrors.ReservedArrowTypeParam, { at: node });\n      }\n    }\n\n    // Handle type assertions\n    parseMaybeUnary(\n      refExpressionErrors?: ExpressionErrors | null,\n      sawUnary?: boolean,\n    ): N.Expression {\n      if (!this.hasPlugin(\"jsx\") && this.match(tt.lt)) {\n        return this.tsParseTypeAssertion();\n      } else {\n        return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n      }\n    }\n\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // This is different from how the TS parser does it.\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\n\n        const result = this.tryParse(abort => {\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\n            tt.colon,\n          );\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n          return returnType;\n        });\n\n        if (result.aborted) return;\n\n        if (!result.thrown) {\n          if (result.error) this.state = result.failState;\n          // @ts-expect-error refine typings\n          node.returnType = result.node;\n        }\n      }\n\n      return super.parseArrow(node);\n    }\n\n    // Allow type annotations inside of a parameter list.\n    parseAssignableListItemTypes(param: N.Pattern) {\n      if (this.eat(tt.question)) {\n        if (\n          param.type !== \"Identifier\" &&\n          !this.state.isAmbientContext &&\n          !this.state.inType\n        ) {\n          this.raise(TSErrors.PatternIsOptional, { at: param });\n        }\n\n        (param as any as N.Identifier).optional = true;\n      }\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      this.resetEndLocation(param);\n\n      return param;\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return this.isAssignable(node.expression, isBinding);\n        case \"TSParameterProperty\":\n          return true;\n        default:\n          return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      switch (node.type) {\n        case \"ParenthesizedExpression\":\n          this.toAssignableParenthesizedExpression(node, isLHS);\n          break;\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n          if (isLHS) {\n            this.expressionScope.recordArrowParemeterBindingError(\n              TSErrors.UnexpectedTypeCastInParameter,\n              { at: node },\n            );\n          } else {\n            this.raise(TSErrors.UnexpectedTypeCastInParameter, { at: node });\n          }\n          this.toAssignable(node.expression, isLHS);\n          break;\n        case \"AssignmentExpression\":\n          if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n            node.left = this.typeCastToParameter(node.left);\n          }\n        /* fall through */\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableParenthesizedExpression(node: N.Node, isLHS: boolean): void {\n      switch (node.expression.type) {\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n        case \"ParenthesizedExpression\":\n          this.toAssignable(node.expression, isLHS);\n          break;\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    checkToRestConversion(node: N.Node, allowPattern: boolean): void {\n      switch (node.type) {\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n        case \"TSNonNullExpression\":\n          this.checkToRestConversion(node.expression, false);\n          break;\n        default:\n          super.checkToRestConversion(node, allowPattern);\n      }\n    }\n\n    // @ts-expect-error plugin overrides interfaces\n    isValidLVal(\n      type:\n        | \"TSTypeCastExpression\"\n        | \"TSParameterProperty\"\n        | \"TSNonNullExpression\"\n        | \"TSAsExpression\"\n        | \"TSTypeAssertion\",\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingTypes,\n    ) {\n      return (\n        getOwn(\n          {\n            // Allow \"typecasts\" to appear on the left of assignment expressions,\n            // because it may be in an arrow function.\n            // e.g. `const f = (foo: number = 0) => foo;`\n            TSTypeCastExpression: true,\n            TSParameterProperty: \"parameter\",\n            TSNonNullExpression: \"expression\",\n            TSAsExpression: (binding !== BIND_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n            TSTypeAssertion: (binding !== BIND_NONE ||\n              !isUnparenthesizedInAssign) && [\"expression\", true],\n          },\n          type,\n        ) || super.isValidLVal(type, isUnparenthesizedInAssign, binding)\n      );\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n      // handles `@f<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n\n        if (this.match(tt.parenL)) {\n          const call = super.parseMaybeDecoratorArguments(expr);\n          call.typeParameters = typeArguments;\n          return call;\n        }\n\n        this.unexpected(null, tt.parenL);\n      }\n\n      return super.parseMaybeDecoratorArguments(expr);\n    }\n\n    checkCommaAfterRest(\n      close: typeof charCodes[keyof typeof charCodes],\n    ): boolean {\n      if (\n        this.state.isAmbientContext &&\n        this.match(tt.comma) &&\n        this.lookaheadCharCode() === close\n      ) {\n        this.next();\n        return false;\n      } else {\n        return super.checkCommaAfterRest(close);\n      }\n    }\n\n    // === === === === === === === === === === === === === === === ===\n    // Note: All below methods are duplicates of something in flow.js.\n    // Not sure what the best way to combine these is.\n    // === === === === === === === === === === === === === === === ===\n\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    isClassProperty(): boolean {\n      return (\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\n      );\n    }\n\n    parseMaybeDefault(\n      startPos?: number | null,\n      startLoc?: Position | null,\n      left?: Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(TSErrors.TypeAnnotationAfterAssign, {\n          at: node.typeAnnotation,\n        });\n      }\n\n      return node;\n    }\n\n    // ensure that inside types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      if (this.state.inType) {\n        if (code === charCodes.greaterThan) {\n          return this.finishOp(tt.gt, 1);\n        }\n        if (code === charCodes.lessThan) {\n          return this.finishOp(tt.lt, 1);\n        }\n      }\n      return super.getTokenFromCode(code);\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      const { type } = this.state;\n      if (type === tt.lt) {\n        this.state.pos -= 1;\n        this.readToken_lt();\n      } else if (type === tt.gt) {\n        this.state.pos -= 1;\n        this.readToken_gt();\n      }\n    }\n\n    reScan_lt() {\n      const { type } = this.state;\n      if (type === tt.bitShiftL) {\n        this.state.pos -= 2;\n        this.finishOp(tt.lt, 1);\n        return tt.lt;\n      }\n      return type;\n    }\n\n    toAssignableList(\n      exprList: Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TSTypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(\n            expr as N.TsTypeCastExpression,\n          );\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    shouldParseArrow(params: Array<N.Node>) {\n      if (this.match(tt.colon)) {\n        return params.every(expr => this.isAssignable(expr, true));\n      }\n      return super.shouldParseArrow(params);\n    }\n\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    canHaveLeadingDecorator() {\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      // handles `<Component<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsTryParseAndCatch(() =>\n          // @ts-expect-error: refine typings\n          this.tsParseTypeArgumentsInExpression(),\n        );\n        // @ts-expect-error: refine typings\n        if (typeArguments) node.typeParameters = typeArguments;\n      }\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    getGetterSetterExpectedParamCount(\n      method: N.ObjectMethod | N.ClassMethod,\n    ): number {\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      const firstParam = params[0];\n      const hasContextParam = firstParam && this.isThisParam(firstParam);\n\n      return hasContextParam ? baseCount + 1 : baseCount;\n    }\n\n    parseCatchClauseParam(): N.Pattern {\n      const param = super.parseCatchClauseParam();\n      const type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        param.typeAnnotation = type;\n        this.resetEndLocation(param);\n      }\n\n      return param;\n    }\n\n    tsInAmbientContext<T>(cb: () => T): T {\n      const oldIsAmbientContext = this.state.isAmbientContext;\n      this.state.isAmbientContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.isAmbientContext = oldIsAmbientContext;\n      }\n    }\n\n    parseClass<T extends N.Class>(\n      node: Undone<T>,\n      isStatement: boolean,\n      optionalId?: boolean,\n    ): T {\n      const oldInAbstractClass = this.state.inAbstractClass;\n      this.state.inAbstractClass = !!(node as any).abstract;\n      try {\n        return super.parseClass(node, isStatement, optionalId);\n      } finally {\n        this.state.inAbstractClass = oldInAbstractClass;\n      }\n    }\n\n    tsParseAbstractDeclaration(\n      node: any,\n    ): N.ClassDeclaration | N.TsInterfaceDeclaration | undefined | null {\n      if (this.match(tt._class)) {\n        node.abstract = true;\n        return this.parseClass<N.ClassDeclaration>(\n          node as N.ClassDeclaration,\n          /* isStatement */ true,\n          /* optionalId */ false,\n        );\n      } else if (this.isContextual(tt._interface)) {\n        // for invalid abstract interface\n\n        // To avoid\n        //   abstract interface\n        //   Foo {}\n        if (!this.hasFollowingLineBreak()) {\n          node.abstract = true;\n          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n            at: node,\n          });\n          return this.tsParseInterfaceDeclaration(\n            node as N.TsInterfaceDeclaration,\n          );\n        }\n      } else {\n        this.unexpected(null, tt._class);\n      }\n    }\n\n    parseMethod<\n      T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope?: boolean,\n    ) {\n      const method = super.parseMethod<T>(\n        node,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error todo(flow->ts) property not defined for all types in union\n      if (method.abstract) {\n        const hasBody = this.hasPlugin(\"estree\")\n          ? // @ts-expect-error estree typings\n            !!method.value.body\n          : !!method.body;\n        if (hasBody) {\n          const { key } = method;\n          this.raise(TSErrors.AbstractMethodHasImplementation, {\n            at: method,\n            methodName:\n              key.type === \"Identifier\" && !method.computed\n                ? key.name\n                : `[${this.input.slice(key.start, key.end)}]`,\n          });\n        }\n      }\n      return method;\n    }\n\n    tsParseTypeParameterName(): N.Identifier | string {\n      const typeName: N.Identifier = this.parseIdentifier();\n      return process.env.BABEL_8_BREAKING ? typeName : typeName.name;\n    }\n\n    shouldParseAsAmbientContext(): boolean {\n      return !!this.getPluginOption(\"typescript\", \"dts\");\n    }\n\n    parse() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.parse();\n    }\n\n    getExpression() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.getExpression();\n    }\n\n    parseExportSpecifier(\n      node: Undone<N.ExportSpecifier>,\n      isString: boolean,\n      isInTypeExport: boolean,\n      isMaybeTypeOnly: boolean,\n    ) {\n      if (!isString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          node,\n          /* isImport */ false,\n          isInTypeExport,\n        );\n        return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n      }\n      node.exportKind = \"value\";\n      return super.parseExportSpecifier(\n        node,\n        isString,\n        isInTypeExport,\n        isMaybeTypeOnly,\n      );\n    }\n\n    parseImportSpecifier(\n      specifier: Undone<N.ImportSpecifier>,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      isMaybeTypeOnly: boolean,\n    ): N.ImportSpecifier {\n      if (!importedIsString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          specifier,\n          /* isImport */ true,\n          isInTypeOnlyImport,\n        );\n        return this.finishNode<N.ImportSpecifier>(specifier, \"ImportSpecifier\");\n      }\n      specifier.importKind = \"value\";\n      return super.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        isInTypeOnlyImport,\n        isMaybeTypeOnly,\n        isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT,\n      );\n    }\n\n    parseTypeOnlyImportExportSpecifier(\n      node: any,\n      isImport: boolean,\n      isInTypeOnlyImportExport: boolean,\n    ): void {\n      const leftOfAsKey = isImport ? \"imported\" : \"local\";\n      const rightOfAsKey = isImport ? \"local\" : \"exported\";\n\n      let leftOfAs = node[leftOfAsKey];\n      let rightOfAs;\n\n      let hasTypeSpecifier = false;\n      let canParseAsKeyword = true;\n\n      const loc = leftOfAs.loc.start;\n\n      // https://github.com/microsoft/TypeScript/blob/fc4f9d83d5939047aa6bb2a43965c6e9bbfbc35b/src/compiler/parser.ts#L7411-L7456\n      // import { type } from \"mod\";          - hasTypeSpecifier: false, leftOfAs: type\n      // import { type as } from \"mod\";       - hasTypeSpecifier: true,  leftOfAs: as\n      // import { type as as } from \"mod\";    - hasTypeSpecifier: false, leftOfAs: type, rightOfAs: as\n      // import { type as as as } from \"mod\"; - hasTypeSpecifier: true,  leftOfAs: as,   rightOfAs: as\n      if (this.isContextual(tt._as)) {\n        // { type as ...? }\n        const firstAs = this.parseIdentifier();\n        if (this.isContextual(tt._as)) {\n          // { type as as ...? }\n          const secondAs = this.parseIdentifier();\n          if (tokenIsKeywordOrIdentifier(this.state.type)) {\n            // { type as as something }\n            hasTypeSpecifier = true;\n            leftOfAs = firstAs;\n            rightOfAs = isImport\n              ? this.parseIdentifier()\n              : this.parseModuleExportName();\n            canParseAsKeyword = false;\n          } else {\n            // { type as as }\n            rightOfAs = secondAs;\n            canParseAsKeyword = false;\n          }\n        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          // { type as something }\n          canParseAsKeyword = false;\n          rightOfAs = isImport\n            ? this.parseIdentifier()\n            : this.parseModuleExportName();\n        } else {\n          // { type as }\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        // { type something ...? }\n        hasTypeSpecifier = true;\n        if (isImport) {\n          leftOfAs = this.parseIdentifier(true);\n          if (!this.isContextual(tt._as)) {\n            this.checkReservedWord(\n              leftOfAs.name,\n              leftOfAs.loc.start,\n              true,\n              true,\n            );\n          }\n        } else {\n          leftOfAs = this.parseModuleExportName();\n        }\n      }\n      if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n        this.raise(\n          isImport\n            ? TSErrors.TypeModifierIsUsedInTypeImports\n            : TSErrors.TypeModifierIsUsedInTypeExports,\n          { at: loc },\n        );\n      }\n\n      node[leftOfAsKey] = leftOfAs;\n      node[rightOfAsKey] = rightOfAs;\n\n      const kindKey = isImport ? \"importKind\" : \"exportKind\";\n      node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n      if (canParseAsKeyword && this.eatContextual(tt._as)) {\n        node[rightOfAsKey] = isImport\n          ? this.parseIdentifier()\n          : this.parseModuleExportName();\n      }\n      if (!node[rightOfAsKey]) {\n        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n      }\n      if (isImport) {\n        this.checkIdentifier(\n          node[rightOfAsKey],\n          hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT,\n        );\n      }\n    }\n  };\n\nfunction isPossiblyLiteralEnum(expression: N.Expression): boolean {\n  if (expression.type !== \"MemberExpression\") return false;\n\n  const { computed, property } = expression;\n\n  if (\n    computed &&\n    property.type !== \"StringLiteral\" &&\n    (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)\n  ) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\nfunction isUncomputedMemberExpressionChain(expression: N.Expression): boolean {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\") return false;\n  if (expression.computed) return false;\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n"],"mappings":"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"}