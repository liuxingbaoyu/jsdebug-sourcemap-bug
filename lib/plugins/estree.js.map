{"version":3,"names":["defineProperty","Object","toUnenumerable","object","key","enumerable","value","toESTreeLocation","node","loc","start","end","superClass","ESTreeParserMixin","parse","file","options","tokens","map","parseRegExpLiteral","pattern","flags","regex","RegExp","e","estreeParseLiteral","parseBigIntLiteral","bigInt","BigInt","bigint","String","parseDecimalLiteral","decimal","parseLiteral","parseStringLiteral","parseNumericLiteral","parseNullLiteral","parseBooleanLiteral","directiveToStmt","directive","directiveLiteral","stmt","startNodeAt","expression","extra","expressionValue","raw","finishNodeAt","slice","initFunction","isAsync","checkDeclaration","isObjectProperty","getObjectOrClassMethodParams","method","params","isValidDirective","type","parenthesized","parseBlockBody","allowDirectives","topLevel","afterBlockParse","directiveStatements","directives","d","body","concat","pushClassMethod","classBody","isGenerator","isConstructor","allowsDirectSuper","parseMethod","typeParameters","push","parsePrivateName","process","env","BABEL_8_BREAKING","getPluginOption","convertPrivateNameToPrivateIdentifier","name","getPrivateNameSV","id","isPrivateName","parseFunctionBody","allowExpression","isMethod","allowDirectSuper","inClassScope","funcNode","startNode","kind","computed","finishNode","parseClassProperty","args","propertyNode","parseClassPrivateProperty","parseObjectMethod","prop","isPattern","isAccessor","shorthand","parseObjectProperty","startPos","startLoc","refExpressionErrors","isValidLVal","isUnparenthesizedInAssign","binding","isAssignable","isBinding","toAssignable","isLHS","classScope","usePrivateName","toAssignableObjectExpressionProp","isLast","raise","Errors","PatternHasAccessor","at","PatternHasMethod","finishCallExpression","unfinished","optional","callee","source","arguments","hasPlugin","attributes","toReferencedArguments","parseExport","exported","specifiers","length","parseSubscript","base","noCalls","state","optionalChainMember","substring","stop","chain","startNodeAtNode","hasPropertyAsPrivateName","isOptionalChain","isObjectMethod","endLoc","resetStartLocation","resetEndLocation","lastTokEndLoc"],"sources":["../../src/plugins/estree.ts"],"sourcesContent":["import { type TokenType } from \"../tokenizer/types\";\nimport type Parser from \"../parser\";\nimport type { ExpressionErrors } from \"../parser/util\";\nimport * as N from \"../types\";\nimport type { Node as NodeType, NodeBase, File } from \"../types\";\nimport type { Position } from \"../util/location\";\nimport { Errors } from \"../parse-error\";\nimport type { Undone } from \"../parser/node\";\nimport type { BindingTypes } from \"../util/scopeflags\";\n\nconst { defineProperty } = Object;\nconst toUnenumerable = (object: any, key: string) =>\n  defineProperty(object, key, { enumerable: false, value: object[key] });\n\nfunction toESTreeLocation(node: any) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n\n  return node;\n}\n\nexport default (superClass: typeof Parser) =>\n  class ESTreeParserMixin extends superClass implements Parser {\n    parse(): File {\n      const file = toESTreeLocation(super.parse());\n\n      if (this.options.tokens) {\n        file.tokens = file.tokens.map(toESTreeLocation);\n      }\n\n      return file;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseRegExpLiteral({ pattern, flags }): N.EstreeRegExpLiteral {\n      let regex: RegExp | null = null;\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (e) {\n        // In environments that don't support these flags value will\n        // be null as the regex can't be represented natively.\n      }\n      const node = this.estreeParseLiteral<N.EstreeRegExpLiteral>(regex);\n      node.regex = { pattern, flags };\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseBigIntLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n      let bigInt: BigInt | null;\n      try {\n        bigInt = BigInt(value);\n      } catch {\n        bigInt = null;\n      }\n      const node = this.estreeParseLiteral<N.EstreeBigIntLiteral>(bigInt);\n      node.bigint = String(node.value || value);\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseDecimalLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/experimental/decimal.md\n      // todo: use BigDecimal when node supports it.\n      const decimal: null = null;\n      const node = this.estreeParseLiteral(decimal);\n      node.decimal = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseLiteral<T extends N.Node>(value: any) {\n      // @ts-expect-error ESTree plugin changes node types\n      return this.parseLiteral<T>(value, \"Literal\");\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseStringLiteral(value: any): N.Node {\n      return this.estreeParseLiteral(value);\n    }\n\n    parseNumericLiteral(value: any): any {\n      return this.estreeParseLiteral(value);\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseNullLiteral(): N.Node {\n      return this.estreeParseLiteral(null);\n    }\n\n    parseBooleanLiteral(value: boolean): N.BooleanLiteral {\n      return this.estreeParseLiteral(value);\n    }\n\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\n      const directiveLiteral = directive.value;\n\n      const stmt = this.startNodeAt<N.ExpressionStatement>(\n        directive.start,\n        directive.loc.start,\n      );\n      const expression = this.startNodeAt<N.EstreeLiteral>(\n        directiveLiteral.start,\n        directiveLiteral.loc.start,\n      );\n\n      expression.value = directiveLiteral.extra.expressionValue;\n      // @ts-expect-error TS2339: Property 'raw' does not exist on type 'Undone '.\n      expression.raw = directiveLiteral.extra.raw;\n\n      stmt.expression = this.finishNodeAt(\n        expression,\n        \"Literal\",\n        directiveLiteral.loc.end,\n      );\n      // @ts-expect-error N.Directive.value is not defined\n      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n\n      return this.finishNodeAt(\n        stmt,\n        \"ExpressionStatement\",\n        directive.loc.end,\n      ) as N.ExpressionStatement;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    initFunction(\n      node: N.BodilessFunctionOrMethodBase,\n      isAsync?: boolean | null,\n    ): void {\n      super.initFunction(node, isAsync);\n      node.expression = false;\n    }\n\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n      if (node != null && this.isObjectProperty(node)) {\n        // @ts-expect-error plugin typings\n        this.checkDeclaration((node as unknown as N.EstreeProperty).value);\n      } else {\n        super.checkDeclaration(node);\n      }\n    }\n\n    getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n      return (method as any as N.EstreeProperty | N.EstreeMethodDefinition)\n        .value.params;\n    }\n\n    isValidDirective(stmt: N.Statement): boolean {\n      return (\n        stmt.type === \"ExpressionStatement\" &&\n        stmt.expression.type === \"Literal\" &&\n        typeof stmt.expression.value === \"string\" &&\n        !stmt.expression.extra?.parenthesized\n      );\n    }\n\n    parseBlockBody(\n      node: N.BlockStatementLike,\n      allowDirectives: boolean | undefined | null,\n      topLevel: boolean,\n      end: TokenType,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): void {\n      super.parseBlockBody(\n        node,\n        allowDirectives,\n        topLevel,\n        end,\n        afterBlockParse,\n      );\n\n      const directiveStatements = node.directives.map(d =>\n        this.directiveToStmt(d),\n      );\n      // @ts-expect-error estree plugin typings\n      node.body = directiveStatements.concat(node.body);\n      delete node.directives;\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      );\n      if (method.typeParameters) {\n        // @ts-expect-error\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(method);\n    }\n\n    parsePrivateName(): any {\n      const node = super.parsePrivateName();\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return node;\n        }\n      }\n      return this.convertPrivateNameToPrivateIdentifier(node);\n    }\n\n    convertPrivateNameToPrivateIdentifier(\n      node: N.PrivateName,\n    ): N.EstreePrivateIdentifier {\n      const name = super.getPrivateNameSV(node);\n      node = node as any;\n      delete node.id;\n      // @ts-expect-error mutate AST types\n      node.name = name;\n      // @ts-expect-error mutate AST types\n      node.type = \"PrivateIdentifier\";\n      return node as unknown as N.EstreePrivateIdentifier;\n    }\n\n    isPrivateName(node: N.Node): boolean {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.isPrivateName(node);\n        }\n      }\n      return node.type === \"PrivateIdentifier\";\n    }\n\n    getPrivateNameSV(node: N.Node): string {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.getPrivateNameSV(node);\n        }\n      }\n      return node.name;\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseLiteral<T extends N.Literal>(value: any, type: T[\"type\"]): T {\n      const node = super.parseLiteral<T>(value, type);\n      // @ts-expect-error mutating AST types\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    }\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpression?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      super.parseFunctionBody(node, allowExpression, isMethod);\n      node.expression = node.body.type !== \"BlockStatement\";\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseMethod<\n      T extends N.ClassPrivateMethod | N.ObjectMethod | N.ClassMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope: boolean = false,\n    ): N.EstreeMethodDefinition {\n      let funcNode = this.startNode<N.MethodLike>();\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n      funcNode = super.parseMethod(\n        // @ts-expect-error todo(flow->ts)\n        funcNode,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error mutate AST types\n      funcNode.type = \"FunctionExpression\";\n      delete funcNode.kind;\n      // @ts-expect-error\n      node.value = funcNode;\n      if (type === \"ClassPrivateMethod\") {\n        node.computed = false;\n      }\n      return this.finishNode(\n        // @ts-expect-error cast methods to estree types\n        node as Undone<N.EstreeMethodDefinition>,\n        \"MethodDefinition\",\n      );\n    }\n\n    parseClassProperty(...args: [N.ClassProperty]): any {\n      const propertyNode = super.parseClassProperty(...args) as any;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as N.EstreePropertyDefinition;\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      return propertyNode as N.EstreePropertyDefinition;\n    }\n\n    parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {\n      const propertyNode = super.parseClassPrivateProperty(...args) as any;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as N.EstreePropertyDefinition;\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      propertyNode.computed = false;\n      return propertyNode as N.EstreePropertyDefinition;\n    }\n\n    parseObjectMethod(\n      prop: N.ObjectMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n    ): N.ObjectMethod | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) as any;\n\n      if (node) {\n        node.type = \"Property\";\n        if ((node as any as N.ClassMethod).kind === \"method\") {\n          node.kind = \"init\";\n        }\n        node.shorthand = false;\n      }\n\n      return node as any;\n    }\n\n    parseObjectProperty(\n      prop: N.ObjectProperty,\n      startPos: number | undefined | null,\n      startLoc: Position | undefined | null,\n      isPattern: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectProperty | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectProperty(\n        prop,\n        startPos,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      ) as any;\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node as any;\n    }\n\n    isValidLVal(\n      type: string,\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingTypes,\n    ) {\n      return type === \"Property\"\n        ? \"value\"\n        : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node != null && this.isObjectProperty(node)) {\n        return this.isAssignable(node.value, isBinding);\n      }\n      return super.isAssignable(node, isBinding);\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (node != null && this.isObjectProperty(node)) {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableObjectExpressionProp(\n      prop: N.Node,\n      isLast: boolean,\n      isLHS: boolean,\n    ) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        this.raise(Errors.PatternHasAccessor, { at: prop.key });\n      } else if (prop.method) {\n        this.raise(Errors.PatternHasMethod, { at: prop.key });\n      } else {\n        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n      }\n    }\n\n    finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n      unfinished: Undone<T>,\n      optional: boolean,\n    ): T {\n      const node = super.finishCallExpression(unfinished, optional);\n\n      if (node.callee.type === \"Import\") {\n        (node as N.Node as N.EstreeImportExpression).type = \"ImportExpression\";\n        (node as N.Node as N.EstreeImportExpression).source = node.arguments[0];\n        if (this.hasPlugin(\"importAssertions\")) {\n          (node as N.Node as N.EstreeImportExpression).attributes =\n            node.arguments[1] ?? null;\n        }\n        // arguments isn't optional in the type definition\n        delete node.arguments;\n        // callee isn't optional in the type definition\n        delete node.callee;\n      }\n\n      return node;\n    }\n\n    toReferencedArguments(\n      node:\n        | N.CallExpression\n        | N.OptionalCallExpression\n        | N.EstreeImportExpression,\n      /* isParenthesizedExpr?: boolean, */\n    ) {\n      // ImportExpressions do not have an arguments array.\n      if (node.type === \"ImportExpression\") {\n        return;\n      }\n\n      super.toReferencedArguments(node);\n    }\n\n    parseExport(unfinished: Undone<N.AnyExport>) {\n      const node = super.parseExport(unfinished);\n\n      switch (node.type) {\n        case \"ExportAllDeclaration\":\n          // @ts-expect-error mutating AST types\n          node.exported = null;\n          break;\n\n        case \"ExportNamedDeclaration\":\n          if (\n            node.specifiers.length === 1 &&\n            // @ts-expect-error mutating AST types\n            node.specifiers[0].type === \"ExportNamespaceSpecifier\"\n          ) {\n            // @ts-expect-error mutating AST types\n            node.type = \"ExportAllDeclaration\";\n            // @ts-expect-error mutating AST types\n            node.exported = node.specifiers[0].exported;\n            delete node.specifiers;\n          }\n\n          break;\n      }\n\n      return node as N.AnyExport;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ) {\n      const node = super.parseSubscript(\n        base,\n        startPos,\n        startLoc,\n        noCalls,\n        state,\n      );\n\n      if (state.optionalChainMember) {\n        // https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n        if (\n          node.type === \"OptionalMemberExpression\" ||\n          node.type === \"OptionalCallExpression\"\n        ) {\n          node.type = node.type.substring(8); // strip Optional prefix\n        }\n        if (state.stop) {\n          const chain = this.startNodeAtNode(node);\n          chain.expression = node;\n          return this.finishNode(chain, \"ChainExpression\");\n        }\n      } else if (\n        node.type === \"MemberExpression\" ||\n        node.type === \"CallExpression\"\n      ) {\n        node.optional = false;\n      }\n\n      return node;\n    }\n\n    hasPropertyAsPrivateName(node: N.Node): boolean {\n      if (node.type === \"ChainExpression\") {\n        node = node.expression;\n      }\n      return super.hasPropertyAsPrivateName(node);\n    }\n\n    isOptionalChain(node: N.Node): boolean {\n      return node.type === \"ChainExpression\";\n    }\n\n    // @ts-expect-error override interfaces\n    isObjectProperty(node: N.Node): boolean {\n      return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n    }\n\n    isObjectMethod(node: N.Node): boolean {\n      return node.method || node.kind === \"get\" || node.kind === \"set\";\n    }\n\n    finishNodeAt<T extends NodeType>(\n      node: Undone<T>,\n      type: T[\"type\"],\n      endLoc: Position,\n    ): T {\n      return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n    }\n\n    resetStartLocation(node: N.Node, start: number, startLoc: Position) {\n      super.resetStartLocation(node, start, startLoc);\n      toESTreeLocation(node);\n    }\n\n    resetEndLocation(\n      node: NodeBase,\n      endLoc: Position = this.state.lastTokEndLoc,\n    ): void {\n      super.resetEndLocation(node, endLoc);\n      toESTreeLocation(node);\n    }\n  };\n"],"mappings":"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"}