{"version":3,"names":["buildPosition","pos","lineStart","curLine","Position","VALID_REGEX_FLAGS","Set","Token","constructor","state","type","value","start","end","loc","SourceLocation","startLoc","endLoc","Tokenizer","CommentsParser","isLookahead","tokens","options","input","State","init","length","pushToken","token","tokensLength","push","next","checkKeywordEscapes","lastTokStart","lastTokEndLoc","lastTokStartLoc","nextToken","eat","match","createLookaheadState","context","curContext","inType","curPosition","lookahead","old","curr","nextTokenStart","nextTokenStartSince","skipWhiteSpace","lastIndex","test","lookaheadCharCode","charCodeAt","codePointAtPos","cp","trail","setStrict","strict","strictErrors","forEach","toParseError","at","raise","clear","skipSpace","finishToken","getTokenFromCode","skipBlockComment","indexOf","Errors","UnterminatedComment","lineBreakG","comment","slice","skipLineComment","startSkip","ch","isNewLine","spaceStart","comments","loop","undefined","addComment","attachComment","isWhitespace","inModule","commentWhitespace","leadingNode","trailingNode","containingNode","commentStack","val","prevType","updateContext","replaceToken","readToken_numberSign","readToken_interpreter","nextPos","UnexpectedDigitAfterHash","hasPlugin","expectPlugin","getPluginOption","RecordExpressionHashIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","isIdentifierStart","readWord1","finishOp","readToken_dot","readNumber","readToken_slash","readToken_mult_modulo","code","width","readToken_pipe_amp","RecordExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectEndSyntaxType","readToken_caret","proposal","topicToken","lookaheadCh","codePointAt","unexpected","readToken_atSign","readToken_plus_min","readToken_lt","readToken_gt","size","readToken_eq_excl","readToken_question","next2","TupleExpressionBarIncorrectStartSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","readTemplateToken","readRadixNumber","readString","readWord","InvalidOrUnexpectedToken","String","fromCodePoint","str","readRegexp","escaped","inClass","UnterminatedRegExp","createPositionWithColumnOffset","content","mods","char","fromCharCode","has","includes","IncompatibleRegExpUVFlags","DuplicateRegExpFlags","isIdentifierChar","MalformedRegExpFlags","pattern","flags","readInt","radix","len","forceLen","allowNumSeparator","n","errorHandlers_readInt","isBigInt","InvalidDigit","InvalidDecimal","NumberIdentifier","index","replace","startsWithDot","isFloat","isDecimal","hasExponent","isOctal","InvalidNumber","hasLeadingZero","integer","recordStrictModeErrors","StrictOctalLiteral","underscorePos","ZeroDigitNumericSeparator","InvalidOrMissingExponent","InvalidBigIntLiteral","parseInt","parseFloat","readCodePoint","throwOnInvalid","errorHandlers_readCodePoint","quote","readStringContents","errorHandlers_readStringContents_string","readTemplateContinuation","opening","containsInvalid","errorHandlers_readStringContents_template","set","firstCode","containsEsc","word","chunkStart","escStart","identifierCheck","MissingUnicodeEscape","esc","EscapedCharNotAnIdentifier","keywordTypes","get","tokenLabelName","tokenIsKeyword","InvalidEscapedReservedWord","reservedWord","raiseProperties","details","error","errorRecovery","errors","raiseOverwrite","i","UnexpectedToken","expected","pluginName","MissingPlugin","missingPlugin","expectOnePlugin","pluginNames","some","name","MissingOneOfPlugins","errorBuilder","invalidDigit","numericSeparatorInEscapeSequence","NumericSeparatorInEscapeSequence","unexpectedNumericSeparator","UnexpectedNumericSeparator","invalidEscapeSequence","InvalidEscapeSequence","invalidCodePoint","InvalidCodePoint","strictNumericEscape","StrictNumericEscape","unterminated","UnterminatedString","UnterminatedTemplate"],"sources":["../../src/tokenizer/index.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport type { Options } from \"../options\";\nimport {\n  Position,\n  SourceLocation,\n  createPositionWithColumnOffset,\n} from \"../util/location\";\nimport CommentsParser, { type CommentWhitespace } from \"../parser/comments\";\nimport * as N from \"../types\";\nimport * as charCodes from \"charcodes\";\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier\";\nimport {\n  tokenIsKeyword,\n  tokenLabelName,\n  tt,\n  keywords as keywordTypes,\n  type TokenType,\n} from \"./types\";\nimport { type TokContext } from \"./context\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n  type RaiseProperties,\n} from \"../parse-error\";\nimport {\n  lineBreakG,\n  isNewLine,\n  isWhitespace,\n  skipWhiteSpace,\n} from \"../util/whitespace\";\nimport State from \"./state\";\nimport type { LookaheadState, DeferredStrictError } from \"./state\";\n\nimport {\n  readInt,\n  readCodePoint,\n  readStringContents,\n  type IntErrorHandlers,\n  type CodePointErrorHandlers,\n  type StringContentsErrorHandlers,\n} from \"@babel/helper-string-parser\";\n\nimport type { Plugin } from \"../typings\";\n\nfunction buildPosition(pos: number, lineStart: number, curLine: number) {\n  return new Position(curLine, pos - lineStart, pos);\n}\n\nconst VALID_REGEX_FLAGS = new Set([\n  charCodes.lowercaseG,\n  charCodes.lowercaseM,\n  charCodes.lowercaseS,\n  charCodes.lowercaseI,\n  charCodes.lowercaseY,\n  charCodes.lowercaseU,\n  charCodes.lowercaseD,\n  // This is only valid when using the regexpUnicodeSets plugin\n  charCodes.lowercaseV,\n]);\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nexport class Token {\n  constructor(state: State) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n  declare type: TokenType;\n  declare value: any;\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n}\n\n// ## Tokenizer\n\nexport default abstract class Tokenizer extends CommentsParser {\n  isLookahead: boolean;\n\n  // Token store.\n  tokens: Array<Token | N.Comment> = [];\n\n  constructor(options: Options, input: string) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token: Token | N.Comment) {\n    // Pop out invalid tokens trapped by try-catch parsing.\n    // Those parsing branches are mainly created by typescript and flow plugins.\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  // Move to the next token\n\n  next(): void {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  // TODO\n\n  eat(type: TokenType): boolean {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Whether current token matches given type\n   *\n   * @param {TokenType} type\n   * @returns {boolean}\n   * @memberof Tokenizer\n   */\n  match(type: TokenType): boolean {\n    return this.state.type === type;\n  }\n\n  /**\n   * Create a LookaheadState from current parser state\n   *\n   * @param {State} state\n   * @returns {LookaheadState}\n   * @memberof Tokenizer\n   */\n  createLookaheadState(state: State): LookaheadState {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition,\n    };\n  }\n\n  /**\n   * lookahead peeks the next token, skipping changes to token context and\n   * comment stack. For performance it returns a limited LookaheadState\n   * instead of full parser state.\n   *\n   * The { column, line } Loc info is not included in lookahead since such usage\n   * is rare. Although it may return other location properties e.g. `curLine` and\n   * `lineStart`, these properties are not listed in the LookaheadState interface\n   * and thus the returned value is _NOT_ reliable.\n   *\n   * The tokenizer should make best efforts to avoid using any parser state\n   * other than those defined in LookaheadState\n   *\n   * @returns {LookaheadState}\n   * @memberof Tokenizer\n   */\n  lookahead(): LookaheadState {\n    const old = this.state;\n    // For performance we use a simplified tokenizer state structure\n    // @ts-expect-error\n    this.state = this.createLookaheadState(old);\n\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart(): number {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos: number): number {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  codePointAtPos(pos: number): number {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `input` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  setStrict(strict: boolean): void {\n    this.state.strict = strict;\n    if (strict) {\n      // Throw an error for any string decimal escape found before/immediately\n      // after a \"use strict\" directive. Strict mode will be set at parse\n      // time for any literals that occur after the next node of the strict\n      // directive.\n      this.state.strictErrors.forEach(([toParseError, at]) =>\n        this.raise(toParseError, { at }),\n      );\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext(): TokContext {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  nextToken(): void {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(tt.eof);\n      return;\n    }\n\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  skipBlockComment(): N.CommentBlock | undefined {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", start + 2);\n    if (end === -1) {\n      // We have to call this again here because startLoc may not be set...\n      // This seems to be for performance reasons:\n      // https://github.com/babel/babel/commit/acf2a10899f696a8aaf34df78bf9725b5ea7f2da\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const comment: N.CommentBlock = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + 2,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip: number): N.CommentLine | undefined {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n\n    const comment: N.CommentLine = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  skipSpace(): void {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case charCodes.space:\n        case charCodes.nonBreakingSpace:\n        case charCodes.tab:\n          ++this.state.pos;\n          break;\n        case charCodes.carriageReturn:\n          if (\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\n          ) {\n            ++this.state.pos;\n          }\n        // fall through\n        case charCodes.lineFeed:\n        case charCodes.lineSeparator:\n        case charCodes.paragraphSeparator:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case charCodes.slash:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case charCodes.asterisk: {\n              const comment = this.skipBlockComment();\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            case charCodes.slash: {\n              const comment = this.skipLineComment(2);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === charCodes.dash && !this.inModule) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.dash &&\n              this.input.charCodeAt(pos + 2) === charCodes.greaterThan &&\n              (spaceStart === 0 || this.state.lineStart > spaceStart)\n            ) {\n              // A `-->` line comment\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === charCodes.lessThan && !this.inModule) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.exclamationMark &&\n              this.input.charCodeAt(pos + 2) === charCodes.dash &&\n              this.input.charCodeAt(pos + 3) === charCodes.dash\n            ) {\n              // `<!--`, an XML-style comment that should be interpreted as a line comment\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace: CommentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null,\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `canStartJSXElement`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  finishToken(type: TokenType, val?: any): void {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type: TokenType): void {\n    this.state.type = type;\n    // the prevType of updateContext is required\n    // only when the new type is tt.slash/tt.jsxTagEnd\n    // @ts-expect-error\n    this.updateContext();\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n\n  // number sign is \"#\"\n  readToken_numberSign(): void {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    if (\n      next === charCodes.leftCurlyBrace ||\n      (next === charCodes.leftSquareBracket && this.hasPlugin(\"recordAndTuple\"))\n    ) {\n      // When we see `#{`, it is likely to be a hash record.\n      // However we don't yell at `#[` since users may intend to use \"computed private fields\",\n      // which is not allowed in the spec. Throwing expecting recordAndTuple is\n      // misleading\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(\n          next === charCodes.leftCurlyBrace\n            ? Errors.RecordExpressionHashIncorrectStartSyntaxType\n            : Errors.TupleExpressionHashIncorrectStartSyntaxType,\n          { at: this.state.curPosition() },\n        );\n      }\n\n      this.state.pos += 2;\n      if (next === charCodes.leftCurlyBrace) {\n        // #{\n        this.finishToken(tt.braceHashL);\n      } else {\n        // #[\n        this.finishToken(tt.bracketHashL);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1(next));\n    } else if (next === charCodes.backslash) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1());\n    } else {\n      this.finishOp(tt.hash, 1);\n    }\n  }\n\n  readToken_dot(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (\n      next === charCodes.dot &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dot\n    ) {\n      this.state.pos += 3;\n      this.finishToken(tt.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.dot);\n    }\n  }\n\n  readToken_slash(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.slashAssign, 2);\n    } else {\n      this.finishOp(tt.slash, 1);\n    }\n  }\n\n  readToken_interpreter(): boolean {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== charCodes.exclamationMark) return false;\n\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n\n    this.finishToken(tt.interpreterDirective, value);\n\n    return true;\n  }\n\n  readToken_mult_modulo(code: number): void {\n    // '%' or '*'\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    // Exponentiation operator '**'\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = tt.exponent;\n    }\n\n    // '%=' or '*='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      width++;\n      // `tt.moduloAssign` is only needed to support % as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      type = code === charCodes.percentSign ? tt.moduloAssign : tt.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code: number): void {\n    // '||' '&&' '||=' '&&='\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n      } else {\n        this.finishOp(\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\n          2,\n        );\n      }\n      return;\n    }\n\n    if (code === charCodes.verticalBar) {\n      // '|>'\n      if (next === charCodes.greaterThan) {\n        this.finishOp(tt.pipeline, 2);\n        return;\n      }\n      // '|}'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.braceBarR);\n        return;\n      }\n\n      // '|]'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightSquareBracket\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition(),\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.bracketBarR);\n        return;\n      }\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n      return;\n    }\n\n    this.finishOp(\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\n      1,\n    );\n  }\n\n  readToken_caret(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '^='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      // `tt.xorAssign` is only needed to support ^ as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      this.finishOp(tt.xorAssign, 2);\n    }\n    // '^^'\n    else if (\n      next === charCodes.caret &&\n      // If the ^^ token is not enabled, we don't throw but parse two single ^s\n      // because it could be a ^ hack token followed by a ^ binary operator.\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"^^\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleCaret, 2);\n\n      // `^^^` is forbidden and must be separated by a space.\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === charCodes.caret) {\n        throw this.unexpected();\n      }\n    }\n    // '^'\n    else {\n      this.finishOp(tt.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_atSign(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '@@'\n    if (\n      next === charCodes.atSign &&\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"@@\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleAt, 2);\n    }\n    // '@'\n    else {\n      this.finishOp(tt.at, 1);\n    }\n  }\n\n  readToken_plus_min(code: number): void {\n    // '+-'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(tt.incDec, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.plusMin, 1);\n    }\n  }\n\n  readToken_lt(): void {\n    // '<'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.lessThan) {\n      if (this.input.charCodeAt(pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n        return;\n      }\n      this.finishOp(tt.bitShiftL, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.lt, 1);\n  }\n\n  readToken_gt(): void {\n    // '>'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.greaterThan) {\n      const size =\n        this.input.charCodeAt(pos + 2) === charCodes.greaterThan ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, size + 1);\n        return;\n      }\n      this.finishOp(tt.bitShiftR, size);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <= | >=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.gt, 1);\n  }\n\n  readToken_eq_excl(code: number): void {\n    // '=!'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(\n        tt.equality,\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\n          ? 3\n          : 2,\n      );\n      return;\n    }\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(tt.arrow);\n      return;\n    }\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n  }\n\n  readToken_question(): void {\n    // '?'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === charCodes.questionMark) {\n      if (next2 === charCodes.equalsTo) {\n        // '??='\n        this.finishOp(tt.assign, 3);\n      } else {\n        // '??'\n        this.finishOp(tt.nullishCoalescing, 2);\n      }\n    } else if (\n      next === charCodes.dot &&\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\n    ) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(tt.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.question);\n    }\n  }\n\n  getTokenFromCode(code: number): void {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case charCodes.dot:\n        this.readToken_dot();\n        return;\n\n      // Punctuation tokens.\n      case charCodes.leftParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenL);\n        return;\n      case charCodes.rightParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenR);\n        return;\n      case charCodes.semicolon:\n        ++this.state.pos;\n        this.finishToken(tt.semi);\n        return;\n      case charCodes.comma:\n        ++this.state.pos;\n        this.finishToken(tt.comma);\n        return;\n      case charCodes.leftSquareBracket:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.TupleExpressionBarIncorrectStartSyntaxType,\n              { at: this.state.curPosition() },\n            );\n          }\n\n          // [|\n          this.state.pos += 2;\n          this.finishToken(tt.bracketBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.bracketL);\n        }\n        return;\n      case charCodes.rightSquareBracket:\n        ++this.state.pos;\n        this.finishToken(tt.bracketR);\n        return;\n      case charCodes.leftCurlyBrace:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.RecordExpressionBarIncorrectStartSyntaxType,\n              { at: this.state.curPosition() },\n            );\n          }\n\n          // {|\n          this.state.pos += 2;\n          this.finishToken(tt.braceBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.braceL);\n        }\n        return;\n      case charCodes.rightCurlyBrace:\n        ++this.state.pos;\n        this.finishToken(tt.braceR);\n        return;\n\n      case charCodes.colon:\n        if (\n          this.hasPlugin(\"functionBind\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.colon);\n        }\n        return;\n\n      case charCodes.questionMark:\n        this.readToken_question();\n        return;\n\n      case charCodes.graveAccent:\n        this.readTemplateToken();\n        return;\n\n      case charCodes.digit0: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        // '0x', '0X' - hex number\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\n          this.readRadixNumber(16);\n          return;\n        }\n        // '0o', '0O' - octal number\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\n          this.readRadixNumber(8);\n          return;\n        }\n        // '0b', '0B' - binary number\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float. (fall through)\n      case charCodes.digit1:\n      case charCodes.digit2:\n      case charCodes.digit3:\n      case charCodes.digit4:\n      case charCodes.digit5:\n      case charCodes.digit6:\n      case charCodes.digit7:\n      case charCodes.digit8:\n      case charCodes.digit9:\n        this.readNumber(false);\n        return;\n\n      // Quotes produce strings.\n      case charCodes.quotationMark:\n      case charCodes.apostrophe:\n        this.readString(code);\n        return;\n\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case charCodes.slash:\n        this.readToken_slash();\n        return;\n\n      case charCodes.percentSign:\n      case charCodes.asterisk:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case charCodes.verticalBar:\n      case charCodes.ampersand:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case charCodes.caret:\n        this.readToken_caret();\n        return;\n\n      case charCodes.plusSign:\n      case charCodes.dash:\n        this.readToken_plus_min(code);\n        return;\n\n      case charCodes.lessThan:\n        this.readToken_lt();\n        return;\n\n      case charCodes.greaterThan:\n        this.readToken_gt();\n        return;\n\n      case charCodes.equalsTo:\n      case charCodes.exclamationMark:\n        this.readToken_eq_excl(code);\n        return;\n\n      case charCodes.tilde:\n        this.finishOp(tt.tilde, 1);\n        return;\n\n      case charCodes.atSign:\n        this.readToken_atSign();\n        return;\n\n      case charCodes.numberSign:\n        this.readToken_numberSign();\n        return;\n\n      case charCodes.backslash:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code),\n    });\n  }\n\n  finishOp(type: TokenType, size: number): void {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp(): void {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let { pos } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        // FIXME: explain\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1),\n        });\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1),\n        });\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === charCodes.leftSquareBracket) {\n          inClass = true;\n        } else if (ch === charCodes.rightSquareBracket && inClass) {\n          inClass = false;\n        } else if (ch === charCodes.slash && !inClass) {\n          break;\n        }\n        escaped = ch === charCodes.backslash;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n\n    let mods = \"\";\n\n    const nextPos = () =>\n      // (pos + 1) + 1 - start\n      createPositionWithColumnOffset(startLoc, pos + 2 - start);\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      // It doesn't matter if cp > 0xffff, the loop will either throw or break because we check on cp\n      const char = String.fromCharCode(cp);\n\n      // @ts-expect-error VALID_REGEX_FLAGS.has should accept expanded type: number\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === charCodes.lowercaseV) {\n          this.expectPlugin(\"regexpUnicodeSets\", nextPos());\n\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });\n          }\n        } else if (cp === charCodes.lowercaseU) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, { at: nextPos() });\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, { at: nextPos() });\n        }\n      } else if (isIdentifierChar(cp) || cp === charCodes.backslash) {\n        this.raise(Errors.MalformedRegExpFlags, { at: nextPos() });\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n\n    this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n    });\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n  // When `forceLen` is `true`, it means that we already know that in case\n  // of a malformed number we have to skip `len` characters anyway, instead\n  // of bailing out early. For example, in \"\\u{123Z}\" we want to read up to }\n  // anyway, while in \"\\u00Z\" we will stop at Z instead of consuming four\n  // characters (and thus the closing quote).\n\n  readInt(\n    radix: number,\n    len?: number,\n    forceLen: boolean = false,\n    allowNumSeparator: boolean | \"bail\" = true,\n  ): number | null {\n    const { n, pos } = readInt(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      radix,\n      len,\n      forceLen,\n      allowNumSeparator,\n      this.errorHandlers_readInt,\n    );\n    this.state.pos = pos;\n    return n;\n  }\n\n  readRadixNumber(radix: number): void {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n\n    this.state.pos += 2; // 0x\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        // Numeric literals can't have newlines, so this is safe to do.\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix,\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === charCodes.lowercaseN) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === charCodes.lowercaseM) {\n      throw this.raise(Errors.InvalidDecimal, { at: startLoc });\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    if (isBigInt) {\n      const str = this.input\n        .slice(startLoc.index, this.state.pos)\n        .replace(/[_n]/g, \"\");\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    this.finishToken(tt.num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  readNumber(startsWithDot: boolean): void {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, { at: this.state.curPosition() });\n    }\n    const hasLeadingZero =\n      this.state.pos - start >= 2 &&\n      this.input.charCodeAt(start) === charCodes.digit0;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, { at: startLoc });\n      if (!this.state.strict) {\n        // disallow numeric separators in non octal decimals and legacy octal likes\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          // Numeric literals can't have newlines, so this is safe to do.\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos),\n          });\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === charCodes.dot && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\n      !isOctal\n    ) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === charCodes.plusSign || next === charCodes.dash) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, { at: startLoc });\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === charCodes.lowercaseN) {\n      // disallow floats, legacy octal syntax and non octal decimals\n      // new style octal (\"0o\") is handled in this.readRadixNumber\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, { at: startLoc });\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === charCodes.lowercaseM) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, { at: startLoc });\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition(),\n      });\n    }\n\n    // remove \"_\" for numeric literal separator, and trailing `m` or `n`\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(tt.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(tt.num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  readCodePoint(throwOnInvalid: boolean): number | null {\n    const { code, pos } = readCodePoint(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      throwOnInvalid,\n      this.errorHandlers_readCodePoint,\n    );\n    this.state.pos = pos;\n    return code;\n  }\n\n  readString(quote: number): void {\n    const { str, pos, curLine, lineStart } = readStringContents(\n      quote === charCodes.quotationMark ? \"double\" : \"single\",\n      this.input,\n      this.state.pos + 1, // skip the quote\n      this.state.lineStart,\n      this.state.curLine,\n      this.errorHandlers_readStringContents_string,\n    );\n    this.state.pos = pos + 1; // skip the quote\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(tt.string, str);\n  }\n\n  // Reads template continuation `}...`\n  readTemplateContinuation(): void {\n    if (!this.match(tt.braceR)) {\n      this.unexpected(null, tt.braceR);\n    }\n    // rewind pos to `}`\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  // Reads template string tokens.\n  readTemplateToken(): void {\n    const opening = this.input[this.state.pos];\n    const { str, containsInvalid, pos, curLine, lineStart } =\n      readStringContents(\n        \"template\",\n        this.input,\n        this.state.pos + 1, // skip '`' or `}`\n        this.state.lineStart,\n        this.state.curLine,\n        this.errorHandlers_readStringContents_template,\n      );\n    this.state.pos = pos + 1; // skip '`' or `$`\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n\n    if (this.input.codePointAt(pos) === charCodes.graveAccent) {\n      this.finishToken(\n        tt.templateTail,\n        containsInvalid ? null : opening + str + \"`\",\n      );\n    } else {\n      this.state.pos++; // skip '{'\n      this.finishToken(\n        tt.templateNonTail,\n        containsInvalid ? null : opening + str + \"${\",\n      );\n    }\n  }\n\n  recordStrictModeErrors(\n    toParseError: DeferredStrictError,\n    { at }: { at: Position },\n  ) {\n    const index = at.index;\n\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, { at });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n  //\n  // When `firstCode` is given, it assumes it is always an identifier start and\n  // will skip reading start position again\n\n  readWord1(firstCode?: number): string {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === charCodes.backslash) {\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck =\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition(),\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, { at: escStart });\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  readWord(firstCode?: number): void {\n    const word = this.readWord1(firstCode);\n    const type = keywordTypes.get(word);\n    if (type !== undefined) {\n      // We don't use word as state.value here because word is a dynamic string\n      // while token label is a shared constant string\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(tt.name, word);\n    }\n  }\n\n  checkKeywordEscapes(): void {\n    const { type } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type),\n      });\n    }\n  }\n\n  /**\n   * Raise a `ParseError` given the appropriate properties. If passed a\n   * `Position` for the `at` property, raises the `ParseError` at that location.\n   * Otherwise, if passed a `Node`, raises the `ParseError` at the start\n   * location of that `Node`.\n   *\n   * If `errorRecovery` is `true`, the error is pushed to the errors array and\n   * returned. If `errorRecovery` is `false`, the error is instead thrown.\n   *\n   * @param {Class<ParseError<ErrorDetails>>>} ParseErrorClass\n   * @param {RaiseProperties<ErrorDetails>} raiseProperties\n   * @returns {(ParseError<ErrorDetails> | empty)}\n   * @memberof Tokenizer\n   */\n  raise<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    raiseProperties: RaiseProperties<ErrorDetails>,\n  ): ParseError<ErrorDetails> {\n    const { at, ...details } = raiseProperties;\n    const loc = at instanceof Position ? at : at.loc.start;\n    // @ts-expect-error: refine details typing\n    const error = toParseError({ loc, details });\n\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n\n    return error;\n  }\n\n  /**\n   * If `errorRecovery` is `false`, this method behaves identically to `raise`.\n   * If `errorRecovery` is `true`, this method will first see if there is\n   * already an error stored at the same `Position`, and replaces it with the\n   * one generated here.\n   *\n   * @param {Class<ParseError<ErrorDetails>>>} ParseErrorClass\n   * @param {RaiseProperties<ErrorDetails>} raiseProperties\n   * @returns {(ParseError<ErrorDetails> | empty)}\n   * @memberof Tokenizer\n   */\n  raiseOverwrite<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    raiseProperties: RaiseProperties<ErrorDetails>,\n  ): ParseError<ErrorDetails> | never {\n    const { at, ...details } = raiseProperties;\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        // @ts-expect-error: refine details typing\n        return (errors[i] = toParseError({ loc, details }));\n      }\n      if (error.loc.index < pos) break;\n    }\n\n    return this.raise(toParseError, raiseProperties);\n  }\n\n  // updateContext is used by the jsx plugin\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateContext(prevType: TokenType): void {}\n\n  // Raise an unexpected token error. Can take the expected token type.\n  unexpected(loc?: Position | null, type?: TokenType): void {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc,\n    });\n  }\n\n  expectPlugin(pluginName: Plugin, loc?: Position): true {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName],\n    });\n  }\n\n  expectOnePlugin(pluginNames: Plugin[]): void {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames,\n      });\n    }\n  }\n\n  errorBuilder(error: ParseErrorConstructor<{}>) {\n    return (pos: number, lineStart: number, curLine: number) => {\n      this.raise(error, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    };\n  }\n\n  errorHandlers_readInt: IntErrorHandlers = {\n    invalidDigit: (pos, lineStart, curLine, radix) => {\n      if (!this.options.errorRecovery) return false;\n\n      this.raise(Errors.InvalidDigit, {\n        at: buildPosition(pos, lineStart, curLine),\n        radix,\n      });\n      // Continue parsing the number as if there was no invalid digit.\n      return true;\n    },\n    numericSeparatorInEscapeSequence: this.errorBuilder(\n      Errors.NumericSeparatorInEscapeSequence,\n    ),\n    unexpectedNumericSeparator: this.errorBuilder(\n      Errors.UnexpectedNumericSeparator,\n    ),\n  };\n\n  errorHandlers_readCodePoint: CodePointErrorHandlers = {\n    ...this.errorHandlers_readInt,\n    invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n    invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),\n  };\n\n  errorHandlers_readStringContents_string: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: (pos, lineStart, curLine) => {\n      this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    },\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(Errors.UnterminatedString, {\n        // Report the error at the string quote\n        at: buildPosition(pos - 1, lineStart, curLine),\n      });\n    },\n  };\n\n  errorHandlers_readStringContents_template: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(Errors.UnterminatedTemplate, {\n        at: buildPosition(pos, lineStart, curLine),\n      });\n    },\n  };\n}\n"],"mappings":";;;;;;;AAGA;;AAKA;;AACA;;AAEA;;AACA;;AAQA;;AAMA;;AAMA;;AAGA;;;;;;;AAWA,SAASA,aAAT,CAAuBC,GAAvB,EAAoCC,SAApC,EAAuDC,OAAvD,EAAwE;EACtE,OAAO,IAAIC,kBAAJ,CAAaD,OAAb,EAAsBF,GAAG,GAAGC,SAA5B,EAAuCD,GAAvC,CAAP;AACD;;AAED,MAAMI,iBAAiB,GAAG,IAAIC,GAAJ,CAAQ,wCAAR,CAA1B;;AAgBO,MAAMC,KAAN,CAAY;EACjBC,WAAW,CAACC,KAAD,EAAe;IACxB,KAAKC,IAAL,GAAYD,KAAK,CAACC,IAAlB;IACA,KAAKC,KAAL,GAAaF,KAAK,CAACE,KAAnB;IACA,KAAKC,KAAL,GAAaH,KAAK,CAACG,KAAnB;IACA,KAAKC,GAAL,GAAWJ,KAAK,CAACI,GAAjB;IACA,KAAKC,GAAL,GAAW,IAAIC,wBAAJ,CAAmBN,KAAK,CAACO,QAAzB,EAAmCP,KAAK,CAACQ,MAAzC,CAAX;EACD;;AAPgB;;;;AAkBJ,MAAeC,SAAf,SAAiCC,iBAAjC,CAAgD;EAC7DC,WAAW;EAGXC,MAAM,GAA6B,EAA7B;;EAENb,WAAW,CAACc,OAAD,EAAmBC,KAAnB,EAAkC;IAC3C;IACA,KAAKd,KAAL,GAAa,IAAIe,cAAJ,EAAb;IACA,KAAKf,KAAL,CAAWgB,IAAX,CAAgBH,OAAhB;IACA,KAAKC,KAAL,GAAaA,KAAb;IACA,KAAKG,MAAL,GAAcH,KAAK,CAACG,MAApB;IACA,KAAKN,WAAL,GAAmB,KAAnB;EACD;;EAEDO,SAAS,CAACC,KAAD,EAA2B;IAGlC,KAAKP,MAAL,CAAYK,MAAZ,GAAqB,KAAKjB,KAAL,CAAWoB,YAAhC;IACA,KAAKR,MAAL,CAAYS,IAAZ,CAAiBF,KAAjB;IACA,EAAE,KAAKnB,KAAL,CAAWoB,YAAb;EACD;;EAIDE,IAAI,GAAS;IACX,KAAKC,mBAAL;;IACA,IAAI,KAAKV,OAAL,CAAaD,MAAjB,EAAyB;MACvB,KAAKM,SAAL,CAAe,IAAIpB,KAAJ,CAAU,KAAKE,KAAf,CAAf;IACD;;IAED,KAAKA,KAAL,CAAWwB,YAAX,GAA0B,KAAKxB,KAAL,CAAWG,KAArC;IACA,KAAKH,KAAL,CAAWyB,aAAX,GAA2B,KAAKzB,KAAL,CAAWQ,MAAtC;IACA,KAAKR,KAAL,CAAW0B,eAAX,GAA6B,KAAK1B,KAAL,CAAWO,QAAxC;IACA,KAAKoB,SAAL;EACD;;EAIDC,GAAG,CAAC3B,IAAD,EAA2B;IAC5B,IAAI,KAAK4B,KAAL,CAAW5B,IAAX,CAAJ,EAAsB;MACpB,KAAKqB,IAAL;MACA,OAAO,IAAP;IACD,CAHD,MAGO;MACL,OAAO,KAAP;IACD;EACF;;EASDO,KAAK,CAAC5B,IAAD,EAA2B;IAC9B,OAAO,KAAKD,KAAL,CAAWC,IAAX,KAAoBA,IAA3B;EACD;;EASD6B,oBAAoB,CAAC9B,KAAD,EAA+B;IACjD,OAAO;MACLR,GAAG,EAAEQ,KAAK,CAACR,GADN;MAELU,KAAK,EAAE,IAFF;MAGLD,IAAI,EAAED,KAAK,CAACC,IAHP;MAILE,KAAK,EAAEH,KAAK,CAACG,KAJR;MAKLC,GAAG,EAAEJ,KAAK,CAACI,GALN;MAML2B,OAAO,EAAE,CAAC,KAAKC,UAAL,EAAD,CANJ;MAOLC,MAAM,EAAEjC,KAAK,CAACiC,MAPT;MAQL1B,QAAQ,EAAEP,KAAK,CAACO,QARX;MASLkB,aAAa,EAAEzB,KAAK,CAACyB,aAThB;MAUL/B,OAAO,EAAEM,KAAK,CAACN,OAVV;MAWLD,SAAS,EAAEO,KAAK,CAACP,SAXZ;MAYLyC,WAAW,EAAElC,KAAK,CAACkC;IAZd,CAAP;EAcD;;EAkBDC,SAAS,GAAmB;IAC1B,MAAMC,GAAG,GAAG,KAAKpC,KAAjB;IAGA,KAAKA,KAAL,GAAa,KAAK8B,oBAAL,CAA0BM,GAA1B,CAAb;IAEA,KAAKzB,WAAL,GAAmB,IAAnB;IACA,KAAKgB,SAAL;IACA,KAAKhB,WAAL,GAAmB,KAAnB;IAEA,MAAM0B,IAAI,GAAG,KAAKrC,KAAlB;IACA,KAAKA,KAAL,GAAaoC,GAAb;IACA,OAAOC,IAAP;EACD;;EAEDC,cAAc,GAAW;IACvB,OAAO,KAAKC,mBAAL,CAAyB,KAAKvC,KAAL,CAAWR,GAApC,CAAP;EACD;;EAED+C,mBAAmB,CAAC/C,GAAD,EAAsB;IACvCgD,0BAAA,CAAeC,SAAf,GAA2BjD,GAA3B;IACA,OAAOgD,0BAAA,CAAeE,IAAf,CAAoB,KAAK5B,KAAzB,IAAkC0B,0BAAA,CAAeC,SAAjD,GAA6DjD,GAApE;EACD;;EAEDmD,iBAAiB,GAAW;IAC1B,OAAO,KAAK7B,KAAL,CAAW8B,UAAX,CAAsB,KAAKN,cAAL,EAAtB,CAAP;EACD;;EAEDO,cAAc,CAACrD,GAAD,EAAsB;IAKlC,IAAIsD,EAAE,GAAG,KAAKhC,KAAL,CAAW8B,UAAX,CAAsBpD,GAAtB,CAAT;;IACA,IAAI,CAACsD,EAAE,GAAG,MAAN,MAAkB,MAAlB,IAA4B,EAAEtD,GAAF,GAAQ,KAAKsB,KAAL,CAAWG,MAAnD,EAA2D;MACzD,MAAM8B,KAAK,GAAG,KAAKjC,KAAL,CAAW8B,UAAX,CAAsBpD,GAAtB,CAAd;;MACA,IAAI,CAACuD,KAAK,GAAG,MAAT,MAAqB,MAAzB,EAAiC;QAC/BD,EAAE,GAAG,WAAW,CAACA,EAAE,GAAG,KAAN,KAAgB,EAA3B,KAAkCC,KAAK,GAAG,KAA1C,CAAL;MACD;IACF;;IACD,OAAOD,EAAP;EACD;;EAKDE,SAAS,CAACC,MAAD,EAAwB;IAC/B,KAAKjD,KAAL,CAAWiD,MAAX,GAAoBA,MAApB;;IACA,IAAIA,MAAJ,EAAY;MAKV,KAAKjD,KAAL,CAAWkD,YAAX,CAAwBC,OAAxB,CAAgC,CAAC,CAACC,YAAD,EAAeC,EAAf,CAAD,KAC9B,KAAKC,KAAL,CAAWF,YAAX,EAAyB;QAAEC;MAAF,CAAzB,CADF;MAGA,KAAKrD,KAAL,CAAWkD,YAAX,CAAwBK,KAAxB;IACD;EACF;;EAEDvB,UAAU,GAAe;IACvB,OAAO,KAAKhC,KAAL,CAAW+B,OAAX,CAAmB,KAAK/B,KAAL,CAAW+B,OAAX,CAAmBd,MAAnB,GAA4B,CAA/C,CAAP;EACD;;EAKDU,SAAS,GAAS;IAChB,KAAK6B,SAAL;IACA,KAAKxD,KAAL,CAAWG,KAAX,GAAmB,KAAKH,KAAL,CAAWR,GAA9B;IACA,IAAI,CAAC,KAAKmB,WAAV,EAAuB,KAAKX,KAAL,CAAWO,QAAX,GAAsB,KAAKP,KAAL,CAAWkC,WAAX,EAAtB;;IACvB,IAAI,KAAKlC,KAAL,CAAWR,GAAX,IAAkB,KAAKyB,MAA3B,EAAmC;MACjC,KAAKwC,WAAL;MACA;IACD;;IAED,KAAKC,gBAAL,CAAsB,KAAKb,cAAL,CAAoB,KAAK7C,KAAL,CAAWR,GAA/B,CAAtB;EACD;;EAEDmE,gBAAgB,GAA+B;IAC7C,IAAIpD,QAAJ;IACA,IAAI,CAAC,KAAKI,WAAV,EAAuBJ,QAAQ,GAAG,KAAKP,KAAL,CAAWkC,WAAX,EAAX;IACvB,MAAM/B,KAAK,GAAG,KAAKH,KAAL,CAAWR,GAAzB;IACA,MAAMY,GAAG,GAAG,KAAKU,KAAL,CAAW8C,OAAX,CAAmB,IAAnB,EAAyBzD,KAAK,GAAG,CAAjC,CAAZ;;IACA,IAAIC,GAAG,KAAK,CAAC,CAAb,EAAgB;MAId,MAAM,KAAKkD,KAAL,CAAWO,kBAAA,CAAOC,mBAAlB,EAAuC;QAC3CT,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;MADuC,CAAvC,CAAN;IAGD;;IAED,KAAKlC,KAAL,CAAWR,GAAX,GAAiBY,GAAG,GAAG,CAAvB;IACA2D,sBAAA,CAAWtB,SAAX,GAAuBtC,KAAK,GAAG,CAA/B;;IACA,OAAO4D,sBAAA,CAAWrB,IAAX,CAAgB,KAAK5B,KAArB,KAA+BiD,sBAAA,CAAWtB,SAAX,IAAwBrC,GAA9D,EAAmE;MACjE,EAAE,KAAKJ,KAAL,CAAWN,OAAb;MACA,KAAKM,KAAL,CAAWP,SAAX,GAAuBsE,sBAAA,CAAWtB,SAAlC;IACD;;IAID,IAAI,KAAK9B,WAAT,EAAsB;IAGtB,MAAMqD,OAAuB,GAAG;MAC9B/D,IAAI,EAAE,cADwB;MAE9BC,KAAK,EAAE,KAAKY,KAAL,CAAWmD,KAAX,CAAiB9D,KAAK,GAAG,CAAzB,EAA4BC,GAA5B,CAFuB;MAG9BD,KAH8B;MAI9BC,GAAG,EAAEA,GAAG,GAAG,CAJmB;MAK9BC,GAAG,EAAE,IAAIC,wBAAJ,CAAmBC,QAAnB,EAA6B,KAAKP,KAAL,CAAWkC,WAAX,EAA7B;IALyB,CAAhC;IAOA,IAAI,KAAKrB,OAAL,CAAaD,MAAjB,EAAyB,KAAKM,SAAL,CAAe8C,OAAf;IACzB,OAAOA,OAAP;EACD;;EAEDE,eAAe,CAACC,SAAD,EAA+C;IAC5D,MAAMhE,KAAK,GAAG,KAAKH,KAAL,CAAWR,GAAzB;IACA,IAAIe,QAAJ;IACA,IAAI,CAAC,KAAKI,WAAV,EAAuBJ,QAAQ,GAAG,KAAKP,KAAL,CAAWkC,WAAX,EAAX;IACvB,IAAIkC,EAAE,GAAG,KAAKtD,KAAL,CAAW8B,UAAX,CAAuB,KAAK5C,KAAL,CAAWR,GAAX,IAAkB2E,SAAzC,CAAT;;IACA,IAAI,KAAKnE,KAAL,CAAWR,GAAX,GAAiB,KAAKyB,MAA1B,EAAkC;MAChC,OAAO,CAAC,IAAAoD,qBAAA,EAAUD,EAAV,CAAD,IAAkB,EAAE,KAAKpE,KAAL,CAAWR,GAAb,GAAmB,KAAKyB,MAAjD,EAAyD;QACvDmD,EAAE,GAAG,KAAKtD,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAL;MACD;IACF;;IAID,IAAI,KAAKmB,WAAT,EAAsB;IAGtB,MAAMP,GAAG,GAAG,KAAKJ,KAAL,CAAWR,GAAvB;IACA,MAAMU,KAAK,GAAG,KAAKY,KAAL,CAAWmD,KAAX,CAAiB9D,KAAK,GAAGgE,SAAzB,EAAoC/D,GAApC,CAAd;IAEA,MAAM4D,OAAsB,GAAG;MAC7B/D,IAAI,EAAE,aADuB;MAE7BC,KAF6B;MAG7BC,KAH6B;MAI7BC,GAJ6B;MAK7BC,GAAG,EAAE,IAAIC,wBAAJ,CAAmBC,QAAnB,EAA6B,KAAKP,KAAL,CAAWkC,WAAX,EAA7B;IALwB,CAA/B;IAOA,IAAI,KAAKrB,OAAL,CAAaD,MAAjB,EAAyB,KAAKM,SAAL,CAAe8C,OAAf;IACzB,OAAOA,OAAP;EACD;;EAKDR,SAAS,GAAS;IAChB,MAAMc,UAAU,GAAG,KAAKtE,KAAL,CAAWR,GAA9B;IACA,MAAM+E,QAAQ,GAAG,EAAjB;;IACAC,IAAI,EAAE,OAAO,KAAKxE,KAAL,CAAWR,GAAX,GAAiB,KAAKyB,MAA7B,EAAqC;MACzC,MAAMmD,EAAE,GAAG,KAAKtD,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAX;;MACA,QAAQ4E,EAAR;QACE;QACA;QACA;UACE,EAAE,KAAKpE,KAAL,CAAWR,GAAb;UACA;;QACF;UACE,IACE,KAAKsB,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,QADF,EAEE;YACA,EAAE,KAAKQ,KAAL,CAAWR,GAAb;UACD;;QAEH;QACA;QACA;UACE,EAAE,KAAKQ,KAAL,CAAWR,GAAb;UACA,EAAE,KAAKQ,KAAL,CAAWN,OAAb;UACA,KAAKM,KAAL,CAAWP,SAAX,GAAuB,KAAKO,KAAL,CAAWR,GAAlC;UACA;;QAEF;UACE,QAAQ,KAAKsB,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAR;YACE;cAAyB;gBACvB,MAAMwE,OAAO,GAAG,KAAKL,gBAAL,EAAhB;;gBACA,IAAIK,OAAO,KAAKS,SAAhB,EAA2B;kBACzB,KAAKC,UAAL,CAAgBV,OAAhB;kBACA,IAAI,KAAKnD,OAAL,CAAa8D,aAAjB,EAAgCJ,QAAQ,CAAClD,IAAT,CAAc2C,OAAd;gBACjC;;gBACD;cACD;;YAED;cAAsB;gBACpB,MAAMA,OAAO,GAAG,KAAKE,eAAL,CAAqB,CAArB,CAAhB;;gBACA,IAAIF,OAAO,KAAKS,SAAhB,EAA2B;kBACzB,KAAKC,UAAL,CAAgBV,OAAhB;kBACA,IAAI,KAAKnD,OAAL,CAAa8D,aAAjB,EAAgCJ,QAAQ,CAAClD,IAAT,CAAc2C,OAAd;gBACjC;;gBACD;cACD;;YAED;cACE,MAAMQ,IAAN;UApBJ;;UAsBA;;QAEF;UACE,IAAI,IAAAI,wBAAA,EAAaR,EAAb,CAAJ,EAAsB;YACpB,EAAE,KAAKpE,KAAL,CAAWR,GAAb;UACD,CAFD,MAEO,IAAI4E,EAAE,OAAF,IAAyB,CAAC,KAAKS,QAAnC,EAA6C;YAClD,MAAMrF,GAAG,GAAG,KAAKQ,KAAL,CAAWR,GAAvB;;YACA,IACE,KAAKsB,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,YACA,KAAKsB,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,QADA,KAEC8E,UAAU,KAAK,CAAf,IAAoB,KAAKtE,KAAL,CAAWP,SAAX,GAAuB6E,UAF5C,CADF,EAIE;cAEA,MAAMN,OAAO,GAAG,KAAKE,eAAL,CAAqB,CAArB,CAAhB;;cACA,IAAIF,OAAO,KAAKS,SAAhB,EAA2B;gBACzB,KAAKC,UAAL,CAAgBV,OAAhB;gBACA,IAAI,KAAKnD,OAAL,CAAa8D,aAAjB,EAAgCJ,QAAQ,CAAClD,IAAT,CAAc2C,OAAd;cACjC;YACF,CAXD,MAWO;cACL,MAAMQ,IAAN;YACD;UACF,CAhBM,MAgBA,IAAIJ,EAAE,OAAF,IAA6B,CAAC,KAAKS,QAAvC,EAAiD;YACtD,MAAMrF,GAAG,GAAG,KAAKQ,KAAL,CAAWR,GAAvB;;YACA,IACE,KAAKsB,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,YACA,KAAKsB,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,QADA,IAEA,KAAKsB,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,QAHF,EAIE;cAEA,MAAMwE,OAAO,GAAG,KAAKE,eAAL,CAAqB,CAArB,CAAhB;;cACA,IAAIF,OAAO,KAAKS,SAAhB,EAA2B;gBACzB,KAAKC,UAAL,CAAgBV,OAAhB;gBACA,IAAI,KAAKnD,OAAL,CAAa8D,aAAjB,EAAgCJ,QAAQ,CAAClD,IAAT,CAAc2C,OAAd;cACjC;YACF,CAXD,MAWO;cACL,MAAMQ,IAAN;YACD;UACF,CAhBM,MAgBA;YACL,MAAMA,IAAN;UACD;;MAnFL;IAqFD;;IAED,IAAID,QAAQ,CAACtD,MAAT,GAAkB,CAAtB,EAAyB;MACvB,MAAMb,GAAG,GAAG,KAAKJ,KAAL,CAAWR,GAAvB;MACA,MAAMsF,iBAAoC,GAAG;QAC3C3E,KAAK,EAAEmE,UADoC;QAE3ClE,GAF2C;QAG3CmE,QAH2C;QAI3CQ,WAAW,EAAE,IAJ8B;QAK3CC,YAAY,EAAE,IAL6B;QAM3CC,cAAc,EAAE;MAN2B,CAA7C;MAQA,KAAKjF,KAAL,CAAWkF,YAAX,CAAwB7D,IAAxB,CAA6ByD,iBAA7B;IACD;EACF;;EAODrB,WAAW,CAACxD,IAAD,EAAkBkF,GAAlB,EAAmC;IAC5C,KAAKnF,KAAL,CAAWI,GAAX,GAAiB,KAAKJ,KAAL,CAAWR,GAA5B;IACA,KAAKQ,KAAL,CAAWQ,MAAX,GAAoB,KAAKR,KAAL,CAAWkC,WAAX,EAApB;IACA,MAAMkD,QAAQ,GAAG,KAAKpF,KAAL,CAAWC,IAA5B;IACA,KAAKD,KAAL,CAAWC,IAAX,GAAkBA,IAAlB;IACA,KAAKD,KAAL,CAAWE,KAAX,GAAmBiF,GAAnB;;IAEA,IAAI,CAAC,KAAKxE,WAAV,EAAuB;MACrB,KAAK0E,aAAL,CAAmBD,QAAnB;IACD;EACF;;EAEDE,YAAY,CAACrF,IAAD,EAAwB;IAClC,KAAKD,KAAL,CAAWC,IAAX,GAAkBA,IAAlB;IAIA,KAAKoF,aAAL;EACD;;EAYDE,oBAAoB,GAAS;IAC3B,IAAI,KAAKvF,KAAL,CAAWR,GAAX,KAAmB,CAAnB,IAAwB,KAAKgG,qBAAL,EAA5B,EAA0D;MACxD;IACD;;IAED,MAAMC,OAAO,GAAG,KAAKzF,KAAL,CAAWR,GAAX,GAAiB,CAAjC;IACA,MAAM8B,IAAI,GAAG,KAAKuB,cAAL,CAAoB4C,OAApB,CAAb;;IACA,IAAInE,IAAI,MAAJ,IAA4BA,IAAI,MAApC,EAA0D;MACxD,MAAM,KAAKgC,KAAL,CAAWO,kBAAA,CAAO6B,wBAAlB,EAA4C;QAChDrC,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;MAD4C,CAA5C,CAAN;IAGD;;IAED,IACEZ,IAAI,QAAJ,IACCA,IAAI,OAAJ,IAAwC,KAAKqE,SAAL,CAAe,gBAAf,CAF3C,EAGE;MAKA,KAAKC,YAAL,CAAkB,gBAAlB;;MACA,IAAI,KAAKC,eAAL,CAAqB,gBAArB,EAAuC,YAAvC,MAAyD,MAA7D,EAAqE;QACnE,MAAM,KAAKvC,KAAL,CACJhC,IAAI,QAAJ,GACIuC,kBAAA,CAAOiC,4CADX,GAEIjC,kBAAA,CAAOkC,2CAHP,EAIJ;UAAE1C,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;QAAN,CAJI,CAAN;MAMD;;MAED,KAAKlC,KAAL,CAAWR,GAAX,IAAkB,CAAlB;;MACA,IAAI8B,IAAI,QAAR,EAAuC;QAErC,KAAKmC,WAAL;MACD,CAHD,MAGO;QAEL,KAAKA,WAAL;MACD;IACF,CA1BD,MA0BO,IAAI,IAAAuC,6BAAA,EAAkB1E,IAAlB,CAAJ,EAA6B;MAClC,EAAE,KAAKtB,KAAL,CAAWR,GAAb;MACA,KAAKiE,WAAL,MAAiC,KAAKwC,SAAL,CAAe3E,IAAf,CAAjC;IACD,CAHM,MAGA,IAAIA,IAAI,OAAR,EAAkC;MACvC,EAAE,KAAKtB,KAAL,CAAWR,GAAb;MACA,KAAKiE,WAAL,MAAiC,KAAKwC,SAAL,EAAjC;IACD,CAHM,MAGA;MACL,KAAKC,QAAL,KAAuB,CAAvB;IACD;EACF;;EAEDC,aAAa,GAAS;IACpB,MAAM7E,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IACA,IAAI8B,IAAI,MAAJ,IAA4BA,IAAI,MAApC,EAA0D;MACxD,KAAK8E,UAAL,CAAgB,IAAhB;MACA;IACD;;IAED,IACE9E,IAAI,OAAJ,IACA,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,QAFF,EAGE;MACA,KAAKQ,KAAL,CAAWR,GAAX,IAAkB,CAAlB;MACA,KAAKiE,WAAL;IACD,CAND,MAMO;MACL,EAAE,KAAKzD,KAAL,CAAWR,GAAb;MACA,KAAKiE,WAAL;IACD;EACF;;EAED4C,eAAe,GAAS;IACtB,MAAM/E,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IACA,IAAI8B,IAAI,OAAR,EAAiC;MAC/B,KAAK4E,QAAL,KAA8B,CAA9B;IACD,CAFD,MAEO;MACL,KAAKA,QAAL,KAAwB,CAAxB;IACD;EACF;;EAEDV,qBAAqB,GAAY;IAC/B,IAAI,KAAKxF,KAAL,CAAWR,GAAX,KAAmB,CAAnB,IAAwB,KAAKyB,MAAL,GAAc,CAA1C,EAA6C,OAAO,KAAP;IAE7C,IAAImD,EAAE,GAAG,KAAKtD,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAT;IACA,IAAI4E,EAAE,OAAN,EAAsC,OAAO,KAAP;IAEtC,MAAMjE,KAAK,GAAG,KAAKH,KAAL,CAAWR,GAAzB;IACA,KAAKQ,KAAL,CAAWR,GAAX,IAAkB,CAAlB;;IAEA,OAAO,CAAC,IAAA6E,qBAAA,EAAUD,EAAV,CAAD,IAAkB,EAAE,KAAKpE,KAAL,CAAWR,GAAb,GAAmB,KAAKyB,MAAjD,EAAyD;MACvDmD,EAAE,GAAG,KAAKtD,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAL;IACD;;IAED,MAAMU,KAAK,GAAG,KAAKY,KAAL,CAAWmD,KAAX,CAAiB9D,KAAK,GAAG,CAAzB,EAA4B,KAAKH,KAAL,CAAWR,GAAvC,CAAd;IAEA,KAAKiE,WAAL,KAA0CvD,KAA1C;IAEA,OAAO,IAAP;EACD;;EAEDoG,qBAAqB,CAACC,IAAD,EAAqB;IAExC,IAAItG,IAAI,GAAGsG,IAAI,OAAJ,UAAX;IACA,IAAIC,KAAK,GAAG,CAAZ;IACA,IAAIlF,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAX;;IAGA,IAAI+G,IAAI,OAAJ,IAA+BjF,IAAI,OAAvC,EAAgE;MAC9DkF,KAAK;MACLlF,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAP;MACAS,IAAI,KAAJ;IACD;;IAGD,IAAIqB,IAAI,OAAJ,IAA+B,CAAC,KAAKtB,KAAL,CAAWiC,MAA/C,EAAuD;MACrDuE,KAAK;MAILvG,IAAI,GAAGsG,IAAI,OAAJ,UAAP;IACD;;IAED,KAAKL,QAAL,CAAcjG,IAAd,EAAoBuG,KAApB;EACD;;EAEDC,kBAAkB,CAACF,IAAD,EAAqB;IAErC,MAAMjF,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IAEA,IAAI8B,IAAI,KAAKiF,IAAb,EAAmB;MACjB,IAAI,KAAKzF,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,QAAJ,EAAsE;QACpE,KAAK0G,QAAL,KAAyB,CAAzB;MACD,CAFD,MAEO;QACL,KAAKA,QAAL,CACEK,IAAI,QAAJ,UADF,EAEE,CAFF;MAID;;MACD;IACD;;IAED,IAAIA,IAAI,QAAR,EAAoC;MAElC,IAAIjF,IAAI,OAAR,EAAoC;QAClC,KAAK4E,QAAL,KAA2B,CAA3B;QACA;MACD;;MAED,IACE,KAAKP,SAAL,CAAe,gBAAf,KACArE,IAAI,QAFN,EAGE;QACA,IAAI,KAAKuE,eAAL,CAAqB,gBAArB,EAAuC,YAAvC,MAAyD,KAA7D,EAAoE;UAClE,MAAM,KAAKvC,KAAL,CAAWO,kBAAA,CAAO6C,yCAAlB,EAA6D;YACjErD,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;UAD6D,CAA7D,CAAN;QAGD;;QACD,KAAKlC,KAAL,CAAWR,GAAX,IAAkB,CAAlB;QACA,KAAKiE,WAAL;QACA;MACD;;MAGD,IACE,KAAKkC,SAAL,CAAe,gBAAf,KACArE,IAAI,OAFN,EAGE;QACA,IAAI,KAAKuE,eAAL,CAAqB,gBAArB,EAAuC,YAAvC,MAAyD,KAA7D,EAAoE;UAClE,MAAM,KAAKvC,KAAL,CAAWO,kBAAA,CAAO8C,wCAAlB,EAA4D;YAChEtD,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;UAD4D,CAA5D,CAAN;QAGD;;QACD,KAAKlC,KAAL,CAAWR,GAAX,IAAkB,CAAlB;QACA,KAAKiE,WAAL;QACA;MACD;IACF;;IAED,IAAInC,IAAI,OAAR,EAAiC;MAC/B,KAAK4E,QAAL,KAAyB,CAAzB;MACA;IACD;;IAED,KAAKA,QAAL,CACEK,IAAI,QAAJ,UADF,EAEE,CAFF;EAID;;EAEDK,eAAe,GAAS;IACtB,MAAMtF,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IAGA,IAAI8B,IAAI,OAAJ,IAA+B,CAAC,KAAKtB,KAAL,CAAWiC,MAA/C,EAAuD;MAIrD,KAAKiE,QAAL,KAA4B,CAA5B;IACD,CALD,MAOK,IACH5E,IAAI,OAAJ,IAGA,KAAKqE,SAAL,CAAe,CACb,kBADa,EAEb;MAAEkB,QAAQ,EAAE,MAAZ;MAAoBC,UAAU,EAAE;IAAhC,CAFa,CAAf,CAJG,EAQH;MACA,KAAKZ,QAAL,KAA8B,CAA9B;MAGA,MAAMa,WAAW,GAAG,KAAKjG,KAAL,CAAWkG,WAAX,CAAuB,KAAKhH,KAAL,CAAWR,GAAlC,CAApB;;MACA,IAAIuH,WAAW,OAAf,EAAqC;QACnC,MAAM,KAAKE,UAAL,EAAN;MACD;IACF,CAhBI,MAkBA;MACH,KAAKf,QAAL,KAA6B,CAA7B;IACD;EACF;;EAEDgB,gBAAgB,GAAS;IACvB,MAAM5F,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IAGA,IACE8B,IAAI,OAAJ,IACA,KAAKqE,SAAL,CAAe,CACb,kBADa,EAEb;MAAEkB,QAAQ,EAAE,MAAZ;MAAoBC,UAAU,EAAE;IAAhC,CAFa,CAAf,CAFF,EAME;MACA,KAAKZ,QAAL,KAA2B,CAA3B;IACD,CARD,MAUK;MACH,KAAKA,QAAL,KAAqB,CAArB;IACD;EACF;;EAEDiB,kBAAkB,CAACZ,IAAD,EAAqB;IAErC,MAAMjF,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IAEA,IAAI8B,IAAI,KAAKiF,IAAb,EAAmB;MACjB,KAAKL,QAAL,KAAyB,CAAzB;MACA;IACD;;IAED,IAAI5E,IAAI,OAAR,EAAiC;MAC/B,KAAK4E,QAAL,KAAyB,CAAzB;IACD,CAFD,MAEO;MACL,KAAKA,QAAL,KAA0B,CAA1B;IACD;EACF;;EAEDkB,YAAY,GAAS;IAEnB,MAAM;MAAE5H;IAAF,IAAU,KAAKQ,KAArB;IACA,MAAMsB,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,CAAb;;IAEA,IAAI8B,IAAI,OAAR,EAAiC;MAC/B,IAAI,KAAKR,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,QAAJ,EAA2D;QACzD,KAAK0G,QAAL,KAAyB,CAAzB;QACA;MACD;;MACD,KAAKA,QAAL,KAA4B,CAA5B;MACA;IACD;;IAED,IAAI5E,IAAI,OAAR,EAAiC;MAE/B,KAAK4E,QAAL,KAA6B,CAA7B;MACA;IACD;;IAED,KAAKA,QAAL,KAAqB,CAArB;EACD;;EAEDmB,YAAY,GAAS;IAEnB,MAAM;MAAE7H;IAAF,IAAU,KAAKQ,KAArB;IACA,MAAMsB,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,CAAb;;IAEA,IAAI8B,IAAI,OAAR,EAAoC;MAClC,MAAMgG,IAAI,GACR,KAAKxG,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG,CAA5B,WAA2D,CAA3D,GAA+D,CADjE;;MAEA,IAAI,KAAKsB,KAAL,CAAW8B,UAAX,CAAsBpD,GAAG,GAAG8H,IAA5B,QAAJ,EAA8D;QAC5D,KAAKpB,QAAL,KAAyBoB,IAAI,GAAG,CAAhC;QACA;MACD;;MACD,KAAKpB,QAAL,KAA4BoB,IAA5B;MACA;IACD;;IAED,IAAIhG,IAAI,OAAR,EAAiC;MAE/B,KAAK4E,QAAL,KAA6B,CAA7B;MACA;IACD;;IAED,KAAKA,QAAL,KAAqB,CAArB;EACD;;EAEDqB,iBAAiB,CAAChB,IAAD,EAAqB;IAEpC,MAAMjF,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;IACA,IAAI8B,IAAI,OAAR,EAAiC;MAC/B,KAAK4E,QAAL,KAEE,KAAKpF,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,WACI,CADJ,GAEI,CAJN;MAMA;IACD;;IACD,IAAI+G,IAAI,OAAJ,IAA+BjF,IAAI,OAAvC,EAAmE;MAEjE,KAAKtB,KAAL,CAAWR,GAAX,IAAkB,CAAlB;MACA,KAAKiE,WAAL;MACA;IACD;;IACD,KAAKyC,QAAL,CAAcK,IAAI,OAAJ,UAAd,EAA6D,CAA7D;EACD;;EAEDiB,kBAAkB,GAAS;IAEzB,MAAMlG,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;IACA,MAAMiI,KAAK,GAAG,KAAK3G,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAd;;IACA,IAAI8B,IAAI,OAAR,EAAqC;MACnC,IAAImG,KAAK,OAAT,EAAkC;QAEhC,KAAKvB,QAAL,KAAyB,CAAzB;MACD,CAHD,MAGO;QAEL,KAAKA,QAAL,KAAoC,CAApC;MACD;IACF,CARD,MAQO,IACL5E,IAAI,OAAJ,IACA,EAAEmG,KAAK,MAAL,IAA6BA,KAAK,MAApC,CAFK,EAGL;MAEA,KAAKzH,KAAL,CAAWR,GAAX,IAAkB,CAAlB;MACA,KAAKiE,WAAL;IACD,CAPM,MAOA;MACL,EAAE,KAAKzD,KAAL,CAAWR,GAAb;MACA,KAAKiE,WAAL;IACD;EACF;;EAEDC,gBAAgB,CAAC6C,IAAD,EAAqB;IACnC,QAAQA,IAAR;MAIE;QACE,KAAKJ,aAAL;QACA;;MAGF;QACE,EAAE,KAAKnG,KAAL,CAAWR,GAAb;QACA,KAAKiE,WAAL;QACA;;MACF;QACE,EAAE,KAAKzD,KAAL,CAAWR,GAAb;QACA,KAAKiE,WAAL;QACA;;MACF;QACE,EAAE,KAAKzD,KAAL,CAAWR,GAAb;QACA,KAAKiE,WAAL;QACA;;MACF;QACE,EAAE,KAAKzD,KAAL,CAAWR,GAAb;QACA,KAAKiE,WAAL;QACA;;MACF;QACE,IACE,KAAKkC,SAAL,CAAe,gBAAf,KACA,KAAK7E,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,SAFF,EAGE;UACA,IAAI,KAAKqG,eAAL,CAAqB,gBAArB,EAAuC,YAAvC,MAAyD,KAA7D,EAAoE;YAClE,MAAM,KAAKvC,KAAL,CACJO,kBAAA,CAAO6D,0CADH,EAEJ;cAAErE,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;YAAN,CAFI,CAAN;UAID;;UAGD,KAAKlC,KAAL,CAAWR,GAAX,IAAkB,CAAlB;UACA,KAAKiE,WAAL;QACD,CAdD,MAcO;UACL,EAAE,KAAKzD,KAAL,CAAWR,GAAb;UACA,KAAKiE,WAAL;QACD;;QACD;;MACF;QACE,EAAE,KAAKzD,KAAL,CAAWR,GAAb;QACA,KAAKiE,WAAL;QACA;;MACF;QACE,IACE,KAAKkC,SAAL,CAAe,gBAAf,KACA,KAAK7E,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,SAFF,EAGE;UACA,IAAI,KAAKqG,eAAL,CAAqB,gBAArB,EAAuC,YAAvC,MAAyD,KAA7D,EAAoE;YAClE,MAAM,KAAKvC,KAAL,CACJO,kBAAA,CAAO8D,2CADH,EAEJ;cAAEtE,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;YAAN,CAFI,CAAN;UAID;;UAGD,KAAKlC,KAAL,CAAWR,GAAX,IAAkB,CAAlB;UACA,KAAKiE,WAAL;QACD,CAdD,MAcO;UACL,EAAE,KAAKzD,KAAL,CAAWR,GAAb;UACA,KAAKiE,WAAL;QACD;;QACD;;MACF;QACE,EAAE,KAAKzD,KAAL,CAAWR,GAAb;QACA,KAAKiE,WAAL;QACA;;MAEF;QACE,IACE,KAAKkC,SAAL,CAAe,cAAf,KACA,KAAK7E,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,QAFF,EAGE;UACA,KAAK0G,QAAL,KAA8B,CAA9B;QACD,CALD,MAKO;UACL,EAAE,KAAKlG,KAAL,CAAWR,GAAb;UACA,KAAKiE,WAAL;QACD;;QACD;;MAEF;QACE,KAAK+D,kBAAL;QACA;;MAEF;QACE,KAAKI,iBAAL;QACA;;MAEF;QAAuB;UACrB,MAAMtG,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAX,GAAiB,CAAvC,CAAb;;UAEA,IAAI8B,IAAI,QAAJ,IAAiCA,IAAI,OAAzC,EAAoE;YAClE,KAAKuG,eAAL,CAAqB,EAArB;YACA;UACD;;UAED,IAAIvG,IAAI,QAAJ,IAAiCA,IAAI,OAAzC,EAAoE;YAClE,KAAKuG,eAAL,CAAqB,CAArB;YACA;UACD;;UAED,IAAIvG,IAAI,OAAJ,IAAiCA,IAAI,OAAzC,EAAoE;YAClE,KAAKuG,eAAL,CAAqB,CAArB;YACA;UACD;QACF;;MAGD;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;QACE,KAAKzB,UAAL,CAAgB,KAAhB;QACA;;MAGF;MACA;QACE,KAAK0B,UAAL,CAAgBvB,IAAhB;QACA;;MAOF;QACE,KAAKF,eAAL;QACA;;MAEF;MACA;QACE,KAAKC,qBAAL,CAA2BC,IAA3B;QACA;;MAEF;MACA;QACE,KAAKE,kBAAL,CAAwBF,IAAxB;QACA;;MAEF;QACE,KAAKK,eAAL;QACA;;MAEF;MACA;QACE,KAAKO,kBAAL,CAAwBZ,IAAxB;QACA;;MAEF;QACE,KAAKa,YAAL;QACA;;MAEF;QACE,KAAKC,YAAL;QACA;;MAEF;MACA;QACE,KAAKE,iBAAL,CAAuBhB,IAAvB;QACA;;MAEF;QACE,KAAKL,QAAL,KAAwB,CAAxB;QACA;;MAEF;QACE,KAAKgB,gBAAL;QACA;;MAEF;QACE,KAAK3B,oBAAL;QACA;;MAEF;QACE,KAAKwC,QAAL;QACA;;MAEF;QACE,IAAI,IAAA/B,6BAAA,EAAkBO,IAAlB,CAAJ,EAA6B;UAC3B,KAAKwB,QAAL,CAAcxB,IAAd;UACA;QACD;;IAjML;;IAoMA,MAAM,KAAKjD,KAAL,CAAWO,kBAAA,CAAOmE,wBAAlB,EAA4C;MAChD3E,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX,EAD4C;MAEhD+E,UAAU,EAAEgB,MAAM,CAACC,aAAP,CAAqB3B,IAArB;IAFoC,CAA5C,CAAN;EAID;;EAEDL,QAAQ,CAACjG,IAAD,EAAkBqH,IAAlB,EAAsC;IAC5C,MAAMa,GAAG,GAAG,KAAKrH,KAAL,CAAWmD,KAAX,CAAiB,KAAKjE,KAAL,CAAWR,GAA5B,EAAiC,KAAKQ,KAAL,CAAWR,GAAX,GAAiB8H,IAAlD,CAAZ;IACA,KAAKtH,KAAL,CAAWR,GAAX,IAAkB8H,IAAlB;IACA,KAAK7D,WAAL,CAAiBxD,IAAjB,EAAuBkI,GAAvB;EACD;;EAEDC,UAAU,GAAS;IACjB,MAAM7H,QAAQ,GAAG,KAAKP,KAAL,CAAWO,QAA5B;IACA,MAAMJ,KAAK,GAAG,KAAKH,KAAL,CAAWG,KAAX,GAAmB,CAAjC;IACA,IAAIkI,OAAJ,EAAaC,OAAb;IACA,IAAI;MAAE9I;IAAF,IAAU,KAAKQ,KAAnB;;IACA,QAAS,EAAER,GAAX,EAAgB;MACd,IAAIA,GAAG,IAAI,KAAKyB,MAAhB,EAAwB;QAEtB,MAAM,KAAKqC,KAAL,CAAWO,kBAAA,CAAO0E,kBAAlB,EAAsC;UAC1ClF,EAAE,EAAE,IAAAmF,wCAAA,EAA+BjI,QAA/B,EAAyC,CAAzC;QADsC,CAAtC,CAAN;MAGD;;MACD,MAAM6D,EAAE,GAAG,KAAKtD,KAAL,CAAW8B,UAAX,CAAsBpD,GAAtB,CAAX;;MACA,IAAI,IAAA6E,qBAAA,EAAUD,EAAV,CAAJ,EAAmB;QACjB,MAAM,KAAKd,KAAL,CAAWO,kBAAA,CAAO0E,kBAAlB,EAAsC;UAC1ClF,EAAE,EAAE,IAAAmF,wCAAA,EAA+BjI,QAA/B,EAAyC,CAAzC;QADsC,CAAtC,CAAN;MAGD;;MACD,IAAI8H,OAAJ,EAAa;QACXA,OAAO,GAAG,KAAV;MACD,CAFD,MAEO;QACL,IAAIjE,EAAE,OAAN,EAAwC;UACtCkE,OAAO,GAAG,IAAV;QACD,CAFD,MAEO,IAAIlE,EAAE,OAAF,IAAuCkE,OAA3C,EAAoD;UACzDA,OAAO,GAAG,KAAV;QACD,CAFM,MAEA,IAAIlE,EAAE,OAAF,IAA0B,CAACkE,OAA/B,EAAwC;UAC7C;QACD;;QACDD,OAAO,GAAGjE,EAAE,OAAZ;MACD;IACF;;IACD,MAAMqE,OAAO,GAAG,KAAK3H,KAAL,CAAWmD,KAAX,CAAiB9D,KAAjB,EAAwBX,GAAxB,CAAhB;IACA,EAAEA,GAAF;IAEA,IAAIkJ,IAAI,GAAG,EAAX;;IAEA,MAAMjD,OAAO,GAAG,MAEd,IAAA+C,wCAAA,EAA+BjI,QAA/B,EAAyCf,GAAG,GAAG,CAAN,GAAUW,KAAnD,CAFF;;IAIA,OAAOX,GAAG,GAAG,KAAKyB,MAAlB,EAA0B;MACxB,MAAM6B,EAAE,GAAG,KAAKD,cAAL,CAAoBrD,GAApB,CAAX;MAEA,MAAMmJ,IAAI,GAAGV,MAAM,CAACW,YAAP,CAAoB9F,EAApB,CAAb;;MAGA,IAAIlD,iBAAiB,CAACiJ,GAAlB,CAAsB/F,EAAtB,CAAJ,EAA+B;QAC7B,IAAIA,EAAE,QAAN,EAAiC;UAC/B,KAAK8C,YAAL,CAAkB,mBAAlB,EAAuCH,OAAO,EAA9C;;UAEA,IAAIiD,IAAI,CAACI,QAAL,CAAc,GAAd,CAAJ,EAAwB;YACtB,KAAKxF,KAAL,CAAWO,kBAAA,CAAOkF,yBAAlB,EAA6C;cAAE1F,EAAE,EAAEoC,OAAO;YAAb,CAA7C;UACD;QACF,CAND,MAMO,IAAI3C,EAAE,QAAN,EAAiC;UACtC,IAAI4F,IAAI,CAACI,QAAL,CAAc,GAAd,CAAJ,EAAwB;YACtB,KAAKxF,KAAL,CAAWO,kBAAA,CAAOkF,yBAAlB,EAA6C;cAAE1F,EAAE,EAAEoC,OAAO;YAAb,CAA7C;UACD;QACF;;QACD,IAAIiD,IAAI,CAACI,QAAL,CAAcH,IAAd,CAAJ,EAAyB;UACvB,KAAKrF,KAAL,CAAWO,kBAAA,CAAOmF,oBAAlB,EAAwC;YAAE3F,EAAE,EAAEoC,OAAO;UAAb,CAAxC;QACD;MACF,CAfD,MAeO,IAAI,IAAAwD,4BAAA,EAAiBnG,EAAjB,KAAwBA,EAAE,OAA9B,EAAwD;QAC7D,KAAKQ,KAAL,CAAWO,kBAAA,CAAOqF,oBAAlB,EAAwC;UAAE7F,EAAE,EAAEoC,OAAO;QAAb,CAAxC;MACD,CAFM,MAEA;QACL;MACD;;MAED,EAAEjG,GAAF;MACAkJ,IAAI,IAAIC,IAAR;IACD;;IACD,KAAK3I,KAAL,CAAWR,GAAX,GAAiBA,GAAjB;IAEA,KAAKiE,WAAL,MAA4B;MAC1B0F,OAAO,EAAEV,OADiB;MAE1BW,KAAK,EAAEV;IAFmB,CAA5B;EAID;;EAWDW,OAAO,CACLC,KADK,EAELC,GAFK,EAGLC,QAAiB,GAAG,KAHf,EAILC,iBAAmC,GAAG,IAJjC,EAKU;IACf,MAAM;MAAEC,CAAF;MAAKlK;IAAL,IAAa,IAAA6J,2BAAA,EACjB,KAAKvI,KADY,EAEjB,KAAKd,KAAL,CAAWR,GAFM,EAGjB,KAAKQ,KAAL,CAAWP,SAHM,EAIjB,KAAKO,KAAL,CAAWN,OAJM,EAKjB4J,KALiB,EAMjBC,GANiB,EAOjBC,QAPiB,EAQjBC,iBARiB,EASjB,KAAKE,qBATY,CAAnB;IAWA,KAAK3J,KAAL,CAAWR,GAAX,GAAiBA,GAAjB;IACA,OAAOkK,CAAP;EACD;;EAED7B,eAAe,CAACyB,KAAD,EAAsB;IACnC,MAAM/I,QAAQ,GAAG,KAAKP,KAAL,CAAWkC,WAAX,EAAjB;IACA,IAAI0H,QAAQ,GAAG,KAAf;IAEA,KAAK5J,KAAL,CAAWR,GAAX,IAAkB,CAAlB;IACA,MAAM2F,GAAG,GAAG,KAAKkE,OAAL,CAAaC,KAAb,CAAZ;;IACA,IAAInE,GAAG,IAAI,IAAX,EAAiB;MACf,KAAK7B,KAAL,CAAWO,kBAAA,CAAOgG,YAAlB,EAAgC;QAE9BxG,EAAE,EAAE,IAAAmF,wCAAA,EAA+BjI,QAA/B,EAAyC,CAAzC,CAF0B;QAG9B+I;MAH8B,CAAhC;IAKD;;IACD,MAAMhI,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAb;;IAEA,IAAI8B,IAAI,QAAR,EAAmC;MACjC,EAAE,KAAKtB,KAAL,CAAWR,GAAb;MACAoK,QAAQ,GAAG,IAAX;IACD,CAHD,MAGO,IAAItI,IAAI,QAAR,EAAmC;MACxC,MAAM,KAAKgC,KAAL,CAAWO,kBAAA,CAAOiG,cAAlB,EAAkC;QAAEzG,EAAE,EAAE9C;MAAN,CAAlC,CAAN;IACD;;IAED,IAAI,IAAAyF,6BAAA,EAAkB,KAAKnD,cAAL,CAAoB,KAAK7C,KAAL,CAAWR,GAA/B,CAAlB,CAAJ,EAA4D;MAC1D,MAAM,KAAK8D,KAAL,CAAWO,kBAAA,CAAOkG,gBAAlB,EAAoC;QACxC1G,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;MADoC,CAApC,CAAN;IAGD;;IAED,IAAI0H,QAAJ,EAAc;MACZ,MAAMzB,GAAG,GAAG,KAAKrH,KAAL,CACTmD,KADS,CACH1D,QAAQ,CAACyJ,KADN,EACa,KAAKhK,KAAL,CAAWR,GADxB,EAETyK,OAFS,CAED,OAFC,EAEQ,EAFR,CAAZ;MAGA,KAAKxG,WAAL,MAA4B0E,GAA5B;MACA;IACD;;IAED,KAAK1E,WAAL,MAAyB0B,GAAzB;EACD;;EAIDiB,UAAU,CAAC8D,aAAD,EAA+B;IACvC,MAAM/J,KAAK,GAAG,KAAKH,KAAL,CAAWR,GAAzB;IACA,MAAMe,QAAQ,GAAG,KAAKP,KAAL,CAAWkC,WAAX,EAAjB;IACA,IAAIiI,OAAO,GAAG,KAAd;IACA,IAAIP,QAAQ,GAAG,KAAf;IACA,IAAIQ,SAAS,GAAG,KAAhB;IACA,IAAIC,WAAW,GAAG,KAAlB;IACA,IAAIC,OAAO,GAAG,KAAd;;IAEA,IAAI,CAACJ,aAAD,IAAkB,KAAKb,OAAL,CAAa,EAAb,MAAqB,IAA3C,EAAiD;MAC/C,KAAK/F,KAAL,CAAWO,kBAAA,CAAO0G,aAAlB,EAAiC;QAAElH,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;MAAN,CAAjC;IACD;;IACD,MAAMsI,cAAc,GAClB,KAAKxK,KAAL,CAAWR,GAAX,GAAiBW,KAAjB,IAA0B,CAA1B,IACA,KAAKW,KAAL,CAAW8B,UAAX,CAAsBzC,KAAtB,QAFF;;IAIA,IAAIqK,cAAJ,EAAoB;MAClB,MAAMC,OAAO,GAAG,KAAK3J,KAAL,CAAWmD,KAAX,CAAiB9D,KAAjB,EAAwB,KAAKH,KAAL,CAAWR,GAAnC,CAAhB;MACA,KAAKkL,sBAAL,CAA4B7G,kBAAA,CAAO8G,kBAAnC,EAAuD;QAAEtH,EAAE,EAAE9C;MAAN,CAAvD;;MACA,IAAI,CAAC,KAAKP,KAAL,CAAWiD,MAAhB,EAAwB;QAEtB,MAAM2H,aAAa,GAAGH,OAAO,CAAC7G,OAAR,CAAgB,GAAhB,CAAtB;;QACA,IAAIgH,aAAa,GAAG,CAApB,EAAuB;UAErB,KAAKtH,KAAL,CAAWO,kBAAA,CAAOgH,yBAAlB,EAA6C;YAC3CxH,EAAE,EAAE,IAAAmF,wCAAA,EAA+BjI,QAA/B,EAAyCqK,aAAzC;UADuC,CAA7C;QAGD;MACF;;MACDN,OAAO,GAAGE,cAAc,IAAI,CAAC,OAAO9H,IAAP,CAAY+H,OAAZ,CAA7B;IACD;;IAED,IAAInJ,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAX;;IACA,IAAI8B,IAAI,OAAJ,IAA0B,CAACgJ,OAA/B,EAAwC;MACtC,EAAE,KAAKtK,KAAL,CAAWR,GAAb;MACA,KAAK6J,OAAL,CAAa,EAAb;MACAc,OAAO,GAAG,IAAV;MACA7I,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAP;IACD;;IAED,IACE,CAAC8B,IAAI,OAAJ,IAAiCA,IAAI,QAAtC,KACA,CAACgJ,OAFH,EAGE;MACAhJ,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,EAAE,KAAK5C,KAAL,CAAWR,GAAnC,CAAP;;MACA,IAAI8B,IAAI,OAAJ,IAA+BA,IAAI,OAAvC,EAA4D;QAC1D,EAAE,KAAKtB,KAAL,CAAWR,GAAb;MACD;;MACD,IAAI,KAAK6J,OAAL,CAAa,EAAb,MAAqB,IAAzB,EAA+B;QAC7B,KAAK/F,KAAL,CAAWO,kBAAA,CAAOiH,wBAAlB,EAA4C;UAAEzH,EAAE,EAAE9C;QAAN,CAA5C;MACD;;MACD4J,OAAO,GAAG,IAAV;MACAE,WAAW,GAAG,IAAd;MACA/I,IAAI,GAAG,KAAKR,KAAL,CAAW8B,UAAX,CAAsB,KAAK5C,KAAL,CAAWR,GAAjC,CAAP;IACD;;IAED,IAAI8B,IAAI,QAAR,EAAmC;MAGjC,IAAI6I,OAAO,IAAIK,cAAf,EAA+B;QAC7B,KAAKlH,KAAL,CAAWO,kBAAA,CAAOkH,oBAAlB,EAAwC;UAAE1H,EAAE,EAAE9C;QAAN,CAAxC;MACD;;MACD,EAAE,KAAKP,KAAL,CAAWR,GAAb;MACAoK,QAAQ,GAAG,IAAX;IACD;;IAED,IAAItI,IAAI,QAAR,EAAmC;MACjC,KAAKsE,YAAL,CAAkB,SAAlB,EAA6B,KAAK5F,KAAL,CAAWkC,WAAX,EAA7B;;MACA,IAAImI,WAAW,IAAIG,cAAnB,EAAmC;QACjC,KAAKlH,KAAL,CAAWO,kBAAA,CAAOiG,cAAlB,EAAkC;UAAEzG,EAAE,EAAE9C;QAAN,CAAlC;MACD;;MACD,EAAE,KAAKP,KAAL,CAAWR,GAAb;MACA4K,SAAS,GAAG,IAAZ;IACD;;IAED,IAAI,IAAApE,6BAAA,EAAkB,KAAKnD,cAAL,CAAoB,KAAK7C,KAAL,CAAWR,GAA/B,CAAlB,CAAJ,EAA4D;MAC1D,MAAM,KAAK8D,KAAL,CAAWO,kBAAA,CAAOkG,gBAAlB,EAAoC;QACxC1G,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;MADoC,CAApC,CAAN;IAGD;;IAGD,MAAMiG,GAAG,GAAG,KAAKrH,KAAL,CAAWmD,KAAX,CAAiB9D,KAAjB,EAAwB,KAAKH,KAAL,CAAWR,GAAnC,EAAwCyK,OAAxC,CAAgD,QAAhD,EAA0D,EAA1D,CAAZ;;IAEA,IAAIL,QAAJ,EAAc;MACZ,KAAKnG,WAAL,MAA4B0E,GAA5B;MACA;IACD;;IAED,IAAIiC,SAAJ,EAAe;MACb,KAAK3G,WAAL,MAA6B0E,GAA7B;MACA;IACD;;IAED,MAAMhD,GAAG,GAAGmF,OAAO,GAAGU,QAAQ,CAAC7C,GAAD,EAAM,CAAN,CAAX,GAAsB8C,UAAU,CAAC9C,GAAD,CAAnD;IACA,KAAK1E,WAAL,MAAyB0B,GAAzB;EACD;;EAID+F,aAAa,CAACC,cAAD,EAAyC;IACpD,MAAM;MAAE5E,IAAF;MAAQ/G;IAAR,IAAgB,IAAA0L,iCAAA,EACpB,KAAKpK,KADe,EAEpB,KAAKd,KAAL,CAAWR,GAFS,EAGpB,KAAKQ,KAAL,CAAWP,SAHS,EAIpB,KAAKO,KAAL,CAAWN,OAJS,EAKpByL,cALoB,EAMpB,KAAKC,2BANe,CAAtB;IAQA,KAAKpL,KAAL,CAAWR,GAAX,GAAiBA,GAAjB;IACA,OAAO+G,IAAP;EACD;;EAEDuB,UAAU,CAACuD,KAAD,EAAsB;IAC9B,MAAM;MAAElD,GAAF;MAAO3I,GAAP;MAAYE,OAAZ;MAAqBD;IAArB,IAAmC,IAAA6L,sCAAA,EACvCD,KAAK,OAAL,GAAoC,QAApC,GAA+C,QADR,EAEvC,KAAKvK,KAFkC,EAGvC,KAAKd,KAAL,CAAWR,GAAX,GAAiB,CAHsB,EAIvC,KAAKQ,KAAL,CAAWP,SAJ4B,EAKvC,KAAKO,KAAL,CAAWN,OAL4B,EAMvC,KAAK6L,uCANkC,CAAzC;IAQA,KAAKvL,KAAL,CAAWR,GAAX,GAAiBA,GAAG,GAAG,CAAvB;IACA,KAAKQ,KAAL,CAAWP,SAAX,GAAuBA,SAAvB;IACA,KAAKO,KAAL,CAAWN,OAAX,GAAqBA,OAArB;IACA,KAAK+D,WAAL,MAA4B0E,GAA5B;EACD;;EAGDqD,wBAAwB,GAAS;IAC/B,IAAI,CAAC,KAAK3J,KAAL,GAAL,EAA4B;MAC1B,KAAKoF,UAAL,CAAgB,IAAhB;IACD;;IAED,KAAKjH,KAAL,CAAWR,GAAX;IACA,KAAKoI,iBAAL;EACD;;EAGDA,iBAAiB,GAAS;IACxB,MAAM6D,OAAO,GAAG,KAAK3K,KAAL,CAAW,KAAKd,KAAL,CAAWR,GAAtB,CAAhB;IACA,MAAM;MAAE2I,GAAF;MAAOuD,eAAP;MAAwBlM,GAAxB;MAA6BE,OAA7B;MAAsCD;IAAtC,IACJ,IAAA6L,sCAAA,EACE,UADF,EAEE,KAAKxK,KAFP,EAGE,KAAKd,KAAL,CAAWR,GAAX,GAAiB,CAHnB,EAIE,KAAKQ,KAAL,CAAWP,SAJb,EAKE,KAAKO,KAAL,CAAWN,OALb,EAME,KAAKiM,yCANP,CADF;IASA,KAAK3L,KAAL,CAAWR,GAAX,GAAiBA,GAAG,GAAG,CAAvB;IACA,KAAKQ,KAAL,CAAWP,SAAX,GAAuBA,SAAvB;IACA,KAAKO,KAAL,CAAWN,OAAX,GAAqBA,OAArB;;IAEA,IAAI,KAAKoB,KAAL,CAAWkG,WAAX,CAAuBxH,GAAvB,QAAJ,EAA2D;MACzD,KAAKiE,WAAL,KAEEiI,eAAe,GAAG,IAAH,GAAUD,OAAO,GAAGtD,GAAV,GAAgB,GAF3C;IAID,CALD,MAKO;MACL,KAAKnI,KAAL,CAAWR,GAAX;MACA,KAAKiE,WAAL,KAEEiI,eAAe,GAAG,IAAH,GAAUD,OAAO,GAAGtD,GAAV,GAAgB,IAF3C;IAID;EACF;;EAEDuC,sBAAsB,CACpBtH,YADoB,EAEpB;IAAEC;EAAF,CAFoB,EAGpB;IACA,MAAM2G,KAAK,GAAG3G,EAAE,CAAC2G,KAAjB;;IAEA,IAAI,KAAKhK,KAAL,CAAWiD,MAAX,IAAqB,CAAC,KAAKjD,KAAL,CAAWkD,YAAX,CAAwB2F,GAAxB,CAA4BmB,KAA5B,CAA1B,EAA8D;MAC5D,KAAK1G,KAAL,CAAWF,YAAX,EAAyB;QAAEC;MAAF,CAAzB;IACD,CAFD,MAEO;MACL,KAAKrD,KAAL,CAAWkD,YAAX,CAAwB0I,GAAxB,CAA4B5B,KAA5B,EAAmC,CAAC5G,YAAD,EAAeC,EAAf,CAAnC;IACD;EACF;;EAWD4C,SAAS,CAAC4F,SAAD,EAA6B;IACpC,KAAK7L,KAAL,CAAW8L,WAAX,GAAyB,KAAzB;IACA,IAAIC,IAAI,GAAG,EAAX;IACA,MAAM5L,KAAK,GAAG,KAAKH,KAAL,CAAWR,GAAzB;IACA,IAAIwM,UAAU,GAAG,KAAKhM,KAAL,CAAWR,GAA5B;;IACA,IAAIqM,SAAS,KAAKpH,SAAlB,EAA6B;MAC3B,KAAKzE,KAAL,CAAWR,GAAX,IAAkBqM,SAAS,IAAI,MAAb,GAAsB,CAAtB,GAA0B,CAA5C;IACD;;IAED,OAAO,KAAK7L,KAAL,CAAWR,GAAX,GAAiB,KAAKyB,MAA7B,EAAqC;MACnC,MAAMmD,EAAE,GAAG,KAAKvB,cAAL,CAAoB,KAAK7C,KAAL,CAAWR,GAA/B,CAAX;;MACA,IAAI,IAAAyJ,4BAAA,EAAiB7E,EAAjB,CAAJ,EAA0B;QACxB,KAAKpE,KAAL,CAAWR,GAAX,IAAkB4E,EAAE,IAAI,MAAN,GAAe,CAAf,GAAmB,CAArC;MACD,CAFD,MAEO,IAAIA,EAAE,OAAN,EAAgC;QACrC,KAAKpE,KAAL,CAAW8L,WAAX,GAAyB,IAAzB;QAEAC,IAAI,IAAI,KAAKjL,KAAL,CAAWmD,KAAX,CAAiB+H,UAAjB,EAA6B,KAAKhM,KAAL,CAAWR,GAAxC,CAAR;QACA,MAAMyM,QAAQ,GAAG,KAAKjM,KAAL,CAAWkC,WAAX,EAAjB;QACA,MAAMgK,eAAe,GACnB,KAAKlM,KAAL,CAAWR,GAAX,KAAmBW,KAAnB,GAA2B6F,6BAA3B,GAA+CiD,4BADjD;;QAGA,IAAI,KAAKnI,KAAL,CAAW8B,UAAX,CAAsB,EAAE,KAAK5C,KAAL,CAAWR,GAAnC,SAAJ,EAAsE;UACpE,KAAK8D,KAAL,CAAWO,kBAAA,CAAOsI,oBAAlB,EAAwC;YACtC9I,EAAE,EAAE,KAAKrD,KAAL,CAAWkC,WAAX;UADkC,CAAxC;UAGA8J,UAAU,GAAG,KAAKhM,KAAL,CAAWR,GAAX,GAAiB,CAA9B;UACA;QACD;;QAED,EAAE,KAAKQ,KAAL,CAAWR,GAAb;QACA,MAAM4M,GAAG,GAAG,KAAKlB,aAAL,CAAmB,IAAnB,CAAZ;;QACA,IAAIkB,GAAG,KAAK,IAAZ,EAAkB;UAChB,IAAI,CAACF,eAAe,CAACE,GAAD,CAApB,EAA2B;YACzB,KAAK9I,KAAL,CAAWO,kBAAA,CAAOwI,0BAAlB,EAA8C;cAAEhJ,EAAE,EAAE4I;YAAN,CAA9C;UACD;;UAEDF,IAAI,IAAI9D,MAAM,CAACC,aAAP,CAAqBkE,GAArB,CAAR;QACD;;QACDJ,UAAU,GAAG,KAAKhM,KAAL,CAAWR,GAAxB;MACD,CA1BM,MA0BA;QACL;MACD;IACF;;IACD,OAAOuM,IAAI,GAAG,KAAKjL,KAAL,CAAWmD,KAAX,CAAiB+H,UAAjB,EAA6B,KAAKhM,KAAL,CAAWR,GAAxC,CAAd;EACD;;EAKDuI,QAAQ,CAAC8D,SAAD,EAA2B;IACjC,MAAME,IAAI,GAAG,KAAK9F,SAAL,CAAe4F,SAAf,CAAb;;IACA,MAAM5L,IAAI,GAAGqM,gBAAA,CAAaC,GAAb,CAAiBR,IAAjB,CAAb;;IACA,IAAI9L,IAAI,KAAKwE,SAAb,EAAwB;MAGtB,KAAKhB,WAAL,CAAiBxD,IAAjB,EAAuB,IAAAuM,sBAAA,EAAevM,IAAf,CAAvB;IACD,CAJD,MAIO;MACL,KAAKwD,WAAL,MAA0BsI,IAA1B;IACD;EACF;;EAEDxK,mBAAmB,GAAS;IAC1B,MAAM;MAAEtB;IAAF,IAAW,KAAKD,KAAtB;;IACA,IAAI,IAAAyM,sBAAA,EAAexM,IAAf,KAAwB,KAAKD,KAAL,CAAW8L,WAAvC,EAAoD;MAClD,KAAKxI,KAAL,CAAWO,kBAAA,CAAO6I,0BAAlB,EAA8C;QAC5CrJ,EAAE,EAAE,KAAKrD,KAAL,CAAWO,QAD6B;QAE5CoM,YAAY,EAAE,IAAAH,sBAAA,EAAevM,IAAf;MAF8B,CAA9C;IAID;EACF;;EAgBDqD,KAAK,CACHF,YADG,EAEHwJ,eAFG,EAGuB;IAC1B,MAAM;MAAEvJ;IAAF,IAAqBuJ,eAA3B;IAAA,MAAeC,OAAf,iCAA2BD,eAA3B;;IACA,MAAMvM,GAAG,GAAGgD,EAAE,YAAY1D,kBAAd,GAAyB0D,EAAzB,GAA8BA,EAAE,CAAChD,GAAH,CAAOF,KAAjD;IAEA,MAAM2M,KAAK,GAAG1J,YAAY,CAAC;MAAE/C,GAAF;MAAOwM;IAAP,CAAD,CAA1B;IAEA,IAAI,CAAC,KAAKhM,OAAL,CAAakM,aAAlB,EAAiC,MAAMD,KAAN;IACjC,IAAI,CAAC,KAAKnM,WAAV,EAAuB,KAAKX,KAAL,CAAWgN,MAAX,CAAkB3L,IAAlB,CAAuByL,KAAvB;IAEvB,OAAOA,KAAP;EACD;;EAaDG,cAAc,CACZ7J,YADY,EAEZwJ,eAFY,EAGsB;IAClC,MAAM;MAAEvJ;IAAF,IAAqBuJ,eAA3B;IAAA,MAAeC,OAAf,iCAA2BD,eAA3B;;IACA,MAAMvM,GAAG,GAAGgD,EAAE,YAAY1D,kBAAd,GAAyB0D,EAAzB,GAA8BA,EAAE,CAAChD,GAAH,CAAOF,KAAjD;IACA,MAAMX,GAAG,GAAGa,GAAG,CAAC2J,KAAhB;IACA,MAAMgD,MAAM,GAAG,KAAKhN,KAAL,CAAWgN,MAA1B;;IAEA,KAAK,IAAIE,CAAC,GAAGF,MAAM,CAAC/L,MAAP,GAAgB,CAA7B,EAAgCiM,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;MAC3C,MAAMJ,KAAK,GAAGE,MAAM,CAACE,CAAD,CAApB;;MACA,IAAIJ,KAAK,CAACzM,GAAN,CAAU2J,KAAV,KAAoBxK,GAAxB,EAA6B;QAE3B,OAAQwN,MAAM,CAACE,CAAD,CAAN,GAAY9J,YAAY,CAAC;UAAE/C,GAAF;UAAOwM;QAAP,CAAD,CAAhC;MACD;;MACD,IAAIC,KAAK,CAACzM,GAAN,CAAU2J,KAAV,GAAkBxK,GAAtB,EAA2B;IAC5B;;IAED,OAAO,KAAK8D,KAAL,CAAWF,YAAX,EAAyBwJ,eAAzB,CAAP;EACD;;EAIDvH,aAAa,CAACD,QAAD,EAA4B,CAAE;;EAG3C6B,UAAU,CAAC5G,GAAD,EAAwBJ,IAAxB,EAAgD;IACxD,MAAM,KAAKqD,KAAL,CAAWO,kBAAA,CAAOsJ,eAAlB,EAAmC;MACvCC,QAAQ,EAAEnN,IAAI,GAAG,IAAAuM,sBAAA,EAAevM,IAAf,CAAH,GAA0B,IADD;MAEvCoD,EAAE,EAAEhD,GAAG,IAAI,IAAP,GAAcA,GAAd,GAAoB,KAAKL,KAAL,CAAWO;IAFI,CAAnC,CAAN;EAID;;EAEDqF,YAAY,CAACyH,UAAD,EAAqBhN,GAArB,EAA2C;IACrD,IAAI,KAAKsF,SAAL,CAAe0H,UAAf,CAAJ,EAAgC;MAC9B,OAAO,IAAP;IACD;;IAED,MAAM,KAAK/J,KAAL,CAAWO,kBAAA,CAAOyJ,aAAlB,EAAiC;MACrCjK,EAAE,EAAEhD,GAAG,IAAI,IAAP,GAAcA,GAAd,GAAoB,KAAKL,KAAL,CAAWO,QADE;MAErCgN,aAAa,EAAE,CAACF,UAAD;IAFsB,CAAjC,CAAN;EAID;;EAEDG,eAAe,CAACC,WAAD,EAA8B;IAC3C,IAAI,CAACA,WAAW,CAACC,IAAZ,CAAiBC,IAAI,IAAI,KAAKhI,SAAL,CAAegI,IAAf,CAAzB,CAAL,EAAqD;MACnD,MAAM,KAAKrK,KAAL,CAAWO,kBAAA,CAAO+J,mBAAlB,EAAuC;QAC3CvK,EAAE,EAAE,KAAKrD,KAAL,CAAWO,QAD4B;QAE3CgN,aAAa,EAAEE;MAF4B,CAAvC,CAAN;IAID;EACF;;EAEDI,YAAY,CAACf,KAAD,EAAmC;IAC7C,OAAO,CAACtN,GAAD,EAAcC,SAAd,EAAiCC,OAAjC,KAAqD;MAC1D,KAAK4D,KAAL,CAAWwJ,KAAX,EAAkB;QAChBzJ,EAAE,EAAE9D,aAAa,CAACC,GAAD,EAAMC,SAAN,EAAiBC,OAAjB;MADD,CAAlB;IAGD,CAJD;EAKD;;EAEDiK,qBAAqB,GAAqB;IACxCmE,YAAY,EAAE,CAACtO,GAAD,EAAMC,SAAN,EAAiBC,OAAjB,EAA0B4J,KAA1B,KAAoC;MAChD,IAAI,CAAC,KAAKzI,OAAL,CAAakM,aAAlB,EAAiC,OAAO,KAAP;MAEjC,KAAKzJ,KAAL,CAAWO,kBAAA,CAAOgG,YAAlB,EAAgC;QAC9BxG,EAAE,EAAE9D,aAAa,CAACC,GAAD,EAAMC,SAAN,EAAiBC,OAAjB,CADa;QAE9B4J;MAF8B,CAAhC;MAKA,OAAO,IAAP;IACD,CAVuC;IAWxCyE,gCAAgC,EAAE,KAAKF,YAAL,CAChChK,kBAAA,CAAOmK,gCADyB,CAXM;IAcxCC,0BAA0B,EAAE,KAAKJ,YAAL,CAC1BhK,kBAAA,CAAOqK,0BADmB;EAdY,CAArB;EAmBrB9C,2BAA2B,qBACtB,KAAKzB,qBADiB;IAEzBwE,qBAAqB,EAAE,KAAKN,YAAL,CAAkBhK,kBAAA,CAAOuK,qBAAzB,CAFE;IAGzBC,gBAAgB,EAAE,KAAKR,YAAL,CAAkBhK,kBAAA,CAAOyK,gBAAzB;EAHO;EAM3B/C,uCAAuC,qBAClC,KAAKH,2BAD6B;IAErCmD,mBAAmB,EAAE,CAAC/O,GAAD,EAAMC,SAAN,EAAiBC,OAAjB,KAA6B;MAChD,KAAKgL,sBAAL,CAA4B7G,kBAAA,CAAO2K,mBAAnC,EAAwD;QACtDnL,EAAE,EAAE9D,aAAa,CAACC,GAAD,EAAMC,SAAN,EAAiBC,OAAjB;MADqC,CAAxD;IAGD,CANoC;IAOrC+O,YAAY,EAAE,CAACjP,GAAD,EAAMC,SAAN,EAAiBC,OAAjB,KAA6B;MACzC,MAAM,KAAK4D,KAAL,CAAWO,kBAAA,CAAO6K,kBAAlB,EAAsC;QAE1CrL,EAAE,EAAE9D,aAAa,CAACC,GAAG,GAAG,CAAP,EAAUC,SAAV,EAAqBC,OAArB;MAFyB,CAAtC,CAAN;IAID;EAZoC;EAevCiM,yCAAyC,qBACpC,KAAKP,2BAD+B;IAEvCmD,mBAAmB,EAAE,KAAKV,YAAL,CAAkBhK,kBAAA,CAAO2K,mBAAzB,CAFkB;IAGvCC,YAAY,EAAE,CAACjP,GAAD,EAAMC,SAAN,EAAiBC,OAAjB,KAA6B;MACzC,MAAM,KAAK4D,KAAL,CAAWO,kBAAA,CAAO8K,oBAAlB,EAAwC;QAC5CtL,EAAE,EAAE9D,aAAa,CAACC,GAAD,EAAMC,SAAN,EAAiBC,OAAjB;MAD2B,CAAxC,CAAN;IAGD;EAPsC;AA39CoB"}