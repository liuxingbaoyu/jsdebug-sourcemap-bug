{"version":3,"names":[],"sources":["../src/types.ts"],"sourcesContent":["import type { SourceType } from \"./options\";\nimport type { Token } from \"./tokenizer\";\nimport type { SourceLocation } from \"./util/location\";\nimport type { PlaceholderTypes } from \"./plugins/placeholders\";\nimport type { ParseError } from \"./parse-error\";\n\n/*\n * If making any changes to the AST, update:\n * - This repository:\n *   - This file\n *   - `ast` directory\n * - Babel repository:\n *   - packages/babel-types/src/definitions\n *   - packages/babel-generators/src/generators\n */\n\ninterface CommentBase {\n  type: \"CommentBlock\" | \"CommentLine\";\n  value: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n}\n\nexport interface CommentBlock extends CommentBase {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends CommentBase {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\n// A whitespace containing comments\nexport interface CommentWhitespace {\n  start: number;\n  end: number;\n  comments: Array<Comment>;\n  leadingNode: Node | null;\n  trailingNode: Node | null;\n  containerNode: Node | null;\n}\n\nexport interface NodeBase {\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  range: [number, number];\n  leadingComments?: Array<Comment>;\n  trailingComments?: Array<Comment>;\n  innerComments?: Array<Comment>;\n  extra: {\n    [key: string]: any;\n  };\n}\n\n// Using a union type for `Node` makes type-checking too slow.\n// Instead, add an index signature to allow a Node to be treated as anything.\n// todo(flow->ts): this probably should be replaced with union\nexport interface Node extends NodeBase {\n  type: string;\n  [key: string]: any;\n}\nexport type Expression = Node;\nexport type Statement = Node;\nexport type Pattern =\n  | Identifier\n  | ObjectPattern\n  | ArrayPattern\n  | RestElement\n  | AssignmentPattern;\n//| Placeholder<\"Pattern\">;\nexport type Declaration =\n  | VariableDeclaration\n  | ClassDeclaration\n  | FunctionDeclaration\n  | TsInterfaceDeclaration\n  | TsTypeAliasDeclaration\n  | TsEnumDeclaration\n  | TsModuleDeclaration;\n// | Placeholder<\"Declaration\">;\n\nexport interface DeclarationBase extends NodeBase {\n  // TypeScript allows declarations to be prefixed by `declare`.\n  //TODO: a FunctionDeclaration is never \"declare\", because it's a TSDeclareFunction instead.\n  declare?: true;\n}\n\n// TODO: Not in spec\nexport interface HasDecorators extends NodeBase {\n  decorators?: Decorator[];\n}\n\nexport interface InterpreterDirective extends NodeBase {\n  type: \"InterpreterDirective\";\n  value: string;\n}\n\nexport interface Identifier extends PatternBase {\n  type: \"Identifier\";\n  name: string;\n  // @deprecated\n  __clone(): Identifier;\n  // TypeScript only. Used in case of an optional parameter.\n  optional?: true | null;\n}\n// | Placeholder<\"Identifier\">;\n\nexport interface PrivateName extends NodeBase {\n  type: \"PrivateName\";\n  id: Identifier;\n}\n\n// Literals\n\nexport type Literal =\n  | RegExpLiteral\n  | NullLiteral\n  | StringLiteral\n  | BooleanLiteral\n  | NumericLiteral\n  | BigIntLiteral\n  | DecimalLiteral;\n\ntype RegExpFlag = \"g\" | \"i\" | \"m\" | \"u\" | \"s\" | \"y\" | \"v\";\n\nexport interface RegExpLiteral extends NodeBase {\n  type: \"RegExpLiteral\";\n  pattern: string;\n  flags: RegExpFlag[];\n}\n\nexport interface NullLiteral extends NodeBase {\n  type: \"NullLiteral\";\n}\n\nexport interface StringLiteral extends NodeBase {\n  type: \"StringLiteral\";\n  value: string;\n}\n\nexport interface BooleanLiteral extends NodeBase {\n  type: \"BooleanLiteral\";\n  value: boolean;\n}\n\nexport interface NumericLiteral extends NodeBase {\n  type: \"NumericLiteral\";\n  value: number;\n}\n\nexport interface BigIntLiteral extends NodeBase {\n  type: \"BigIntLiteral\";\n  value: number;\n}\n\nexport interface DecimalLiteral extends NodeBase {\n  type: \"DecimalLiteral\";\n  value: number;\n}\n\nexport interface ParserOutput {\n  comments: Comment[];\n  errors: Array<ParseError<any>>;\n  tokens?: Array<Token | Comment>;\n}\n// Programs\n\nexport type BlockStatementLike = Program | BlockStatement;\n\nexport interface File extends NodeBase, ParserOutput {\n  type: \"File\";\n  program: Program;\n}\n\nexport interface Program extends NodeBase {\n  type: \"Program\";\n  sourceType: SourceType;\n  body: Array<Statement | ModuleDeclaration>; // TODO: $ReadOnlyArray,\n  directives: Directive[]; // TODO: Not in spec,\n  interpreter: InterpreterDirective | null;\n}\n\n// Functions\n\nexport type Function =\n  | NormalFunction\n  | ArrowFunctionExpression\n  | ObjectMethod\n  | ClassMethod;\n\nexport type NormalFunction = FunctionDeclaration | FunctionExpression;\n\nexport interface BodilessFunctionOrMethodBase extends HasDecorators {\n  // TODO: Remove this. Should not assign \"id\" to methods.\n  // https://github.com/babel/babylon/issues/535\n  id: Identifier | undefined | null;\n  params: Array<Pattern | TSParameterProperty>;\n  generator: boolean;\n  async: boolean;\n  // TODO: All not in spec\n  expression: boolean;\n  typeParameters?: TypeParameterDeclarationBase | null;\n  returnType?: TypeAnnotationBase | null;\n}\n\nexport interface FunctionBase extends BodilessFunctionOrMethodBase {\n  body: BlockStatement;\n}\n\n// Statements\n\nexport interface ExpressionStatement extends NodeBase {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n\nexport interface BlockStatement extends NodeBase {\n  type: \"BlockStatement\";\n  body: Array<Statement>; // TODO: $ReadOnlyArray,\n  directives: Directive[];\n}\n// | Placeholder<\"BlockStatement\">;\n\nexport interface EmptyStatement extends NodeBase {\n  type: \"EmptyStatement\";\n}\n\nexport interface DebuggerStatement extends NodeBase {\n  type: \"DebuggerStatement\";\n}\n\nexport interface WithStatement extends NodeBase {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n\nexport interface ReturnStatement extends NodeBase {\n  type: \"ReturnStatement\";\n  argument: Expression | undefined | null;\n}\n\nexport interface LabeledStatement extends NodeBase {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n\nexport interface BreakStatement extends NodeBase {\n  type: \"BreakStatement\";\n  label: Identifier | undefined | null;\n}\n\nexport interface ContinueStatement extends NodeBase {\n  type: \"ContinueStatement\";\n  label: Identifier | undefined | null;\n}\n\n// Choice\n\nexport interface IfStatement extends NodeBase {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate: Statement | undefined | null;\n}\n\nexport interface SwitchStatement extends NodeBase {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: SwitchCase[];\n}\n\nexport interface SwitchCase extends NodeBase {\n  type: \"SwitchCase\";\n  test: Expression | undefined | null;\n  consequent: Statement[];\n}\n\n// Exceptions\n\nexport interface ThrowStatement extends NodeBase {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n\nexport interface TryStatement extends NodeBase {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler: CatchClause | null;\n  finalizer: BlockStatement | null;\n}\n\nexport interface CatchClause extends NodeBase {\n  type: \"CatchClause\";\n  param: Pattern;\n  body: BlockStatement;\n}\n\n// Loops\n\nexport interface WhileStatement extends NodeBase {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n\nexport interface DoWhileStatement extends NodeBase {\n  type: \"DoWhileStatement\";\n  body: Statement;\n  test: Expression;\n}\n\nexport type ForLike = ForStatement | ForInOf;\n\nexport interface ForStatement extends NodeBase {\n  type: \"ForStatement\";\n  init: VariableDeclaration | Expression | undefined | null;\n  test: Expression | undefined | null;\n  update: Expression | undefined | null;\n  body: Statement;\n}\n\nexport type ForInOf = ForInStatement | ForOfStatement;\n\ninterface ForInOfBase extends NodeBase {\n  left: VariableDeclaration | Expression;\n  right: Expression;\n  body: Statement;\n}\n\nexport interface ForInStatement extends ForInOfBase {\n  type: \"ForInStatement\";\n  // TODO: Shouldn't be here, but have to declare it because it's assigned to a ForInOf unconditionally.\n  await: boolean;\n}\n\nexport interface ForOfStatement extends ForInOfBase {\n  type: \"ForOfStatement\";\n  await: boolean;\n}\n\n// Declarations\n\nexport interface OptFunctionDeclaration extends FunctionBase, DeclarationBase {\n  type: \"FunctionDeclaration\";\n}\n\nexport interface FunctionDeclaration extends OptFunctionDeclaration {\n  id: Identifier;\n}\n\nexport interface VariableDeclaration extends DeclarationBase, HasDecorators {\n  type: \"VariableDeclaration\";\n  declarations: VariableDeclarator[];\n  kind: \"var\" | \"let\" | \"const\";\n}\n\nexport interface VariableDeclarator extends NodeBase {\n  type: \"VariableDeclarator\";\n  id: Pattern;\n  init: Expression | undefined | null;\n  // TypeScript only:\n  definite?: true;\n}\n\n// Misc\n\nexport interface ArgumentPlaceholder extends NodeBase {\n  type: \"ArgumentPlaceholder\";\n}\n\nexport interface Decorator extends NodeBase {\n  type: \"Decorator\";\n  expression: Expression;\n  arguments?: Array<Expression | SpreadElement>;\n}\n\nexport interface Directive extends NodeBase {\n  type: \"Directive\";\n  value: DirectiveLiteral;\n}\n\nexport interface DirectiveLiteral extends NodeBase {\n  type: \"DirectiveLiteral\";\n  value: string;\n}\n\nexport interface ImportAttribute extends NodeBase {\n  type: \"ImportAttribute\";\n  key: Identifier | StringLiteral;\n  value: StringLiteral;\n}\n\n// Expressions\n\nexport interface Super extends NodeBase {\n  type: \"Super\";\n}\n\nexport interface Import extends NodeBase {\n  type: \"Import\";\n}\n\nexport interface ThisExpression extends NodeBase {\n  type: \"ThisExpression\";\n}\n\nexport interface ArrowFunctionExpression extends BodilessFunctionOrMethodBase {\n  type: \"ArrowFunctionExpression\";\n  body: BlockStatement | Expression;\n}\n\nexport interface YieldExpression extends NodeBase {\n  type: \"YieldExpression\";\n  argument: Expression | undefined | null;\n  delegate: boolean;\n}\n\nexport interface AwaitExpression extends NodeBase {\n  type: \"AwaitExpression\";\n  argument: Expression;\n}\n\nexport interface ArrayExpression extends NodeBase {\n  type: \"ArrayExpression\";\n  elements: Array<Expression | SpreadElement | undefined | null>;\n}\n\nexport interface DoExpression extends NodeBase {\n  type: \"DoExpression\";\n  body: BlockStatement | undefined | null;\n  async: boolean;\n}\n\nexport interface TupleExpression extends NodeBase {\n  type: \"TupleExpression\";\n  elements: Array<Expression | SpreadElement | undefined | null>;\n}\n\nexport interface ObjectExpression extends NodeBase {\n  type: \"ObjectExpression\";\n  properties: Array<ObjectProperty | ObjectMethod | SpreadElement>;\n}\nexport interface RecordExpression extends NodeBase {\n  type: \"RecordExpression\";\n  properties: Array<ObjectProperty | ObjectMethod | SpreadElement>;\n}\n\nexport type ObjectOrClassMember = ClassMethod | ClassProperty | ObjectMember;\n\nexport type ObjectMember = ObjectProperty | ObjectMethod;\n\nexport interface ObjectMemberBase extends NodeBase {\n  key: Expression;\n  computed: boolean;\n  value: Expression | Pattern;\n  decorators?: Decorator[];\n  kind?: \"get\" | \"set\" | \"method\";\n  method: boolean; // TODO: Not in spec,\n  typeParameters?: TypeParameterDeclarationBase | null; // TODO: Not in spec,\n  variance?: FlowVariance | null; // TODO: Not in spec\n}\n\nexport interface ObjectProperty extends ObjectMemberBase {\n  type: \"ObjectProperty\";\n  shorthand: boolean;\n  value: Expression | Pattern;\n}\n\nexport interface ObjectMethod extends ObjectMemberBase, FunctionBase {\n  type: \"ObjectMethod\";\n  kind: \"get\" | \"set\" | \"method\"; // Never \"constructor\"\n  value: Expression;\n}\n\nexport interface FunctionExpression extends FunctionBase {\n  kind?: void; // never set,\n  type: \"FunctionExpression\";\n}\n\n// Unary operations\n\nexport interface UnaryExpression extends NodeBase {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n\nexport type UnaryOperator =\n  | \"-\"\n  | \"+\"\n  | \"!\"\n  | \"~\"\n  | \"typeof\"\n  | \"void\"\n  | \"delete\"\n  | \"throw\";\n\nexport interface UpdateExpression extends NodeBase {\n  type: \"UpdateExpression\";\n  operator: UpdateOperator;\n  argument: Expression;\n  prefix: boolean;\n}\n\nexport type UpdateOperator = \"++\" | \"--\";\n\n// Binary operations\n\nexport interface BinaryExpression extends NodeBase {\n  type: \"BinaryExpression\";\n  operator: BinaryOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport type BinaryOperator =\n  | \"==\"\n  | \"!=\"\n  | \"===\"\n  | \"!==\"\n  | \"<\"\n  | \"<=\"\n  | \">\"\n  | \">=\"\n  | \"<<\"\n  | \">>\"\n  | \">>>\"\n  | \"+\"\n  | \"-\"\n  | \"*\"\n  | \"/\"\n  | \"%\"\n  | \"|\"\n  | \"^\"\n  | \"&\"\n  | \"in\"\n  | \"instanceof\";\n\nexport interface AssignmentExpression extends NodeBase {\n  type: \"AssignmentExpression\";\n  operator: AssignmentOperator;\n  left: Pattern | Expression;\n  right: Expression;\n}\n\nexport type AssignmentOperator =\n  | \"=\"\n  | \"+=\"\n  | \"-=\"\n  | \"*=\"\n  | \"/=\"\n  | \"%=\"\n  | \"<<=\"\n  | \">>=\"\n  | \">>>=\"\n  | \"|=\"\n  | \"^=\"\n  | \"&=\";\n\nexport interface LogicalExpression extends NodeBase {\n  type: \"LogicalExpression\";\n  operator: LogicalOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport type LogicalOperator = \"||\" | \"&&\";\n\nexport interface SpreadElement extends NodeBase {\n  type: \"SpreadElement\";\n  argument: Expression;\n}\n\nexport interface MemberExpression extends NodeBase {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression;\n  computed: boolean;\n}\n\nexport interface OptionalMemberExpression extends NodeBase {\n  type: \"OptionalMemberExpression\";\n  object: Expression | Super;\n  property: Expression;\n  computed: boolean;\n  optional: boolean;\n}\n\nexport interface OptionalCallExpression extends CallOrNewBase {\n  type: \"OptionalCallExpression\";\n  optional: boolean;\n}\nexport interface BindExpression extends NodeBase {\n  type: \"BindExpression\";\n  object: Array<Expression | undefined | null>;\n  callee: Expression[];\n}\n\nexport interface ConditionalExpression extends NodeBase {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  alternate: Expression;\n  consequent: Expression;\n}\n\nexport interface CallOrNewBase extends NodeBase {\n  callee: Expression | Super | Import;\n  arguments: Array<Expression | SpreadElement>; // TODO: $ReadOnlyArray,\n  typeArguments: TypeParameterInstantiationBase | undefined | null;\n  typeParameters?: TypeParameterInstantiationBase | null; // TODO: Not in spec\n}\n\nexport interface CallExpression extends CallOrNewBase {\n  type: \"CallExpression\";\n}\n\nexport interface NewExpression extends CallOrNewBase {\n  type: \"NewExpression\";\n  optional?: boolean; // TODO: Not in spec\n}\n\nexport interface SequenceExpression extends NodeBase {\n  type: \"SequenceExpression\";\n  expressions: Expression[];\n}\n\nexport interface ParenthesizedExpression extends NodeBase {\n  type: \"ParenthesizedExpression\";\n  expression: Expression;\n}\n\n// Hack pipe operator\n\nexport interface TopicReference extends NodeBase {\n  type: \"TopicReference\";\n}\n\n// Smart-mix pipe operator\n\nexport interface PipelineBody extends NodeBase {\n  type: \"PipelineBody\";\n}\n\nexport interface PipelineBareFunctionBody extends NodeBase {\n  type: \"PipelineBareFunctionBody\";\n  callee: Expression;\n}\n\nexport interface PipelineBareConstructorBody extends NodeBase {\n  type: \"PipelineBareConstructorBody\";\n  callee: Expression;\n}\n\nexport interface PipelineBareAwaitedFunctionBody extends NodeBase {\n  type: \"PipelineBareAwaitedFunctionBody\";\n  callee: Expression;\n}\n\nexport interface PipelineTopicBody extends NodeBase {\n  type: \"PipelineTopicBody\";\n  expression: Expression;\n}\n\nexport type PipelineStyle =\n  | \"PipelineBareFunction\"\n  | \"PipelineBareConstructor\"\n  | \"PipelineBareAwaitedFunction\"\n  | \"PipelineTopicExpression\";\n\nexport interface PipelinePrimaryTopicReference extends NodeBase {\n  type: \"PipelinePrimaryTopicReference\";\n}\n\n// Template Literals\n\nexport interface TemplateLiteral extends NodeBase {\n  type: \"TemplateLiteral\";\n  quasis: TemplateElement[];\n  expressions: Expression[];\n}\n\nexport interface TaggedTemplateExpression extends NodeBase {\n  type: \"TaggedTemplateExpression\";\n  tag: Expression;\n  quasi: TemplateLiteral;\n  typeParameters?: TypeParameterInstantiationBase | null; // TODO: Not in spec\n}\n\nexport interface TemplateElement extends NodeBase {\n  type: \"TemplateElement\";\n  tail: boolean;\n  value: {\n    cooked: string;\n    raw: string;\n  };\n}\n\nexport interface ModuleExpression extends NodeBase {\n  type: \"ModuleExpression\";\n  body: Program;\n}\n\n// Patterns\n\n// TypeScript access modifiers\nexport type Accessibility = \"public\" | \"protected\" | \"private\";\n\nexport type VarianceAnnotations = \"in\" | \"out\";\n\nexport interface PatternBase extends HasDecorators {\n  // TODO: All not in spec\n  // Flow/TypeScript only:\n  typeAnnotation?: TypeAnnotationBase | null;\n}\n\nexport interface AssignmentProperty extends ObjectProperty {\n  value: Pattern;\n}\n\nexport interface ObjectPattern extends PatternBase {\n  type: \"ObjectPattern\";\n  properties: (AssignmentProperty | RestElement)[];\n}\n\nexport interface ArrayPattern extends PatternBase {\n  type: \"ArrayPattern\";\n  elements: (Pattern | undefined | null)[];\n}\n\nexport interface RestElement extends PatternBase {\n  type: \"RestElement\";\n  argument: Pattern;\n}\n\nexport interface AssignmentPattern extends PatternBase {\n  type: \"AssignmentPattern\";\n  left: Pattern;\n  right: Expression;\n}\n\n// Classes\n\nexport type Class = ClassDeclaration | ClassExpression;\n\nexport interface ClassBase extends HasDecorators {\n  id: Identifier | undefined | null;\n  superClass: Expression | undefined | null;\n  body: ClassBody;\n  decorators?: Decorator[];\n  // TODO: All not in spec\n  typeParameters?: TypeParameterDeclarationBase | null;\n  superTypeParameters?: TypeParameterInstantiationBase | null;\n  abstract?: boolean;\n  implements?:\n    | TsExpressionWithTypeArguments[]\n    | undefined\n    | null\n    | FlowClassImplements[];\n}\n\nexport interface ClassBody extends NodeBase {\n  type: \"ClassBody\";\n  body: Array<ClassMember | StaticBlock | TsIndexSignature>; // TODO: $ReadOnlyArray\n}\n// | Placeholder<\"ClassBody\">;\n\nexport interface ClassMemberBase extends NodeBase, HasDecorators {\n  static: boolean;\n  computed: boolean;\n  // TypeScript only:\n  accessibility?: Accessibility | null;\n  override?: true | null;\n  abstract?: true | null;\n  optional?: true | null;\n}\n\nexport interface StaticBlock extends NodeBase {\n  type: \"StaticBlock\";\n  body: Array<Statement>;\n}\n\nexport type ClassMember =\n  | ClassMethod\n  | ClassPrivateMethod\n  | ClassProperty\n  | ClassPrivateProperty\n  | ClassAccessorProperty;\n\nexport type MethodLike =\n  | ObjectMethod\n  | FunctionExpression\n  | ClassMethod\n  | ClassPrivateMethod\n  | TSDeclareMethod;\n\ninterface MethodBase extends FunctionBase {\n  kind: MethodKind;\n}\n\nexport type MethodKind = \"constructor\" | \"method\" | \"get\" | \"set\";\n\nexport interface ClassMethodOrDeclareMethodCommon extends ClassMemberBase {\n  key: Expression;\n  kind: MethodKind;\n  static: boolean;\n  decorators?: Decorator[];\n}\n\nexport interface ClassMethod\n  extends MethodBase,\n    ClassMethodOrDeclareMethodCommon {\n  type: \"ClassMethod\";\n  variance?: FlowVariance | null; // TODO: Not in spec\n}\n\nexport interface ClassPrivateMethod\n  extends NodeBase,\n    ClassMethodOrDeclareMethodCommon,\n    MethodBase {\n  type: \"ClassPrivateMethod\";\n  key: PrivateName;\n  computed: false;\n  variance?: FlowVariance | null; // TODO: Not in spec\n}\n\nexport interface ClassProperty extends ClassMemberBase, DeclarationBase {\n  type: \"ClassProperty\";\n  key: Expression;\n  value: Expression | undefined | null; // TODO: Not in spec that this is nullable.,\n  typeAnnotation?: TypeAnnotationBase | null; // TODO: Not in spec,\n  // Flow only:\n  variance?: FlowVariance | null; // TODO: Not in spec,\n  // TypeScript only: (TODO: Not in spec)\n  readonly?: true;\n  definite?: true;\n}\n\nexport interface ClassPrivateProperty extends NodeBase {\n  type: \"ClassPrivateProperty\";\n  key: PrivateName;\n  value: Expression | undefined | null; // TODO: Not in spec that this is nullable.,\n  static: boolean;\n  computed: false;\n  // Flow and Typescript\n  typeAnnotation?: TypeAnnotationBase | null;\n  // TypeScript only\n  optional?: true;\n  definite?: true;\n  readonly?: true;\n  override?: true;\n  // Flow only\n  variance?: FlowVariance | null;\n}\n\nexport interface ClassAccessorProperty\n  extends ClassMemberBase,\n    DeclarationBase {\n  type: \"ClassAccessorProperty\";\n  key: Expression | PrivateName;\n  value: Expression | undefined | null;\n  typeAnnotation?: TypeAnnotationBase | null; // TODO: Not in spec,\n  variance?: FlowVariance | null; // TODO: Not in spec,\n  // TypeScript only: (TODO: Not in spec)\n  readonly?: true;\n  definite?: true;\n}\n\nexport interface OptClassDeclaration\n  extends ClassBase,\n    DeclarationBase,\n    HasDecorators {\n  type: \"ClassDeclaration\";\n  // TypeScript only\n  abstract?: true | null;\n}\n\nexport interface ClassDeclaration extends OptClassDeclaration {\n  id: Identifier;\n}\n\nexport interface ClassExpression extends ClassBase {\n  type: \"ClassExpression\";\n}\n\nexport interface MetaProperty extends NodeBase {\n  type: \"MetaProperty\";\n  meta: Identifier;\n  property: Identifier;\n}\n\n// Modules\n\nexport type ModuleDeclaration = AnyImport | AnyExport;\n\nexport type AnyImport = ImportDeclaration | TsImportEqualsDeclaration;\n\nexport type AnyExport =\n  | ExportNamedDeclaration\n  | ExportDefaultDeclaration\n  | ExportAllDeclaration\n  | TsExportAssignment\n  | TsImportEqualsDeclaration\n  | TsNamespaceExportDeclaration;\n\ninterface ModuleSpecifier extends NodeBase {\n  local: Identifier;\n}\n\n// Imports\n\nexport interface ImportDeclaration extends NodeBase {\n  type: \"ImportDeclaration\";\n  // TODO: $ReadOnlyArray\n  specifiers: Array<\n    ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier\n  >;\n  source: Literal;\n  importKind?: \"type\" | \"typeof\" | \"value\"; // TODO: Not in spec,\n  assertions?: ImportAttribute[];\n}\n\nexport interface ImportSpecifier extends ModuleSpecifier {\n  type: \"ImportSpecifier\";\n  imported: Identifier | StringLiteral;\n  importKind?: \"type\" | \"value\";\n}\n\nexport interface ImportDefaultSpecifier extends ModuleSpecifier {\n  type: \"ImportDefaultSpecifier\";\n}\n\nexport interface ImportNamespaceSpecifier extends ModuleSpecifier {\n  type: \"ImportNamespaceSpecifier\";\n}\n\n// Exports\n\nexport interface ExportNamedDeclaration extends NodeBase {\n  type: \"ExportNamedDeclaration\";\n  declaration: Declaration | undefined | null;\n  specifiers: Array<ExportSpecifier | ExportDefaultSpecifier>;\n  source: Literal | undefined | null;\n  exportKind?: \"type\" | \"value\"; // TODO: Not in spec,\n  assertions?: ImportAttribute[];\n}\n\nexport interface ExportSpecifier extends NodeBase {\n  type: \"ExportSpecifier\";\n  exported: Identifier | StringLiteral;\n  local: Identifier;\n  exportKind?: \"type\" | \"value\";\n}\n\nexport interface ExportDefaultSpecifier extends NodeBase {\n  type: \"ExportDefaultSpecifier\";\n  exported: Identifier;\n}\n\nexport interface ExportDefaultDeclaration extends NodeBase {\n  type: \"ExportDefaultDeclaration\";\n  declaration:\n    | OptFunctionDeclaration\n    | OptTSDeclareFunction\n    | OptClassDeclaration\n    | Expression;\n}\n\nexport interface ExportAllDeclaration extends NodeBase {\n  type: \"ExportAllDeclaration\";\n  source: Literal;\n  exportKind?: \"type\" | \"value\"; // TODO: Not in spec,\n  assertions?: ImportAttribute[];\n}\n\nexport interface PipelineTopicExpression extends NodeBase {\n  type: \"PipelineTopicExpression\";\n  expression: Expression;\n}\n\nexport interface PipelineBareFunction extends NodeBase {\n  type: \"PipelineBareFunction\";\n  callee: Expression;\n}\n\n// JSX (TODO: Not in spec)\n\nexport type JSXIdentifier = Node;\nexport type JSXNamespacedName = Node;\nexport type JSXMemberExpression = Node;\nexport type JSXEmptyExpression = Node;\nexport type JSXSpreadChild = Node;\nexport type JSXExpressionContainer = Node;\nexport type JSXAttribute = Node;\nexport interface JSXOpeningElement extends NodeBase {\n  type: \"JSXOpeningElement\";\n  name: JSXNamespacedName | JSXMemberExpression;\n  typeParameters?: TypeParameterInstantiationBase | null; // TODO: Not in spec,\n  attributes: JSXAttribute[];\n  selfClosing: boolean;\n}\nexport type JSXClosingElement = Node;\nexport type JSXElement = Node;\nexport type JSXOpeningFragment = Node;\nexport type JSXClosingFragment = Node;\nexport type JSXFragment = Node;\n\n// Flow/TypeScript common (TODO: Not in spec)\n\nexport interface TypeAnnotationBase extends NodeBase {\n  typeAnnotation: Node;\n}\n\nexport interface TypeAnnotation extends NodeBase {\n  type: \"TypeAnnotation\";\n  typeAnnotation: FlowTypeAnnotation;\n}\n\nexport interface TsTypeAnnotation extends NodeBase {\n  type: \"TSTypeAnnotation\";\n  typeAnnotation: TsType;\n}\n\nexport interface TypeParameterDeclarationBase extends NodeBase {\n  params: Array<TypeParameter | TsTypeParameter>;\n}\n\nexport interface TypeParameterDeclaration extends TypeParameterDeclarationBase {\n  type: \"TypeParameterDeclaration\";\n  params: TypeParameter[];\n}\n\nexport interface TsTypeParameterDeclaration\n  extends TypeParameterDeclarationBase {\n  type: \"TSTypeParameterDeclaration\";\n  params: TsTypeParameter[];\n}\n\nexport interface TypeParameter extends NodeBase {\n  type: \"TypeParameter\";\n  name: string;\n  default?: TypeAnnotation;\n}\n\nexport interface TsTypeParameter extends NodeBase {\n  type: \"TSTypeParameter\";\n  // TODO(Babel-8): remove string type support\n  name: string | Identifier;\n  in?: boolean;\n  out?: boolean;\n  constraint?: TsType;\n  default?: TsType;\n}\n\nexport interface TypeParameterInstantiationBase extends NodeBase {\n  params: Node[];\n}\n\nexport interface TypeParameterInstantiation\n  extends TypeParameterInstantiationBase {\n  type: \"TypeParameterInstantiation\";\n  params: FlowType[];\n}\n\nexport interface TsTypeParameterInstantiation\n  extends TypeParameterInstantiationBase {\n  type: \"TSTypeParameterInstantiation\";\n  params: TsType[];\n}\n\n// Flow (TODO: Not in spec)\n\nexport interface TypeCastExpressionBase extends NodeBase {\n  expression: Expression;\n  typeAnnotation: TypeAnnotationBase;\n}\n\nexport interface TypeCastExpression extends NodeBase {\n  type: \"TypeCastExpression\";\n  expression: Expression;\n  typeAnnotation: TypeAnnotation;\n}\n\nexport interface TsTypeCastExpression extends NodeBase {\n  type: \"TSTypeCastExpression\";\n  expression: Expression;\n  typeAnnotation: TsTypeAnnotation;\n}\n\nexport type FlowType = Node;\nexport type FlowPredicate = Node;\nexport type FlowDeclare = Node;\nexport type FlowDeclareClass = Node;\nexport type FlowDeclareExportDeclaration = Node;\nexport type FlowDeclareFunction = Node;\nexport type FlowDeclareVariable = Node;\nexport type FlowDeclareModule = Node;\nexport type FlowDeclareModuleExports = Node;\nexport type FlowDeclareTypeAlias = Node;\nexport type FlowDeclareOpaqueType = Node;\nexport type FlowDeclareInterface = Node;\nexport type FlowInterface = Node;\nexport type FlowInterfaceExtends = Node;\nexport type FlowTypeAlias = Node;\nexport type FlowOpaqueType = Node;\nexport type FlowObjectTypeIndexer = Node;\nexport type FlowObjectTypeInternalSlot = Node;\nexport type FlowFunctionTypeAnnotation = Node;\nexport type FlowObjectTypeProperty = Node;\nexport type FlowObjectTypeSpreadProperty = Node;\nexport type FlowObjectTypeCallProperty = Node;\nexport type FlowObjectTypeAnnotation = Node;\nexport type FlowQualifiedTypeIdentifier = Node;\nexport type FlowGenericTypeAnnotation = Node;\nexport type FlowTypeofTypeAnnotation = Node;\nexport type FlowTupleTypeAnnotation = Node;\nexport type FlowFunctionTypeParam = Node;\nexport type FlowTypeAnnotation = Node;\nexport type FlowVariance = Node;\nexport type FlowClassImplements = Node;\n\nexport interface FlowInterfaceType extends NodeBase {\n  type: \"InterfaceTypeAnnotation\";\n  extends: FlowInterfaceExtends[];\n  body: FlowObjectTypeAnnotation;\n}\n\nexport interface FlowIndexedAccessType extends NodeBase {\n  type: \"IndexedAccessType\";\n  objectType: FlowType;\n  indexType: FlowType;\n}\n\nexport interface FlowOptionalIndexedAccessType extends NodeBase {\n  type: \"OptionalIndexedAccessType\";\n  objectType: FlowType;\n  indexType: FlowType;\n  optional: boolean;\n}\n\nexport interface StringLiteralTypeAnnotation extends NodeBase {\n  type: \"StringLiteralTypeAnnotation\";\n  value: string;\n}\n\nexport interface BooleanLiteralTypeAnnotation extends NodeBase {\n  type: \"BooleanLiteralTypeAnnotation\";\n  value: boolean;\n}\nexport interface NumberLiteralTypeAnnotation extends NodeBase {\n  type: \"NumberLiteralTypeAnnotation\";\n  value: number;\n}\n\nexport interface BigIntLiteralTypeAnnotation extends NodeBase {\n  type: \"BigIntLiteralTypeAnnotation\";\n  //todo(flow): use bigint when Flow supports BigInt\n  value: number;\n}\n\n// ESTree\nexport interface EstreeLiteral extends NodeBase {\n  type: \"Literal\";\n  value: any;\n}\n\ninterface EstreeRegExpLiteralRegex {\n  pattern: string;\n  flags: string;\n}\n\nexport interface EstreeRegExpLiteral extends EstreeLiteral {\n  regex: EstreeRegExpLiteralRegex;\n}\n\nexport interface EstreeBigIntLiteral extends EstreeLiteral {\n  value: number | null;\n  bigint: string;\n}\n\nexport interface EstreeProperty extends NodeBase {\n  type: \"Property\";\n  shorthand: boolean;\n  key: Expression;\n  computed: boolean;\n  value: Expression;\n  decorators: Decorator[];\n  kind?: \"get\" | \"set\" | \"init\";\n  variance?: FlowVariance | null;\n}\n\nexport interface EstreeMethodDefinition extends NodeBase {\n  type: \"MethodDefinition\";\n  static: boolean;\n  key: Expression;\n  computed: boolean;\n  value: Expression;\n  decorators: Decorator[];\n  kind?: \"get\" | \"set\" | \"method\";\n  variance?: FlowVariance | null;\n}\n\nexport interface EstreeImportExpression extends NodeBase {\n  type: \"ImportExpression\";\n  source: Expression;\n  attributes?: Expression | null;\n}\n\nexport interface EstreePrivateIdentifier extends NodeBase {\n  type: \"PrivateIdentifier\";\n  name: string;\n}\n\nexport interface EstreePropertyDefinition extends NodeBase {\n  type: \"PropertyDefinition\";\n  static: boolean;\n  key: Expression | EstreePrivateIdentifier;\n  computed: boolean;\n  value: Expression;\n}\n\n// === === === ===\n// TypeScript\n// === === === ===\n\n// Note: A type named `TsFoo` is based on TypeScript's `FooNode` type,\n// defined in https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts\n// Differences:\n// * Change `NodeArray<T>` to just `$T[]`.\n// * Don't give nodes a \"modifiers\" list; use boolean flags instead,\n//   and only allow modifiers that are not considered errors.\n// * A property named `type` must be renamed to `typeAnnotation` to avoid conflict with the node's type.\n// * Sometimes TypeScript allows to parse something which will be a grammar error later;\n//   in @babel/parser these cause exceptions, so the AST format is stricter.\n\n// ================\n// Misc\n// ================\n\nexport interface TSParameterProperty extends HasDecorators {\n  // Note: This has decorators instead of its parameter.\n  type: \"TSParameterProperty\";\n  // At least one of `accessibility` or `readonly` must be set.\n  accessibility?: Accessibility | null;\n  readonly?: true | null;\n  override?: true | null;\n  parameter: Identifier | AssignmentPattern;\n}\n\nexport interface OptTSDeclareFunction extends FunctionBase, DeclarationBase {\n  type: \"TSDeclareFunction\";\n}\n\nexport interface TSDeclareFunction extends OptTSDeclareFunction {\n  id: Identifier;\n}\n\nexport interface TSDeclareMethod\n  extends FunctionBase,\n    ClassMethodOrDeclareMethodCommon {\n  type: \"TSDeclareMethod\";\n  kind: MethodKind;\n}\n\nexport interface TsQualifiedName extends NodeBase {\n  type: \"TSQualifiedName\";\n  left: TsEntityName;\n  right: Identifier;\n}\n\nexport type TsEntityName = Identifier | TsQualifiedName;\n\nexport type TsSignatureDeclaration =\n  | TsCallSignatureDeclaration\n  | TsConstructSignatureDeclaration\n  | TsMethodSignature\n  | TsFunctionType\n  | TsConstructorType;\n\nexport interface TsSignatureDeclarationOrIndexSignatureBase extends NodeBase {\n  // Not using TypeScript's \"ParameterDeclaration\" here, since it's inconsistent with regular functions.\n  params: Array<Identifier | RestElement | ObjectPattern | ArrayPattern>;\n  returnType: TsTypeAnnotation | undefined | null;\n  // TODO(Babel-8): Remove\n  parameters: Array<Identifier | RestElement | ObjectPattern | ArrayPattern>;\n  typeAnnotation: TsTypeAnnotation | undefined | null;\n}\n\nexport interface TsSignatureDeclarationBase\n  extends TsSignatureDeclarationOrIndexSignatureBase {\n  typeParameters: TsTypeParameterDeclaration | undefined | null;\n}\n\n// ================\n// TypeScript type members (for type literal / interface / class)\n// ================\n\nexport type TsTypeElement =\n  | TsCallSignatureDeclaration\n  | TsConstructSignatureDeclaration\n  | TsPropertySignature\n  | TsMethodSignature\n  | TsIndexSignature;\n\nexport interface TsCallSignatureDeclaration extends TsSignatureDeclarationBase {\n  type: \"TSCallSignatureDeclaration\";\n}\n\nexport interface TsConstructSignatureDeclaration\n  extends TsSignatureDeclarationBase {\n  type: \"TSConstructSignatureDeclaration\";\n}\n\nexport interface TsNamedTypeElementBase extends NodeBase {\n  // Not using TypeScript's `PropertyName` here since we don't have a `ComputedPropertyName` node type.\n  // This is usually an Identifier but may be e.g. `Symbol.iterator` if `computed` is true.\n  key: Expression;\n  computed: boolean;\n  optional?: true;\n}\n\nexport interface TsPropertySignature extends TsNamedTypeElementBase {\n  type: \"TSPropertySignature\";\n  readonly?: true;\n  typeAnnotation?: TsTypeAnnotation;\n  initializer?: Expression;\n}\n\nexport interface TsMethodSignature\n  extends TsSignatureDeclarationBase,\n    TsNamedTypeElementBase {\n  type: \"TSMethodSignature\";\n  kind: \"method\" | \"get\" | \"set\";\n}\n\n// *Not* a ClassMemberBase: Can't have accessibility, can't be abstract, can't be optional.\nexport interface TsIndexSignature\n  extends TsSignatureDeclarationOrIndexSignatureBase {\n  readonly?: true;\n  static?: true;\n  type: \"TSIndexSignature\";\n  // Note: parameters.length must be 1.\n}\n\n// ================\n// TypeScript types\n// ================\n\nexport type TsType =\n  | TsKeywordType\n  | TsThisType\n  | TsFunctionOrConstructorType\n  | TsTypeReference\n  | TsTypeQuery\n  | TsTypeLiteral\n  | TsArrayType\n  | TsTupleType\n  | TsOptionalType\n  | TsRestType\n  | TsUnionOrIntersectionType\n  | TsConditionalType\n  | TsInferType\n  | TsParenthesizedType\n  | TsTypeOperator\n  | TsIndexedAccessType\n  | TsMappedType\n  | TsLiteralType // TODO: This probably shouldn't be included here.\n  | TsImportType\n  | TsTypePredicate;\n\nexport type TsTypeBase = NodeBase;\n\nexport type TsKeywordTypeType =\n  | \"TSAnyKeyword\"\n  | \"TSUnknownKeyword\"\n  | \"TSNumberKeyword\"\n  | \"TSObjectKeyword\"\n  | \"TSBooleanKeyword\"\n  | \"TSBigIntKeyword\"\n  | \"TSStringKeyword\"\n  | \"TSSymbolKeyword\"\n  | \"TSVoidKeyword\"\n  | \"TSUndefinedKeyword\"\n  | \"TSNullKeyword\"\n  | \"TSNeverKeyword\"\n  | \"TSIntrinsicKeyword\";\nexport interface TsKeywordType extends TsTypeBase {\n  type: TsKeywordTypeType;\n}\n\nexport interface TsThisType extends TsTypeBase {\n  type: \"TSThisType\";\n}\n\nexport type TsFunctionOrConstructorType = TsFunctionType | TsConstructorType;\n\nexport interface TsFunctionType extends TsTypeBase, TsSignatureDeclarationBase {\n  type: \"TSFunctionType\";\n  typeAnnotation: TsTypeAnnotation; // not optional\n}\n\nexport interface TsConstructorType\n  extends TsTypeBase,\n    TsSignatureDeclarationBase {\n  type: \"TSConstructorType\";\n  typeAnnotation: TsTypeAnnotation;\n  abstract: boolean;\n}\n\nexport interface TsTypeReference extends TsTypeBase {\n  type: \"TSTypeReference\";\n  typeName: TsEntityName;\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\nexport interface TsTypePredicate extends TsTypeBase {\n  type: \"TSTypePredicate\";\n  parameterName: Identifier | TsThisType;\n  typeAnnotation: TsTypeAnnotation | null;\n  asserts: boolean;\n}\n\n// `typeof` operator\nexport interface TsTypeQuery extends TsTypeBase {\n  type: \"TSTypeQuery\";\n  exprName: TsEntityName | TsImportType;\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\nexport interface TsTypeLiteral extends TsTypeBase {\n  type: \"TSTypeLiteral\";\n  members: TsTypeElement[];\n}\n\nexport interface TsArrayType extends TsTypeBase {\n  type: \"TSArrayType\";\n  elementType: TsType;\n}\n\nexport interface TsTupleType extends TsTypeBase {\n  type: \"TSTupleType\";\n  elementTypes: Array<TsType | TsNamedTupleMember>;\n}\n\nexport interface TsNamedTupleMember extends TsTypeBase {\n  type: \"TSNamedTupleMember\";\n  label: Identifier;\n  optional: boolean;\n  elementType: TsType;\n}\n\nexport interface TsOptionalType extends TsTypeBase {\n  type: \"TSOptionalType\";\n  typeAnnotation: TsType;\n}\n\nexport interface TsRestType extends TsTypeBase {\n  type: \"TSRestType\";\n  typeAnnotation: TsType | TsNamedTupleMember;\n}\n\nexport type TsUnionOrIntersectionType = TsUnionType | TsIntersectionType;\n\nexport interface TsUnionOrIntersectionTypeBase extends TsTypeBase {\n  types: TsType[];\n}\n\nexport interface TsUnionType extends TsUnionOrIntersectionTypeBase {\n  type: \"TSUnionType\";\n}\n\nexport interface TsIntersectionType extends TsUnionOrIntersectionTypeBase {\n  type: \"TSIntersectionType\";\n}\n\nexport interface TsConditionalType extends TsTypeBase {\n  type: \"TSConditionalType\";\n  checkType: TsType;\n  extendsType: TsType;\n  trueType: TsType;\n  falseType: TsType;\n}\n\nexport interface TsInferType extends TsTypeBase {\n  type: \"TSInferType\";\n  typeParameter: TsTypeParameter;\n}\n\nexport interface TsParenthesizedType extends TsTypeBase {\n  type: \"TSParenthesizedType\";\n  typeAnnotation: TsType;\n}\n\nexport interface TsTypeOperator extends TsTypeBase {\n  type: \"TSTypeOperator\";\n  operator: \"keyof\" | \"unique\" | \"readonly\";\n  typeAnnotation: TsType;\n}\n\nexport interface TsIndexedAccessType extends TsTypeBase {\n  type: \"TSIndexedAccessType\";\n  objectType: TsType;\n  indexType: TsType;\n}\n\nexport interface TsMappedType extends TsTypeBase {\n  type: \"TSMappedType\";\n  readonly?: true | \"+\" | \"-\";\n  typeParameter: TsTypeParameter;\n  optional?: true | \"+\" | \"-\";\n  typeAnnotation: TsType | undefined | null;\n  nameType: TsType | undefined | null;\n}\n\nexport interface TsLiteralType extends TsTypeBase {\n  type: \"TSLiteralType\";\n  literal: NumericLiteral | StringLiteral | BooleanLiteral | TemplateLiteral;\n}\n\nexport interface TsImportType extends TsTypeBase {\n  type: \"TSImportType\";\n  argument: StringLiteral;\n  qualifier?: TsEntityName;\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\n// ================\n// TypeScript declarations\n// ================\n\nexport interface TsInterfaceDeclaration extends DeclarationBase {\n  type: \"TSInterfaceDeclaration\";\n  id: Identifier | undefined | null;\n  typeParameters: TsTypeParameterDeclaration | undefined | null;\n  // TS uses \"heritageClauses\", but want this to resemble ClassBase.\n  extends?: TsExpressionWithTypeArguments[];\n  body: TSInterfaceBody;\n}\n\nexport interface TSInterfaceBody extends NodeBase {\n  type: \"TSInterfaceBody\";\n  body: TsTypeElement[];\n}\n\nexport interface TsExpressionWithTypeArguments extends TsTypeBase {\n  type: \"TSExpressionWithTypeArguments\";\n  expression: TsEntityName;\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\nexport interface TsTypeAliasDeclaration extends DeclarationBase {\n  type: \"TSTypeAliasDeclaration\";\n  id: Identifier;\n  typeParameters: TsTypeParameterDeclaration | undefined | null;\n  typeAnnotation: TsType;\n}\n\nexport interface TsEnumDeclaration extends DeclarationBase {\n  type: \"TSEnumDeclaration\";\n  const?: true;\n  id: Identifier;\n  members: TsEnumMember[];\n}\n\nexport interface TsEnumMember extends NodeBase {\n  type: \"TSEnumMember\";\n  id: Identifier | StringLiteral;\n  initializer?: Expression;\n}\n\nexport interface TsModuleDeclaration extends DeclarationBase {\n  type: \"TSModuleDeclaration\";\n  global?: true; // In TypeScript, this is only available through `node.flags`.,\n  id: TsModuleName;\n  body: TsNamespaceBody;\n}\n\n// `namespace A.B { }` is a namespace named `A` with another TsNamespaceDeclaration as its body.\nexport type TsNamespaceBody = TsModuleBlock | TsNamespaceDeclaration;\n\nexport interface TsModuleBlock extends NodeBase {\n  type: \"TSModuleBlock\";\n  body: Statement[];\n}\n\nexport interface TsNamespaceDeclaration extends TsModuleDeclaration {\n  id: Identifier;\n  body: TsNamespaceBody;\n}\n\nexport type TsModuleName = Identifier | StringLiteral;\n\nexport interface TsImportEqualsDeclaration extends NodeBase {\n  type: \"TSImportEqualsDeclaration\";\n  isExport: boolean;\n  id: Identifier;\n  importKind: \"type\" | \"value\";\n  moduleReference: TsModuleReference;\n}\n\nexport type TsModuleReference = TsEntityName | TsExternalModuleReference;\n\nexport interface TsExternalModuleReference extends NodeBase {\n  type: \"TSExternalModuleReference\";\n  expression: StringLiteral;\n}\n\n// TypeScript's own parser uses ExportAssignment for both `export default` and `export =`.\n// But for @babel/parser, `export default` is an ExportDefaultDeclaration,\n// so a TsExportAssignment is always `export =`.\nexport interface TsExportAssignment extends NodeBase {\n  type: \"TSExportAssignment\";\n  expression: Expression;\n}\n\nexport interface TsNamespaceExportDeclaration extends NodeBase {\n  type: \"TSNamespaceExportDeclaration\";\n  id: Identifier;\n}\n\n// ================\n// TypeScript expressions\n// ================\n\nexport interface TsTypeAssertionLikeBase extends NodeBase {\n  expression: Expression;\n  typeAnnotation: TsType;\n}\n\nexport interface TsAsExpression extends TsTypeAssertionLikeBase {\n  type: \"TSAsExpression\";\n}\n\nexport interface TsTypeAssertion extends TsTypeAssertionLikeBase {\n  type: \"TSTypeAssertion\";\n}\n\nexport interface TsNonNullExpression extends NodeBase {\n  type: \"TSNonNullExpression\";\n  expression: Expression;\n}\n\nexport interface TsInstantiationExpression extends NodeBase {\n  type: \"TSInstantiationExpression\";\n  expression: Expression;\n  typeParameters: TsTypeParameterInstantiation;\n}\n\n// ================\n// Babel placeholders %%foo%%\n// ================\n\nexport interface Placeholder<N extends PlaceholderTypes = PlaceholderTypes>\n  extends NodeBase {\n  type: \"Placeholder\";\n  id: Identifier;\n  expectedNode: N;\n}\n\n// ================\n// Other\n// ================\n\nexport interface ParseSubscriptState {\n  optionalChainMember: boolean;\n  maybeAsyncArrow: boolean;\n  stop: boolean;\n}\n\nexport interface ParseClassMemberState {\n  hadConstructor: boolean;\n  hadSuperClass: boolean;\n}\n"],"mappings":""}