{"version":3,"names":["kExpression","kMaybeArrowParameterDeclaration","kMaybeAsyncArrowParameterDeclaration","kParameterDeclaration","ExpressionScope","type","constructor","canBeArrowParameterDeclaration","isCertainlyParameterDeclaration","ArrowHeadParsingScope","declarationErrors","Map","recordDeclarationError","ParsingErrorClass","at","index","set","clearDeclarationError","delete","iterateErrors","iterator","forEach","ExpressionScopeHandler","parser","stack","enter","scope","push","exit","pop","recordParameterInitializerError","toParseError","node","origin","loc","start","i","length","raise","recordArrowParemeterBindingError","error","recordAsyncArrowParametersError","Errors","AwaitBindingIdentifier","validateAsPattern","currentScope","newParameterDeclarationScope","newArrowHeadScope","newAsyncArrowScope","newExpressionScope"],"sources":["../../src/util/expression-scope.ts"],"sourcesContent":["import { Errors, type ParseErrorConstructor } from \"../parse-error\";\nimport { Position } from \"./location\";\nimport type { Node } from \"../types\";\nimport Tokenizer from \"../tokenizer\";\n\n/**\n * @module util/expression-scope\n\nExpressionScope is used to track declaration errors in these ambiguous patterns:\n\n- CoverParenthesizedExpressionAndArrowParameterList\n  e.g. we don't know if `({ x })` is an parenthesized expression or an\n  arrow function parameters until we see an `=>` after `)`.\n\n- CoverCallExpressionAndAsyncArrowHead\n   e.g. we don't know if `async({ x })` is a call expression or an async arrow\n   function parameters until we see an `=>` after `)`\n\nThe following declaration errors (@see parser-errors/standard) will be recorded in\nsome expression scopes and thrown later when we know what the ambiguous pattern is\n\n- AwaitBindingIdentifier\n- AwaitExpressionFormalParameter\n- YieldInParameter\n- InvalidParenthesizedAssignment when parenthesized is an identifier\n\nThere are four different expression scope\n- Expression\n  A general scope that represents program / function body / static block. No errors\n  will be recorded nor thrown in this scope.\n\n- MaybeArrowParameterDeclaration\n  A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded\n  alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`\n  is called.\n\n- MaybeAsyncArrowParameterDeclaration\n  A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will\n  be recorded alongside parent scopes and thrown when\n  `ExpressionScopeHandler#validateAsPattern` is called.\n\n- ParameterDeclaration\n  A scope that represents unambiguous function parameters `function(x)`. Errors\n  recorded in this scope will be thrown immediately. No errors will be recorded in\n  this scope.\n\n// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}\n */\n\nconst kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3;\n\ntype ExpressionScopeType = 0 | 1 | 2 | 3;\n\nclass ExpressionScope {\n  type: ExpressionScopeType;\n\n  constructor(type: ExpressionScopeType = kExpression) {\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration(): this is ArrowHeadParsingScope {\n    return (\n      this.type === kMaybeAsyncArrowParameterDeclaration ||\n      this.type === kMaybeArrowParameterDeclaration\n    );\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n}\n\ntype ArrowHeadParsingParameterInitializerError =\n  | typeof Errors.AwaitExpressionFormalParameter\n  | typeof Errors.YieldInParameter;\ntype ArrowHeadParsingDeclarationError =\n  | ArrowHeadParsingParameterInitializerError\n  | typeof Errors.InvalidParenthesizedAssignment\n  | typeof Errors.AwaitBindingIdentifier;\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  declarationErrors: Map<number, [ParseErrorConstructor<{}>, Position]> =\n    new Map();\n  constructor(type: 1 | 2) {\n    super(type);\n  }\n  recordDeclarationError(\n    ParsingErrorClass: ParseErrorConstructor<{}>,\n    {\n      at,\n    }: {\n      at: Position;\n    },\n  ) {\n    const index = at.index;\n\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index: number) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(\n    iterator: (a: [ArrowHeadParsingDeclarationError, Position]) => void,\n  ) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\n\nexport default class ExpressionScopeHandler {\n  parser: Tokenizer;\n  stack: Array<ExpressionScope> = [new ExpressionScope()];\n\n  constructor(parser: Tokenizer) {\n    this.parser = parser;\n  }\n  enter(scope: ExpressionScope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  /**\n   * Record likely parameter initializer errors\n   *\n   * When current scope is a ParameterDeclaration, the error will be thrown immediately,\n   * otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and\n   * MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.\n   * @param {number} pos Error position\n   * @param {ErrorTemplate} template Error template\n   * @memberof ExpressionScopeHandler\n   */\n  recordParameterInitializerError(\n    toParseError: ArrowHeadParsingParameterInitializerError,\n    {\n      at: node,\n    }: {\n      at: Node;\n    },\n  ): void {\n    const origin = { at: node.loc.start };\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        /*:: invariant(scope.type == kExpression) */\n        // Type-Expression is the boundary where initializer error can populate to\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n\n  /**\n   * Record errors that must be thrown if the current pattern ends up being an arrow\n   * function parameter. This is used to record parenthesized identifiers, and to record\n   * \"a as T\" and \"<T> a\" type assertions when parsing typescript.\n   *\n   * A parenthesized identifier (or type assertion) in LHS can be ambiguous because the assignment\n   * can be transformed to an assignable later, but not vice versa:\n   * For example, in `([(a) = []] = []) => {}`, we think `(a) = []` is an LHS in `[(a) = []]`,\n   * an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,\n   * and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the\n   * location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration\n   * and MaybeAsyncArrowParameterDeclaration\n   *\n   * Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we\n   * validate arrow head parsing scope before exit, and then the LHS will be unambiguous:\n   * For example, in `( x = ( [(a) = []] = [] ) ) => {}`, we should not record `(a)` in `( x = ... ) =>`\n   * arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment\n   * expression and can not be cast to pattern\n   * @param {ParseErrorConstructor<{||}>} error\n   * @param {Node} payload.at\n   * @returns {void}\n   * @memberof ExpressionScopeHandler\n   */\n  recordArrowParemeterBindingError(\n    error: ParseErrorConstructor<{}>,\n    {\n      at: node,\n    }: {\n      at: Node;\n    },\n  ): void {\n    const { stack } = this;\n    const scope: ExpressionScope = stack[stack.length - 1];\n    const origin = { at: node.loc.start };\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Record likely async arrow parameter errors\n   *\n   * Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration\n   * scope until an Expression scope is seen.\n   * @param {number} pos\n   * @param {ErrorTemplate} template\n   * @memberof ExpressionScopeHandler\n   */\n  recordAsyncArrowParametersError({ at }: { at: Position }): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, { at });\n      }\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern(): void {\n    const { stack } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, { at: loc });\n      // iterate from parent scope\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\n\nexport function newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\n\nexport function newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\n\nexport function newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\n\nexport function newExpressionScope() {\n  return new ExpressionScope();\n}\n"],"mappings":"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"}