{"version":3,"names":["ExpressionParser","LValParser","checkProto","prop","isRecord","protoRef","refExpressionErrors","type","isObjectMethod","computed","shorthand","key","name","value","raise","Errors","RecordNoProto","at","used","doubleProtoLoc","loc","start","DuplicateProto","shouldExitDescending","expr","potentialArrowAt","getExpression","enterInitialScopes","nextToken","parseExpression","match","unexpected","finalizeRemainingComments","comments","state","errors","options","tokens","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","startPos","startLoc","parseMaybeAssign","node","startNodeAt","expressions","eat","push","toReferencedList","finishNode","parseMaybeAssignDisallowIn","afterLeftParse","parseMaybeAssignAllowIn","setOptionalParametersError","resultError","optionalParametersLoc","isContextual","prodParam","hasYield","left","parseYield","call","ownExpressionErrors","ExpressionErrors","tokenIsIdentifier","parseMaybeConditional","tokenIsAssignment","operator","toAssignable","index","shorthandAssignLoc","privateKeyLoc","checkDestructuringPrivate","next","right","checkLVal","in","checkExpressionErrors","parseExprOps","parseConditional","test","consequent","expect","alternate","parseMaybeUnaryOrPrivate","parsePrivateName","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","isPrivateName","getPrivateNameSV","tokenOperatorPrecedence","hasIn","PrivateInExpectedIn","identifierName","classScope","usePrivateName","op","tokenIsOperator","prec","expectPlugin","inFSharpPipelineDirectBody","checkPipelineAtInfixOperator","logical","coalesce","hasPlugin","proposal","hasAwait","UnexpectedAwaitAfterPipelineBody","parseExprOpRightExpr","finishedNode","nextOp","MixingCoalesceWithLogical","getPluginOption","withTopicBindingContext","parseHackPipeBody","PipeBodyIsTighter","parseSmartPipelineBodyInStyle","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","tokenIsRightAssociative","body","requiredParentheses","UnparenthesizedPipeBodyDescriptions","has","extra","parenthesized","PipeUnparenthesizedBody","topicReferenceWasUsedInCurrentContext","PipeTopicUnused","checkExponentialAfterUnary","UnexpectedTokenUnaryExponentiation","argument","sawUnary","isAwait","isAwaitAllowed","parseAwait","update","startNode","tokenIsPrefix","prefix","isDelete","strict","arg","StrictDelete","hasPropertyAsPrivateName","DeletePrivateField","parseUpdate","startsExpr","tokenCanStartExpression","isAmbiguousAwait","raiseOverwrite","AwaitNotInAsyncContext","updateExpressionNode","parseExprSubscripts","tokenIsPostfix","canInsertSemicolon","parseExprAtom","parseSubscripts","base","noCalls","optionalChainMember","maybeAsyncArrow","atPossibleAsyncArrow","stop","parseSubscript","parseBind","tokenIsTemplate","parseTaggedTemplateExpression","optional","lookaheadCharCode","parseCoverCallAndAsyncArrowHead","parseMember","object","property","SuperPrivateField","parseIdentifier","callee","parseNoCallExpr","oldMaybeInArrowParameters","maybeInArrowParameters","expressionScope","enter","newAsyncArrowScope","arguments","parseCallExpressionArguments","finishCallExpression","shouldParseAsyncArrow","validateAsPattern","exit","parseAsyncArrowFromCallExpression","toReferencedArguments","isParenthesizedExpr","toReferencedListDeep","tag","quasi","parseTemplate","OptionalChainingNoTemplate","lastTokEndLoc","end","length","process","env","BABEL_8_BREAKING","ImportCallArity","maxArgumentCount","ImportCallSpreadArgument","close","dynamicImport","allowPlaceholder","nodeForExtra","elts","first","oldInFSharpPipelineDirectBody","ImportCallArgumentTrailingComma","lastTokStartLoc","addTrailingCommaExtraToNode","parseExprListItem","resetPreviousNodeTrailingComments","parseArrowExpression","trailingCommaLoc","innerComments","setInnerComments","trailingComments","parseSuper","parseImportMetaProperty","UnsupportedImport","parseDo","readRegexp","parseRegExpLiteral","parseNumericLiteral","parseBigIntLiteral","parseDecimalLiteral","parseStringLiteral","parseNullLiteral","parseBooleanLiteral","canBeArrow","parseParenAndDistinguishExpression","parseArrayLike","parseObjectLike","parseFunctionOrFunctionSent","parseDecorators","takeDecorators","parseClass","parseNewOrNewTarget","UnsupportedBind","parseTopicReferenceThenEqualsSign","parseTopicReference","pipeProposal","lookaheadCh","input","codePointAt","nextTokenStart","isIdentifierStart","expectOnePlugin","hasFollowingLineBreak","parseModuleExpression","containsEsc","id","parseFunction","startNodeAtNode","undefined","parseAsyncArrowUnaryFunction","topicTokenType","topicTokenValue","pos","endLoc","createPositionWithColumnOffset","tokenType","finishTopicReference","testTopicReferenceConfiguration","nodeType","topicReferenceIsAllowedInCurrentContext","PrimaryTopicNotAllowed","PipeTopicUnbound","registerTopicReference","PipeTopicUnconfiguredToken","token","tokenLabelName","topicToken","PipeTopicRequiresHackPipes","functionFlags","params","hasPrecedingLineBreak","LineTerminatorBeforeArrow","curPosition","isAsync","async","oldLabels","labels","PARAM_AWAIT","parseBlock","scope","allowDirectSuper","allowSuperOutsideMethod","SuperNotAllowed","allowSuper","UnexpectedSuper","UnsupportedSuper","Position","curLine","lineStart","createIdentifier","meta","parseMetaProperty","propertyName","UnsupportedMetaProperty","target","onlyValidPropertyName","inModule","ImportMetaOutsideModule","sawUnambiguousESM","parseLiteralAtNode","addExtra","slice","parseLiteral","pattern","flags","val","newArrowHeadScope","innerStartPos","innerStartLoc","exprList","spreadStartLoc","optionalCommaStartLoc","spreadNodeStartPos","spreadNodeStartLoc","parseParenItem","parseRestBinding","checkCommaAfterRest","innerEndLoc","arrowNode","shouldParseArrow","parseArrow","resetEndLocation","wrapParenthesis","expression","createParenthesizedExpressions","takeSurroundingComments","parenExpression","metaProp","inNonArrowFunction","inClass","UnexpectedNewTarget","parseNew","parseNewCallee","args","parseExprList","ImportCallNotNewExpression","isOptionalChain","OptionalChainingNoNew","parseTemplateElement","isTagged","elemStart","elem","InvalidEscapeSequenceTemplate","isTail","endOffset","elemEnd","raw","replace","cooked","tail","curElt","quasis","parseTemplateSubstitution","readTemplateContinuation","isPattern","propHash","Object","create","properties","parseBindingProperty","parsePropertyDefinition","isObjectProperty","InvalidRecordProperty","lastTokStart","maybeAsyncOrAccessorProp","isLiteralPropertyName","decorators","UnsupportedPropertyDecorator","parseDecorator","isAccessor","parseSpread","method","isGenerator","parsePropertyNamePrefixOperator","parsePropertyName","keyName","kind","AccessorIsGenerator","parseObjPropValue","getGetterSetterExpectedParamCount","getObjectOrClassMethodParams","checkGetterSetterParams","paramCount","BadGetterArity","BadSetterArity","BadSetterRestParameter","parseObjectMethod","finishedProp","parseMethod","parseObjectProperty","parseMaybeDefault","checkReservedWord","cloneIdentifier","InvalidCoverInitializedName","tokenIsKeywordOrIdentifier","UnexpectedPrivateField","initFunction","generator","isConstructor","inClassScope","allowModifiers","SCOPE_FUNCTION","SCOPE_SUPER","SCOPE_CLASS","SCOPE_DIRECT_SUPER","parseFunctionParams","parseFunctionBodyAndFinish","canBePattern","isTuple","elements","SCOPE_ARROW","PARAM_IN","setArrowFunctionParameters","parseFunctionBody","toAssignableList","isMethod","allowExpression","isExpression","newExpressionScope","checkParams","oldStrict","currentFlags","PARAM_RETURN","hasStrictModeDirective","nonSimple","isSimpleParamList","IllegalLanguageModeDirective","strictModeChanged","checkIdentifier","BIND_OUTSIDE","isSimpleParameter","i","len","allowDuplicates","isArrowFunction","checkClashes","Set","formalParameters","param","binding","BIND_VAR","allowEmpty","elt","UnexpectedToken","UnexpectedArgumentPlaceholder","liberal","parseIdentifierName","tokenIsKeyword","tokenKeywordOrIdentifierIsKeyword","replaceToken","word","checkKeywords","isBinding","canBeReservedWord","YieldBindingIdentifier","AwaitBindingIdentifier","inStaticBlock","AwaitBindingIdentifierInStaticBlock","recordAsyncArrowParametersError","inClassAndNotInNonArrowFunction","ArgumentsInClass","isKeyword","UnexpectedKeyword","keyword","reservedTest","isReservedWord","isStrictBindReservedWord","isStrictReservedWord","UnexpectedReservedWord","reservedWord","allowAwaitOutsideFunction","inFunction","recordParameterInitializerError","AwaitExpressionFormalParameter","ObsoleteAwaitStar","ambiguousScriptDifferentAst","soloAwait","YieldInParameter","delegating","delegate","PipelineHeadSequenceExpression","childExpr","isSimpleReference","bodyNode","checkSmartPipeTopicBodyEarlyErrors","PipelineBodyNoArrow","PipelineTopicUnused","callback","outerContextTopicState","topicContext","maxNumOfResolvableTopics","maxTopicIndex","withSmartMixTopicForbiddingContext","outerContextSoloAwaitState","prodParamToSet","prodParamToClear","ret","revertScopes","initializeScopes","program","parseProgram"],"sources":["../../src/parser/expression.ts"],"sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  tokenCanStartExpression,\n  tokenIsAssignment,\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsOperator,\n  tokenIsPostfix,\n  tokenIsPrefix,\n  tokenIsRightAssociative,\n  tokenIsTemplate,\n  tokenKeywordOrIdentifierIsKeyword,\n  tokenLabelName,\n  tokenOperatorPrecedence,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types\";\nimport * as N from \"../types\";\nimport LValParser from \"./lval\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n  canBeReservedWord,\n} from \"../util/identifier\";\nimport { Position, createPositionWithColumnOffset } from \"../util/location\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_OUTSIDE,\n  BIND_VAR,\n  SCOPE_ARROW,\n  SCOPE_CLASS,\n  SCOPE_DIRECT_SUPER,\n  SCOPE_FUNCTION,\n  SCOPE_SUPER,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport {\n  PARAM_AWAIT,\n  PARAM_IN,\n  PARAM_RETURN,\n  functionFlags,\n} from \"../util/production-parameter\";\nimport type { ParamKind } from \"../util/production-parameter\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope\";\nimport { Errors, type ParseError } from \"../parse-error\";\nimport { UnparenthesizedPipeBodyDescriptions } from \"../parse-error/pipeline-operator-errors\";\nimport { setInnerComments } from \"./comments\";\nimport { cloneIdentifier, type Undone } from \"./node\";\nimport type Parser from \".\";\n\nimport type { SourceType } from \"../options\";\n\nexport default abstract class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  abstract parseBlock(\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement;\n  abstract parseClass(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ): N.Class;\n  abstract parseDecorators(allowExport?: boolean): void;\n  abstract parseFunction<T extends N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ): T;\n  abstract parseFunctionParams(\n    node: N.Function,\n    allowModifiers?: boolean,\n  ): void;\n  abstract takeDecorators(node: N.HasDecorators): void;\n  abstract parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: N.Directive[] | null | undefined,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void;\n  abstract parseProgram(\n    program: N.Program,\n    end: TokenType,\n    sourceType?: SourceType,\n  ): N.Program;\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: boolean | undefined | null,\n    protoRef: {\n      used: boolean;\n    },\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      // @ts-expect-error\n      prop.shorthand\n    ) {\n      return;\n    }\n\n    const key = prop.key;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, { at: key });\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, { at: key });\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {\n    return (\n      expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(this: Parser): N.Expression & N.ParserOutput {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    // Unlike parseTopLevel, we need to drain remaining commentStacks\n    // because the top level node is _not_ Program.\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    // @ts-expect-error fixme: refine types\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    this: Parser,\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // This method is only used by\n  // the typescript and flow plugins.\n  setOptionalParametersError(\n    refExpressionErrors: ExpressionErrors,\n    resultError?: ParseError<any>,\n  ) {\n    refExpressionErrors.optionalParametersLoc =\n      resultError?.loc ?? this.state.startLoc;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(tt._yield)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const { type } = this.state;\n\n    if (type === tt.parenL || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt<N.AssignmentExpression>(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        this.toAssignable(left, /* isLHS */ true);\n        node.left = left;\n\n        if (\n          refExpressionErrors.doubleProtoLoc != null &&\n          refExpressionErrors.doubleProtoLoc.index >= startPos\n        ) {\n          refExpressionErrors.doubleProtoLoc = null; // reset because double __proto__ is valid in assignment expression\n        }\n        if (\n          refExpressionErrors.shorthandAssignLoc != null &&\n          refExpressionErrors.shorthandAssignLoc.index >= startPos\n        ) {\n          refExpressionErrors.shorthandAssignLoc = null; // reset because shorthand default was used correctly\n        }\n        if (\n          refExpressionErrors.privateKeyLoc != null &&\n          refExpressionErrors.privateKeyLoc.index >= startPos\n        ) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null; // reset because `({ #x: x })` is an assignable pattern\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\"),\n      });\n      // @ts-expect-error todo(flow->ts) improve node types\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(\n    this: Parser,\n    expr: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression | N.PrivateName {\n    return this.match(tt.privateName)\n      ? this.parsePrivateName()\n      : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    this: Parser,\n    left: N.Expression | N.PrivateName,\n    leftStartPos: number,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    if (this.isPrivateName(left)) {\n      // https://tc39.es/ecma262/#prod-RelationalExpression\n      // RelationalExpression [In, Yield, Await]\n      //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n\n      const value = this.getPrivateNameSV(left);\n\n      if (\n        minPrec >= tokenOperatorPrecedence(tt._in) ||\n        !this.prodParam.hasIn ||\n        !this.match(tt._in)\n      ) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value,\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(tt._in))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt<N.LogicalExpression | N.BinaryExpression>(\n          leftStartPos,\n          leftStartLoc,\n        );\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = tokenOperatorPrecedence(tt.logicalAND);\n        }\n\n        this.next();\n\n        if (\n          op === tt.pipeline &&\n          this.hasPlugin([\"pipelineOperator\", { proposal: \"minimal\" }])\n        ) {\n          if (this.state.type === tt._await && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc,\n            });\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return this.parseExprOp(\n          finishedNode,\n          leftStartPos,\n          leftStartLoc,\n          minPrec,\n        );\n      }\n    }\n    return left;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(tt._yield)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc,\n                });\n              }\n              return this.parseSmartPipelineBodyInStyle(\n                this.parseExprOpBaseRightExpr(op, prec),\n                startPos,\n                startLoc,\n              );\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      // Falls through.\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startPos,\n      startLoc,\n      tokenIsRightAssociative(op) ? prec - 1 : prec,\n    );\n  }\n\n  parseHackPipeBody(this: Parser): N.Expression {\n    const { startLoc } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(\n      // @ts-expect-error TS2345: Argument of type 'string' is not assignable to parameter of type '\"ArrowFunctionExpression\" | \"YieldExpression\" | \"AssignmentExpression\" | \"ConditionalExpression\"'.\n      body.type,\n    );\n\n    // TODO: Check how to handle type casts in Flow and TS once they are supported\n    if (requiredParentheses && !body.extra?.parenthesized) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        // @ts-expect-error TS2322: Type 'string' is not assignable to type '\"AssignmentExpression\" | \"ArrowFunctionExpression\" | \"ConditionalExpression\" | \"YieldExpression\"'.\n        type: body.type,\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(Errors.PipeTopicUnused, { at: startLoc });\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(\n    node: N.AwaitExpression | Undone<N.UnaryExpression>,\n  ) {\n    if (this.match(tt.exponent)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument,\n      });\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(tt._await);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startPos, startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode<N.UnaryExpression | N.UpdateExpression>();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, { at: node });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, { at: node });\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node as Undone<N.UnaryExpression>);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(\n      // @ts-expect-error using \"Undone\" node as \"done\"\n      node,\n      update,\n      refExpressionErrors,\n    );\n\n    if (isAwait) {\n      const { type } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? tokenCanStartExpression(type)\n        : tokenCanStartExpression(type) && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, { at: startLoc });\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    this: Parser,\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (update) {\n      // @ts-expect-error Type 'Node' is missing the following properties from type 'Undone<UpdateExpression>': prefix, operator, argument\n      const updateExpressionNode = node as Undone<N.UpdateExpression>;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\"),\n      });\n      return node;\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt<N.UpdateExpression>(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: (expr = this.finishNode(node, \"UpdateExpression\")),\n      });\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(\n    this: Parser,\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls?: boolean | null,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    this: Parser,\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const { type } = this.state;\n    if (!noCalls && type === tt.doubleColon) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(\n        base,\n        startPos,\n        startLoc,\n        state,\n      );\n    }\n\n    let optional = false;\n\n    if (type === tt.questionDot) {\n      if (noCalls && this.lookaheadCharCode() === charCodes.leftParenthesis) {\n        // stop at `?.` when parsing `new a?.()`\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startPos,\n        startLoc,\n        state,\n        optional,\n      );\n    } else {\n      const computed = this.eat(tt.bracketL);\n      if (computed || optional || this.eat(tt.dot)) {\n        return this.parseMember(\n          base,\n          startPos,\n          startLoc,\n          state,\n          computed,\n          optional,\n        );\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    this: Parser,\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    computed: boolean,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt<\n      N.OptionalMemberExpression | N.MemberExpression\n    >(startPos, startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(tt.bracketR);\n    } else if (this.match(tt.privateName)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, { at: startLoc });\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      (node as N.OptionalMemberExpression).optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    this: Parser,\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    this.next(); // eat '::'\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startPos,\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    this: Parser,\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors: ExpressionErrors | null = null;\n\n    this.state.maybeInArrowParameters = true;\n    this.next(); // eat `(`\n\n    const node = this.startNodeAt<N.CallExpression | N.OptionalCallExpression>(\n      startPos,\n      startLoc,\n    );\n    node.callee = base;\n    const { maybeAsyncArrow, optionalChainMember } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      // @ts-expect-error when optionalChainMember is true, node must be an optional call\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        base.type === \"Import\",\n        base.type !== \"Super\",\n        // @ts-expect-error todo(flow->ts)\n        node,\n        refExpressionErrors,\n      );\n    }\n    let finishedNode:\n      | N.CallExpression\n      | N.OptionalCallExpression\n      | N.ArrowFunctionExpression = this.finishCallExpression(\n      node,\n      optionalChainMember,\n    );\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      /*:: invariant(refExpressionErrors != null) */\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt<N.ArrowFunctionExpression>(startPos, startLoc),\n        finishedNode as N.CallExpression,\n      );\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return finishedNode;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    this: Parser,\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node = this.startNodeAt<N.TaggedTemplateExpression>(\n      startPos,\n      startLoc,\n    );\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, { at: startLoc });\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEndLoc.index === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      base.start === this.state.potentialArrowAt\n    );\n  }\n\n  finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n    node: Undone<T>,\n    optional: boolean,\n  ): T {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (process.env.BABEL_8_BREAKING) {\n          this.expectPlugin(\"importAssertions\");\n        } else {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount:\n            this.hasPlugin(\"importAssertions\") ||\n            this.hasPlugin(\"moduleAttributes\")\n              ? 2\n              : 1,\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, { at: arg });\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    this: Parser,\n    close: TokenType,\n    dynamicImport?: boolean,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: N.Node | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): Array<N.Expression | undefined | null> {\n    const elts: N.Expression[] = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (\n            dynamicImport &&\n            !this.hasPlugin(\"importAssertions\") &&\n            !this.hasPlugin(\"moduleAttributes\")\n          ) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingCommaLoc,\n    );\n    // mark inner comments of `async()` as inner comments of `async () =>`\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    // mark trailing comments of `async` to be inner comments\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node as N.ArrowFunctionExpression;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(this: Parser): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    let node;\n\n    const { type } = this.state;\n    switch (type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode<N.MetaProperty | N.Import>();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node as Undone<N.MetaProperty>);\n        }\n\n        if (!this.match(tt.parenL)) {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc,\n          });\n        }\n        return this.finishNode(node, \"Import\");\n      case tt._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt._do: {\n        return this.parseDo(this.startNode(), false);\n      }\n\n      case tt.slash:\n      case tt.slashAssign: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n\n      case tt.num:\n        return this.parseNumericLiteral(this.state.value);\n\n      case tt.bigint:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case tt.decimal:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case tt.string:\n        return this.parseStringLiteral(this.state.value);\n\n      case tt._null:\n        return this.parseNullLiteral();\n\n      case tt._true:\n        return this.parseBooleanLiteral(true);\n      case tt._false:\n        return this.parseBooleanLiteral(false);\n\n      case tt.parenL: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        this.parseDecorators();\n      // fall through\n      case tt._class:\n        node = this.startNode<N.Class>();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.templateNonTail:\n      case tt.templateTail:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, { at: callee });\n        }\n      }\n\n      case tt.privateName: {\n        // Standalone private names are only allowed in \"#x in obj\"\n        // expressions, and they are directly handled by callers of\n        // parseExprOp. If we reach this, the input is always invalid.\n        // We can throw a better error message and recover, rather than\n        // just throwing \"Unexpected token\" (which is the default\n        // behavior of this big switch statement).\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: this.state.startLoc,\n          identifierName: this.state.value,\n        });\n        return this.parsePrivateName();\n      }\n\n      case tt.moduloAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.modulo, \"%\");\n      }\n\n      case tt.xorAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, \"^\");\n      }\n\n      case tt.doubleCaret:\n      case tt.doubleAt: {\n        return this.parseTopicReference(\"hack\");\n      }\n\n      case tt.bitwiseXOR:\n      case tt.modulo:\n      case tt.hash: {\n        const pipeProposal = this.getPluginOption(\n          \"pipelineOperator\",\n          \"proposal\",\n        );\n\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        } else {\n          throw this.unexpected();\n        }\n      }\n\n      case tt.lt: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (\n          isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n          lookaheadCh === charCodes.greaterThan // Fragment <>\n        ) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          break;\n        } else {\n          throw this.unexpected();\n        }\n      }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (\n            this.isContextual(tt._module) &&\n            this.lookaheadCharCode() === charCodes.leftCurlyBrace &&\n            !this.hasFollowingLineBreak()\n          ) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (\n            !containsEsc &&\n            id.name === \"async\" &&\n            !this.canInsertSemicolon()\n          ) {\n            const { type } = this.state;\n            if (type === tt._function) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(\n                this.startNodeAtNode(id),\n                undefined,\n                true,\n              );\n            } else if (tokenIsIdentifier(type)) {\n              // If the next token begins with \"=\", commit to parsing an async\n              // arrow function. (Peeking ahead for \"=\" lets us avoid a more\n              // expensive full-token lookahead on this common path.)\n              if (this.lookaheadCharCode() === charCodes.equalsTo) {\n                // although `id` is not used in async arrow unary function,\n                // we don't need to reset `async`'s trailing comments because\n                // it will be attached to the upcoming async arrow binding identifier\n                return this.parseAsyncArrowUnaryFunction(\n                  this.startNodeAtNode(id),\n                );\n              } else {\n                // Otherwise, treat \"async\" as an identifier and let calling code\n                // deal with the current tt.name token.\n                return id;\n              }\n            } else if (type === tt._do) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (\n            canBeArrow &&\n            this.match(tt.arrow) &&\n            !this.canInsertSemicolon()\n          ) {\n            this.next();\n            return this.parseArrowExpression(\n              this.startNodeAtNode(id),\n              [id],\n              false,\n            );\n          }\n\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n    }\n  }\n\n  // This helper method should only be called\n  // when the parser has reached a potential Hack pipe topic token\n  // that is followed by an equals sign.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  // If we find ^= or %= in an expression position\n  // (i.e., the tt.moduloAssign or tt.xorAssign token types), and if the\n  // Hack-pipes proposal is active with ^ or % as its topicToken, then the ^ or\n  // % could be the topic token (e.g., in x |> ^==y or x |> ^===y), and so we\n  // reparse the current token as ^ or %.\n  // Otherwise, this throws an unexpected-token error.\n  parseTopicReferenceThenEqualsSign(\n    topicTokenType: TokenType,\n    topicTokenValue: string,\n  ): N.Expression {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      // Set the most-recent token to be a topic token\n      // given by the tokenType and tokenValue.\n      // Now the next readToken() call (in parseTopicReference)\n      // will consume that “topic token”.\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      // Rewind the tokenizer to the end of the “topic token”, so that the\n      // following token starts at the equals sign after that topic token.\n      this.state.pos--;\n      this.state.end--;\n      // This is safe to do since the preceding character was either ^ or %, and\n      // thus not a newline.\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      // Now actually consume the topic token.\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  // This helper method should only be called\n  // when the proposal-pipeline-operator plugin is active,\n  // and when the parser has reached a potential Hack pipe topic token.\n  // Although a pipe-operator proposal is assumed to be active,\n  // its configuration might not match the current token’s type.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  parseTopicReference(pipeProposal: string): N.Expression {\n    const node = this.startNode<N.TopicReference>();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n\n    // Consume the current token.\n    this.next();\n\n    // If the pipe-operator plugin’s configuration matches the current token’s type,\n    // then this will return `node`, will have been finished as a topic reference.\n    // Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  // This helper method attempts to finish the given `node`\n  // into a topic-reference node for the given `pipeProposal`.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  //\n  // The method assumes that any topic token was consumed before it was called.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // and if the given `tokenType` matches the plugin’s configuration,\n  // then this method will return the finished `node`.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // but if the given `tokenType` does not match the plugin’s configuration,\n  // then this method will throw a `PipeTopicUnconfiguredToken` error.\n  finishTopicReference(\n    node: Undone<N.Node>,\n    startLoc: Position,\n    pipeProposal: string,\n    tokenType: TokenType,\n  ): N.Expression {\n    if (\n      this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)\n    ) {\n      // The token matches the plugin’s configuration.\n      // The token is therefore a topic reference.\n\n      // Determine the node type for the topic reference\n      // that is appropriate for the active pipe-operator proposal.\n      const nodeType =\n        pipeProposal === \"smart\"\n          ? \"PipelinePrimaryTopicReference\"\n          : // The proposal must otherwise be \"hack\",\n            // as enforced by testTopicReferenceConfiguration.\n            \"TopicReference\";\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(\n          // The topic reference is not allowed in the current context:\n          // it is outside of a pipe body.\n          // Raise recoverable errors.\n          pipeProposal === \"smart\"\n            ? Errors.PrimaryTopicNotAllowed\n            : // In this case, `pipeProposal === \"hack\"` is true.\n              Errors.PipeTopicUnbound,\n          { at: startLoc },\n        );\n      }\n\n      // Register the topic reference so that its pipe body knows\n      // that its topic was used at least once.\n      this.registerTopicReference();\n\n      return this.finishNode(node, nodeType);\n    } else {\n      // The token does not match the plugin’s configuration.\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType),\n      });\n    }\n  }\n\n  // This helper method tests whether the given token type\n  // matches the pipelineOperator parser plugin’s configuration.\n  // If the active pipe proposal is Hack style,\n  // and if the given token is the same as the plugin configuration’s `topicToken`,\n  // then this is a valid topic reference.\n  // If the active pipe proposal is smart mix,\n  // then the topic token must always be `#`.\n  // If the active pipe proposal is neither (e.g., \"minimal\" or \"fsharp\"),\n  // then an error is thrown.\n  testTopicReferenceConfiguration(\n    pipeProposal: string,\n    startLoc: Position,\n    tokenType: TokenType,\n  ): boolean {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\n          \"pipelineOperator\",\n          {\n            // @ts-expect-error token must have a label\n            topicToken: tokenLabelName(tokenType),\n          },\n        ]);\n      }\n      case \"smart\":\n        return tokenType === tt.hash;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, { at: startLoc });\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n  ): N.ArrowFunctionExpression {\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition(),\n      });\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  // https://github.com/tc39/proposal-async-do-expressions\n  parseDo(\n    this: Parser,\n    node: Undone<N.DoExpression>,\n    isAsync: boolean,\n  ): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      // AsyncDoExpression :\n      // async [no LineTerminator here] do Block[~Yield, +Await, ~Return]\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode<N.Super>();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.SuperNotAllowed, { at: node });\n    } else if (\n      !this.scope.allowSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.UnexpectedSuper, { at: node });\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(Errors.UnsupportedSuper, { at: node });\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName(): N.PrivateName {\n    const node = this.startNode<N.PrivateName>();\n    const id = this.startNodeAt<N.Identifier>(\n      this.state.start + 1,\n      // The position is hardcoded because we merge `#` and name into a single\n      // tt.privateName token\n      new Position(\n        this.state.curLine,\n        this.state.start + 1 - this.state.lineStart,\n        this.state.start + 1,\n      ),\n    );\n    const name = this.state.value;\n    this.next(); // eat #name;\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent(\n    this: Parser,\n  ): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode<N.FunctionExpression | N.MetaProperty>();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.match(tt._sent)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n      return this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"sent\",\n      );\n    }\n    return this.parseFunction(node as Undone<N.FunctionExpression>);\n  }\n\n  parseMetaProperty(\n    node: Undone<N.MetaProperty>,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName,\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(node: Undone<N.MetaProperty>): N.MetaProperty {\n    const id = this.createIdentifier(\n      this.startNodeAtNode<N.Identifier>(node),\n      \"import\",\n    );\n    this.next(); // eat `.`\n\n    if (this.isContextual(tt._meta)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, { at: id });\n      }\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteralAtNode<T extends N.Node>(\n    value: any,\n    type: T[\"type\"],\n    node: any,\n  ): T {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode<T>(node, type);\n  }\n\n  parseLiteral<T extends N.Node>(value: any, type: T[\"type\"]): T {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value: any) {\n    return this.parseLiteral<N.StringLiteral>(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value: any) {\n    return this.parseLiteral<N.NumericLiteral>(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value: any) {\n    return this.parseLiteral<N.BigIntLiteral>(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value: any) {\n    return this.parseLiteral<N.DecimalLiteral>(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value: {\n    value: any;\n    pattern: string;\n    flags: N.RegExpLiteral[\"flags\"];\n  }) {\n    const node = this.parseLiteral<N.RegExpLiteral>(\n      value.value,\n      \"RegExpLiteral\",\n    );\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value: boolean) {\n    const node = this.startNode<N.BooleanLiteral>();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode<N.NullLiteral>();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(\n    this: Parser,\n    canBeArrow: boolean,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList: N.Expression[] = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(\n          tt.comma,\n          refExpressionErrors.optionalParametersLoc === null\n            ? null\n            : refExpressionErrors.optionalParametersLoc,\n        );\n        if (this.match(tt.parenR)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(\n          this.parseParenItem(\n            this.parseRestBinding(),\n            spreadNodeStartPos,\n            spreadNodeStartLoc,\n          ),\n        );\n\n        if (!this.checkCommaAfterRest(charCodes.rightParenthesis)) {\n          break;\n        }\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n          ),\n        );\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt<N.ArrowFunctionExpression>(\n      startPos,\n      startLoc,\n    );\n    if (\n      canBeArrow &&\n      this.shouldParseArrow(exprList) &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      // @ts-expect-error todo(flow->ts) improve node types\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt<N.SequenceExpression>(\n        innerStartPos,\n        innerStartLoc,\n      );\n      val.expressions = exprList;\n      // finish node at current location so it can pick up comments after `)`\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(\n      startPos,\n      startLoc,\n      // @ts-expect-error todo(flow->ts)\n      val,\n    );\n  }\n\n  wrapParenthesis(\n    startPos: number,\n    startLoc: Position,\n    expression: N.Expression,\n  ): N.Expression {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startPos);\n\n      this.takeSurroundingComments(\n        expression,\n        startPos,\n        this.state.lastTokEndLoc.index,\n      );\n\n      return expression;\n    }\n\n    const parenExpression = this.startNodeAt<N.ParenthesizedExpression>(\n      startPos,\n      startLoc,\n    );\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- `params` is used in typescript plugin\n  shouldParseArrow(params: Array<N.Node>): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(\n    node: Undone<N.ArrowFunctionExpression>,\n  ): Undone<N.ArrowFunctionExpression> | undefined {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(\n    node: N.Expression,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startPos: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoc: Position,\n  ): N.Expression {\n    return node;\n  }\n\n  parseNewOrNewTarget(this: Parser): N.NewExpression | N.MetaProperty {\n    const node = this.startNode<N.NewExpression | N.MetaProperty>();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"new\",\n      );\n      this.next();\n      const metaProp = this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"target\",\n      );\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(Errors.UnexpectedNewTarget, { at: metaProp });\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node as Undone<N.NewExpression>);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(this: Parser, node: Undone<N.NewExpression>): N.NewExpression {\n    this.parseNewCallee(node);\n\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(this: Parser, node: Undone<N.NewExpression>): void {\n    node.callee = this.parseNoCallExpr();\n    if (node.callee.type === \"Import\") {\n      this.raise(Errors.ImportCallNotNewExpression, { at: node.callee });\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.lastTokEndLoc,\n      });\n    } else if (this.eat(tt.questionDot)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.startLoc,\n      });\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const { start, startLoc, end, value } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt<N.TemplateElement>(\n      elemStart,\n      createPositionWithColumnOffset(startLoc, 1),\n    );\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          // FIXME: explain\n          at: createPositionWithColumnOffset(startLoc, 2),\n        });\n      }\n    }\n\n    const isTail = this.match(tt.templateTail);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset),\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(\n      finishedNode,\n      createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),\n    );\n    return finishedNode;\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(this: Parser, isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode<N.TemplateLiteral>();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(this: Parser): N.Expression {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike(\n    close: TokenType,\n    isPattern: true,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectPattern;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: false | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectExpression;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: true,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.RecordExpression;\n  parseObjectLike<T extends N.ObjectPattern | N.ObjectExpression>(\n    this: Parser,\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash: any = Object.create(null);\n    let first = true;\n    const node = this.startNode<\n      N.ObjectExpression | N.ObjectPattern | N.RecordExpression\n    >();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(\n            // @ts-expect-error todo(flow->ts) improve node types\n            node,\n          );\n          break;\n        }\n      }\n\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(Errors.InvalidRecordProperty, { at: prop });\n      }\n\n      // @ts-expect-error\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      // @ts-expect-error Fixme: refine typings\n      node.properties.push(prop);\n    }\n\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    // @ts-expect-error type is well defined\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node: N.Node): void {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(prop: Undone<N.ObjectProperty>): boolean {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMember | N.SpreadElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode<N.ObjectProperty>();\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(tt.star);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName,\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n\n    return this.parseObjPropValue(\n      prop,\n      startPos,\n      startLoc,\n      isGenerator,\n      isAsync,\n      false /* isPattern */,\n      isAccessor,\n      refExpressionErrors,\n    );\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(\n        method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity,\n        { at: method },\n      );\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(Errors.BadSetterRestParameter, { at: method });\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    this: Parser,\n    prop: Undone<N.ObjectMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): N.ObjectMethod | undefined | null {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      const finishedProp = this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    this: Parser,\n    prop: Undone<N.ObjectProperty>,\n    startPos: number | undefined | null,\n    startLoc: Position | undefined | null,\n    isPattern: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectProperty | undefined | null {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoverInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startPos,\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else if (this.match(tt.eq)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc,\n          });\n        }\n        prop.value = this.parseMaybeDefault(\n          startPos,\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(\n    this: Parser,\n    prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n    startPos: number | undefined | null,\n    startLoc: Position | undefined | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMethod | N.ObjectProperty {\n    const node =\n      this.parseObjectMethod(\n        prop as Undone<N.ObjectMethod>,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) ||\n      this.parseObjectProperty(\n        prop as Undone<N.ObjectProperty>,\n        startPos,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      );\n\n    if (!node) this.unexpected();\n\n    return node;\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyName\n  // when refExpressionErrors presents, it will parse private name\n  // and record the position of the first private name\n  parsePropertyName(\n    this: Parser,\n    prop:\n      | Undone<N.ObjectOrClassMember | N.ClassMember>\n      | N.TsNamedTypeElementBase,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression | N.Identifier {\n    if (this.eat(tt.bracketL)) {\n      (prop as Undone<N.ObjectOrClassMember>).computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(tt.bracketR);\n    } else {\n      // We check if it's valid for it to be a private name when we push it.\n      const { type, value } = this.state;\n      let key;\n      // most un-computed property names are identifiers\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case tt.num:\n            key = this.parseNumericLiteral(value);\n            break;\n          case tt.string:\n            key = this.parseStringLiteral(value);\n            break;\n          case tt.bigint:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case tt.decimal:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case tt.privateName: {\n            // the class private key has been handled in parseClassElementName\n            const privateKeyLoc = this.state.startLoc;\n            if (refExpressionErrors != null) {\n              if (refExpressionErrors.privateKeyLoc === null) {\n                refExpressionErrors.privateKeyLoc = privateKeyLoc;\n              }\n            } else {\n              this.raise(Errors.UnexpectedPrivateField, {\n                at: privateKeyLoc,\n              });\n            }\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            throw this.unexpected();\n        }\n      }\n      (prop as any).key = key;\n      if (type !== tt.privateName) {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n    }\n\n    return prop.key;\n  }\n\n  // Initialize empty function node.\n\n  initFunction(\n    node: N.BodilessFunctionOrMethodBase,\n    isAsync?: boolean | null,\n  ): void {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  // Parse object or class method.\n\n  parseMethod<T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod>(\n    this: Parser,\n    node: Undone<T>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowDirectSuper: boolean,\n    type: T[\"type\"],\n    inClassScope: boolean = false,\n  ): T {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor; // For TypeScript parameter properties\n    this.scope.enter(\n      SCOPE_FUNCTION |\n        SCOPE_SUPER |\n        (inClassScope ? SCOPE_CLASS : 0) |\n        (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),\n    );\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n\n    return finishedNode;\n  }\n\n  // parse an array literal or tuple literal\n  // https://tc39.es/ecma262/#prod-ArrayLiteral\n  // https://tc39.es/proposal-record-tuple/#prod-TupleLiteral\n  parseArrayLike(\n    this: Parser,\n    close: TokenType,\n    canBePattern: boolean,\n    isTuple: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ArrayExpression | N.TupleExpression {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode<N.ArrayExpression | N.TupleExpression>();\n    this.next();\n    node.elements = this.parseExprList(\n      close,\n      /* allowEmpty */ !isTuple,\n      refExpressionErrors,\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(\n      node,\n      isTuple ? \"TupleExpression\" : \"ArrayExpression\",\n    );\n  }\n\n  // Parse arrow function expression.\n  // If the parameters are provided, they will be converted to an\n  // assignable list.\n  parseArrowExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    params: N.Expression[] | undefined | null,\n    isAsync: boolean,\n    trailingCommaLoc?: Position | null,\n  ): N.ArrowFunctionExpression {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n    // ConciseBody[In] :\n    //   [lookahead ≠ {] ExpressionBody[?In, ~Await]\n    //   { FunctionBody[~Yield, ~Await] }\n    if (!this.match(tt.braceL) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(\n    node: Undone<N.ArrowFunctionExpression>,\n    params: N.Expression[],\n    trailingCommaLoc?: Position | null,\n  ): void {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params as (N.Pattern | N.TSParameterProperty)[];\n  }\n\n  parseFunctionBodyAndFinish<\n    T extends\n      | N.Function\n      | N.TSDeclareMethod\n      | N.TSDeclareFunction\n      | N.ClassPrivateMethod,\n  >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n    // @ts-expect-error (node is not bodiless if we get here)\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n\n  // Parse function body and check parameters.\n  parseFunctionBody(\n    this: Parser,\n    node: Undone<N.Function>,\n    allowExpression?: boolean | null,\n    isMethod: boolean = false,\n  ): void {\n    const isExpression = allowExpression && !this.match(tt.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      // https://tc39.es/ecma262/#prod-ExpressionBody\n      (node as Undone<N.ArrowFunctionExpression>).body =\n        this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      // Start a new scope with regard to labels\n      // flag (restore them to their old value afterwards).\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      // FunctionBody[Yield, Await]:\n      //   StatementList[?Yield, ?Await, +Return] opt\n      this.prodParam.enter(\n        (this.prodParam.currentFlags() | PARAM_RETURN) as ParamKind,\n      );\n      node.body = this.parseBlock(\n        true,\n        false,\n        // Strict mode function checks after we parse the statements in the function body.\n        (hasStrictModeDirective: boolean) => {\n          const nonSimple = !this.isSimpleParamList(node.params);\n\n          if (hasStrictModeDirective && nonSimple) {\n            // This logic is here to align the error location with the ESTree plugin.\n            this.raise(Errors.IllegalLanguageModeDirective, {\n              at:\n                // @ts-expect-error\n                (node.kind === \"method\" || node.kind === \"constructor\") &&\n                // @ts-expect-error\n                !!node.key\n                  ? // @ts-expect-error node.key has been gaurded\n                    node.key.loc.end\n                  : node,\n            });\n          }\n\n          const strictModeChanged = !oldStrict && this.state.strict;\n\n          // Add the params to varDeclaredNames to ensure that an error is thrown\n          // if a let/const declaration in the function clashes with one of the params.\n          this.checkParams(\n            node,\n            !this.state.strict && !allowExpression && !isMethod && !nonSimple,\n            allowExpression,\n            strictModeChanged,\n          );\n\n          // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n          if (this.state.strict && node.id) {\n            this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);\n          }\n        },\n      );\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n\n  isSimpleParameter(node: N.Pattern | N.TSParameterProperty) {\n    return node.type === \"Identifier\";\n  }\n\n  isSimpleParamList(\n    params: ReadonlyArray<N.Pattern | N.TSParameterProperty>,\n  ): boolean {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n\n  checkParams(\n    node: Undone<N.Function>,\n    allowDuplicates: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isArrowFunction?: boolean | null,\n    strictModeChanged: boolean = true,\n  ): void {\n    const checkClashes = !allowDuplicates && new Set<string>();\n    // We create a fake node with the \"ephemeral\" type `FormalParameters`[1]\n    // since we just store an array of parameters. Perhaps someday we can have\n    // something like class FormalParameters extends Array { ... }, which would\n    // also be helpful when traversing this node.\n    //\n    // 1. https://tc39.es/ecma262/#prod-FormalParameters\n    const formalParameters = { type: \"FormalParameters\" } as const;\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BIND_VAR,\n        checkClashes,\n        strictModeChanged,\n      });\n    }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  parseExprList(\n    this: Parser,\n    close: TokenType,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    nodeForExtra?: N.Node | null,\n  ): (N.Expression | null)[] {\n    const elts: (N.Expression | null)[] = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: false,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null {\n    let elt;\n    if (this.match(tt.comma)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\",\n        });\n      }\n      elt = null;\n    } else if (this.match(tt.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n\n      elt = this.parseParenItem(\n        this.parseSpread(refExpressionErrors),\n        spreadNodeStartPos,\n        spreadNodeStartLoc,\n      );\n    } else if (this.match(tt.question)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc,\n        });\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(\n        refExpressionErrors,\n        this.parseParenItem,\n      );\n    }\n    return elt;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n  // This shouldn't be used to parse the keywords of meta properties, since they\n  // are not identifiers and cannot contain escape sequences.\n\n  parseIdentifier(liberal?: boolean): N.Identifier {\n    const node = this.startNode<N.Identifier>();\n    const name = this.parseIdentifierName(node.start, liberal);\n\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(\n    node: Omit<N.Identifier, \"type\">,\n    name: string,\n  ): N.Identifier {\n    node.name = name;\n    node.loc.identifierName = name;\n\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos: number, liberal?: boolean): string {\n    let name: string;\n\n    const { startLoc, type } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      // If the current token is not used as a keyword, set its type to \"tt.name\".\n      // This will prevent this.next() from throwing about unexpected escapes.\n      if (tokenIsKeyword) {\n        this.replaceToken(tt.name);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n\n    this.next();\n\n    return name;\n  }\n\n  checkReservedWord(\n    word: string,\n    startLoc: Position,\n    checkKeywords: boolean,\n    isBinding: boolean,\n  ): void {\n    // Every JavaScript reserved word is 10 characters or less.\n    if (word.length > 10) {\n      return;\n    }\n    // Most identifiers are not reservedWord-like, they don't need special\n    // treatments afterward, which very likely ends up throwing errors\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, { at: startLoc });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, { at: startLoc });\n        return;\n      }\n\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc,\n        });\n        return;\n      }\n\n      this.expressionScope.recordAsyncArrowParametersError({ at: startLoc });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, { at: startLoc });\n        return;\n      }\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word,\n      });\n      return;\n    }\n\n    const reservedTest = !this.state.strict\n      ? isReservedWord\n      : isBinding\n      ? isStrictBindReservedWord\n      : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word,\n      });\n    }\n  }\n\n  isAwaitAllowed(): boolean {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n\n  // Parses await expression inside async function.\n\n  parseAwait(\n    this: Parser,\n    startPos: number,\n    startLoc: Position,\n  ): N.AwaitExpression {\n    const node = this.startNodeAt<N.AwaitExpression>(startPos, startLoc);\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.AwaitExpressionFormalParameter,\n      {\n        // @ts-expect-error todo(flow->ts)\n        at: node,\n      },\n    );\n\n    if (this.eat(tt.star)) {\n      this.raise(Errors.ObsoleteAwaitStar, { at: node });\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait(): boolean {\n    if (this.hasPrecedingLineBreak()) return true;\n    const { type } = this.state;\n    return (\n      // All the following expressions are ambiguous:\n      //   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``\n      type === tt.plusMin ||\n      type === tt.parenL ||\n      type === tt.bracketL ||\n      tokenIsTemplate(type) ||\n      // Sometimes the tokenizer generates tt.slash for regexps, and this is\n      // handler by parseExprAtom\n      type === tt.regexp ||\n      type === tt.slash ||\n      // This code could be parsed both as a modulo operator or as an intrinsic:\n      //   await %x(0)\n      (this.hasPlugin(\"v8intrinsic\") && type === tt.modulo)\n    );\n  }\n\n  // Parses yield expression inside generator.\n\n  parseYield(this: Parser): N.YieldExpression {\n    const node = this.startNode<N.YieldExpression>();\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.YieldInParameter,\n      {\n        // @ts-expect-error todo(flow->ts)\n        at: node,\n      },\n    );\n\n    this.next();\n    let delegating = false;\n    let argument: N.Expression | null = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(tt.star);\n      switch (this.state.type) {\n        case tt.semi:\n        case tt.eof:\n        case tt.braceR:\n        case tt.parenR:\n        case tt.bracketR:\n        case tt.braceBarR:\n        case tt.colon:\n        case tt.comma:\n          // The above is the complete set of tokens that can\n          // follow an AssignmentExpression, and none of them\n          // can start an AssignmentExpression\n          if (!delegating) break;\n        /* fallthrough */\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\n  // of the infix operator `|>`.\n\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartLoc: Position) {\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      if (left.type === \"SequenceExpression\") {\n        // Ensure that the pipeline head is not a comma-delimited\n        // sequence expression.\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc,\n        });\n      }\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(\n    childExpr: N.Expression,\n    startPos: number,\n    startLoc: Position,\n  ) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt<N.PipelineBareFunction>(\n        startPos,\n        startLoc,\n      );\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt<N.PipelineTopicExpression>(\n        startPos,\n        startLoc,\n      );\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression: N.Expression): boolean {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return (\n          !expression.computed && this.isSimpleReference(expression.object)\n        );\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // This helper method is to be called immediately\n  // after a topic-style smart-mix pipe body is parsed.\n  // The `startLoc` is the starting position of the pipe body.\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc: Position): void {\n    // If the following token is invalidly `=>`, then throw a human-friendly error\n    // instead of something like 'Unexpected token, expected \";\"'.\n    // For example, `x => x |> y => #` (assuming `#` is the topic reference)\n    // groups into `x => (x |> y) => #`,\n    // and `(x |> y) => #` is an invalid arrow function.\n    // This is because smart-mix `|>` has tighter precedence than `=>`.\n    if (this.match(tt.arrow)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, { at: this.state.startLoc });\n    }\n\n    // A topic-style smart-mix pipe body must use the topic reference at least once.\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, { at: startLoc });\n    }\n  }\n\n  // Enable topic references from outer contexts within Hack-style pipe bodies.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references.\n  // The function then calls a callback, then resets the parser\n  // to the old topic-context state that it had before the function was called.\n\n  withTopicBindingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Enable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 1,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  // This helper method is used only with the deprecated smart-mix pipe proposal.\n  // Disables topic references from outer contexts within syntax constructs\n  // such as the bodies of iteration statements.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withSmartMixTopicForbiddingContext<T>(callback: () => T): T {\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      // Reset the parser’s topic context only if the smart-mix pipe proposal is active.\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        // Disable the use of the primary topic reference.\n        maxNumOfResolvableTopics: 0,\n        // Hide the use of any topic references from outer contexts.\n        maxTopicIndex: null,\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      // If the pipe proposal is \"minimal\", \"fsharp\", or \"hack\",\n      // or if no pipe proposal is active,\n      // then the callback result is returned\n      // without touching any extra parser state.\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext<T>(callback: () => T): T {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  disallowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  // Register the use of a topic reference within the current\n  // topic-binding context.\n  registerTopicReference(): void {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext(): boolean {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext(): boolean {\n    return (\n      this.state.topicContext.maxTopicIndex != null &&\n      this.state.topicContext.maxTopicIndex >= 0\n    );\n  }\n\n  parseFSharpPipelineBody(this: Parser, prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n\n    const ret = this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startPos,\n      startLoc,\n      prec,\n    );\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return ret;\n  }\n\n  // https://github.com/tc39/proposal-js-module-blocks\n  parseModuleExpression(this: Parser): N.ModuleExpression {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode<N.ModuleExpression>();\n    this.next(); // eat \"module\"\n    this.eat(tt.braceL);\n\n    const revertScopes = this.initializeScopes(/** inModule */ true);\n    this.enterInitialScopes();\n\n    const program = this.startNode<N.Program>();\n    try {\n      node.body = this.parseProgram(program, tt.braceR, \"module\");\n    } finally {\n      revertScopes();\n    }\n    this.eat(tt.braceR);\n    return this.finishNode<N.ModuleExpression>(node, \"ModuleExpression\");\n  }\n\n  // Used in Flow plugin\n  parsePropertyNamePrefixOperator(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prop: Undone<N.ObjectOrClassMember | N.ClassMember>,\n  ): void {}\n}\n"],"mappings":"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"}