{"version":3,"names":["UtilParser","Tokenizer","addExtra","node","key","value","enumerable","extra","Object","defineProperty","isContextual","token","state","type","containsEsc","isUnparsedContextual","nameStart","name","nameEnd","length","input","slice","nextCh","charCodeAt","isIdentifierChar","isLookaheadContextual","next","nextTokenStart","eatContextual","expectContextual","toParseError","raise","at","startLoc","unexpected","canInsertSemicolon","match","hasPrecedingLineBreak","lineBreak","test","lastTokEndLoc","index","start","hasFollowingLineBreak","skipWhiteSpaceToLineBreak","lastIndex","end","isLineTerminator","eat","semicolon","allowAsi","Errors","MissingSemicolon","expect","loc","tryParse","fn","oldState","clone","abortSignal","errors","failState","tokensLength","error","thrown","aborted","SyntaxError","checkExpressionErrors","refExpressionErrors","andThrow","shorthandAssignLoc","doubleProtoLoc","privateKeyLoc","optionalParametersLoc","hasErrors","InvalidCoverInitializedName","DuplicateProto","UnexpectedPrivateField","isLiteralPropertyName","tokenIsLiteralPropertyName","isPrivateName","getPrivateNameSV","id","hasPropertyAsPrivateName","property","isOptionalChain","isObjectProperty","isObjectMethod","initializeScopes","inModule","options","sourceType","oldLabels","labels","oldExportedIdentifiers","exportedIdentifiers","Set","oldInModule","oldScope","scope","ScopeHandler","getScopeHandler","oldProdParam","prodParam","ProductionParameterHandler","oldClassScope","classScope","ClassScopeHandler","oldExpressionScope","expressionScope","ExpressionScopeHandler","enterInitialScopes","paramFlags","PARAM","PARAM_AWAIT","enter","SCOPE_PROGRAM","checkDestructuringPrivate","expectPlugin","ExpressionErrors"],"sources":["../../src/parser/util.ts"],"sourcesContent":["import { type Position } from \"../util/location\";\nimport {\n  tokenIsLiteralPropertyName,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types\";\nimport Tokenizer from \"../tokenizer\";\nimport State from \"../tokenizer/state\";\nimport type { EstreePropertyDefinition, Node, ObjectProperty } from \"../types\";\nimport { lineBreak, skipWhiteSpaceToLineBreak } from \"../util/whitespace\";\nimport { isIdentifierChar } from \"../util/identifier\";\nimport ClassScopeHandler from \"../util/class-scope\";\nimport ExpressionScopeHandler from \"../util/expression-scope\";\nimport { SCOPE_PROGRAM } from \"../util/scopeflags\";\nimport ProductionParameterHandler, {\n  PARAM_AWAIT,\n  PARAM,\n} from \"../util/production-parameter\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n} from \"../parse-error\";\nimport type Parser from \".\";\n\nimport type ScopeHandler from \"../util/scope\";\n\ntype TryParse<Node, Error, Thrown, Aborted, FailState> = {\n  node: Node;\n  error: Error;\n  thrown: Thrown;\n  aborted: Aborted;\n  failState: FailState;\n};\n\n// ## Parser utilities\n\nexport default abstract class UtilParser extends Tokenizer {\n  // Forward-declaration: defined in parser/index.js\n  abstract getScopeHandler(): { new (...args: any): ScopeHandler };\n\n  // TODO\n\n  addExtra(\n    node: Partial<Node>,\n    key: string,\n    value: any,\n    enumerable: boolean = true,\n  ): void {\n    if (!node) return;\n\n    const extra = (node.extra = node.extra || {});\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, { enumerable, value });\n    }\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  isContextual(token: TokenType): boolean {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart: number, name: string): boolean {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(\n        isIdentifierChar(nextCh) ||\n        // check if `nextCh is between 0xd800 - 0xdbff,\n        // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function\n        // returns true\n        (nextCh & 0xfc00) === 0xd800\n      );\n    }\n    return false;\n  }\n\n  isLookaheadContextual(name: string): boolean {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  // Consumes contextual keyword if possible.\n\n  eatContextual(token: TokenType): boolean {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  expectContextual(\n    token: TokenType,\n    toParseError?: ParseErrorConstructor<any>,\n  ): void {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, { at: this.state.startLoc });\n      }\n      throw this.unexpected(null, token);\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  canInsertSemicolon(): boolean {\n    return (\n      this.match(tt.eof) ||\n      this.match(tt.braceR) ||\n      this.hasPrecedingLineBreak()\n    );\n  }\n\n  hasPrecedingLineBreak(): boolean {\n    return lineBreak.test(\n      this.input.slice(this.state.lastTokEndLoc.index, this.state.start),\n    );\n  }\n\n  hasFollowingLineBreak(): boolean {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  // TODO\n\n  isLineTerminator(): boolean {\n    return this.eat(tt.semi) || this.canInsertSemicolon();\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  semicolon(allowAsi: boolean = true): void {\n    if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;\n    this.raise(Errors.MissingSemicolon, { at: this.state.lastTokEndLoc });\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n  expect(type: TokenType, loc?: Position | null): void {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n\n  // tryParse will clone parser state.\n  // It is expensive and should be used with cautions\n  tryParse<T extends Node | ReadonlyArray<Node>>(\n    fn: (abort: (node?: T) => never) => T,\n    oldState: State = this.state.clone(),\n  ):\n    | TryParse<T, null, false, false, null>\n    | TryParse<T | null, ParseError<any>, boolean, false, State>\n    | TryParse<T | null, null, false, true, State> {\n    const abortSignal: {\n      node: T | null;\n    } = { node: null };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        // tokensLength should be preserved during error recovery mode\n        // since the parser does not halt and will instead parse the\n        // remaining tokens\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length] as ParseError<any>,\n          thrown: false,\n          aborted: false,\n          failState,\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null,\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        // @ts-expect-error casting general syntax error to parse error\n        return { node: null, error, thrown: true, aborted: false, failState };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState,\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(\n    refExpressionErrors: ExpressionErrors | undefined | null,\n    andThrow: boolean,\n  ) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n    } = refExpressionErrors;\n\n    const hasErrors =\n      !!shorthandAssignLoc ||\n      !!doubleProtoLoc ||\n      !!optionalParametersLoc ||\n      !!privateKeyLoc;\n\n    if (!andThrow) {\n      return hasErrors;\n    }\n\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc,\n      });\n    }\n\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, { at: doubleProtoLoc });\n    }\n\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, { at: privateKeyLoc });\n    }\n\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  /**\n   * Test if current token is a literal property name\n   * https://tc39.es/ecma262/#prod-LiteralPropertyName\n   * LiteralPropertyName:\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   *   BigIntLiteral\n   */\n  isLiteralPropertyName(): boolean {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  /*\n   * Test if given node is a PrivateName\n   * will be overridden in ESTree plugin\n   */\n  isPrivateName(node: Node): boolean {\n    return node.type === \"PrivateName\";\n  }\n\n  /*\n   * Return the string value of a given private name\n   * WITHOUT `#`\n   * @see {@link https://tc39.es/ecma262/#sec-static-semantics-stringvalue}\n   */\n  getPrivateNameSV(node: Node): string {\n    return node.id.name;\n  }\n\n  /*\n   * Return whether the given node is a member/optional chain that\n   * contains a private name as its property\n   * It is overridden in ESTree plugin\n   */\n  hasPropertyAsPrivateName(node: Node): boolean {\n    return (\n      (node.type === \"MemberExpression\" ||\n        node.type === \"OptionalMemberExpression\") &&\n      this.isPrivateName(node.property)\n    );\n  }\n\n  isOptionalChain(node: Node): boolean {\n    return (\n      node.type === \"OptionalMemberExpression\" ||\n      node.type === \"OptionalCallExpression\"\n    );\n  }\n\n  isObjectProperty(\n    node: Node,\n  ): node is ObjectProperty | EstreePropertyDefinition {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node: Node): boolean {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(\n    this: Parser,\n    inModule: boolean = this.options.sourceType === \"module\",\n  ): () => void {\n    // Initialize state\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n\n    // initialize scopes\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n\n    return () => {\n      // Revert state\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n\n      // Revert scopes\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n  checkDestructuringPrivate(refExpressionErrors: ExpressionErrors) {\n    const { privateKeyLoc } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\n\n/**\n * The ExpressionErrors is a context struct used to track ambiguous patterns\n * When we are sure the parsed pattern is a RHS, which means it is not a pattern,\n * we will throw on this position on invalid assign syntax, otherwise it will be reset to -1\n *\n * Types of ExpressionErrors:\n *\n * - **shorthandAssignLoc**: track initializer `=` position\n * - **doubleProtoLoc**: track the duplicate `__proto__` key position\n * - **privateKey**: track private key `#p` position\n * - **optionalParametersLoc**: track the optional paramter (`?`).\n * It's only used by typescript and flow plugins\n */\nexport class ExpressionErrors {\n  shorthandAssignLoc: Position | undefined | null = null;\n  doubleProtoLoc: Position | undefined | null = null;\n  privateKeyLoc: Position | undefined | null = null;\n  optionalParametersLoc: Position | undefined | null = null;\n}\n"],"mappings":"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"}