{"version":3,"names":["Node","constructor","parser","pos","loc","start","end","SourceLocation","options","ranges","range","filename","type","NodePrototype","prototype","process","env","BABEL_8_BREAKING","__clone","newNode","keys","Object","i","length","key","clonePlaceholder","node","cloneIdentifier","extra","name","cloned","create","expectedNode","cloneStringLiteral","raw","undefined","value","NodeUtils","UtilParser","startNode","state","startLoc","startNodeAt","startNodeAtNode","finishNode","finishNodeAt","lastTokEndLoc","endLoc","NODE_ENV","Error","index","attachComment","processComment","resetStartLocation","resetEndLocation","resetStartLocationFromNode","locationNode"],"sources":["../../src/parser/node.ts"],"sourcesContent":["import type Parser from \"./index\";\nimport UtilParser from \"./util\";\nimport { SourceLocation, type Position } from \"../util/location\";\nimport type { Comment, Node as NodeType, NodeBase } from \"../types\";\n\n// Start an AST node, attaching a start offset.\n\nclass Node implements NodeBase {\n  constructor(parser: Parser, pos: number, loc: Position) {\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser?.options.ranges) this.range = [pos, 0];\n    if (parser?.filename) this.loc.filename = parser.filename;\n  }\n\n  type: string = \"\";\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n  declare range: [number, number];\n  declare leadingComments: Array<Comment>;\n  declare trailingComments: Array<Comment>;\n  declare innerComments: Array<Comment>;\n  declare extra: {\n    [key: string]: any;\n  };\n}\nconst NodePrototype = Node.prototype;\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error\n  NodePrototype.__clone = function (): Node {\n    // @ts-expect-error\n    const newNode: any = new Node();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // Do not clone comments that are already attached to the node\n      if (\n        key !== \"leadingComments\" &&\n        key !== \"trailingComments\" &&\n        key !== \"innerComments\"\n      ) {\n        newNode[key] =\n          // @ts-expect-error: key must present in this\n          this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node: any): any {\n  return cloneIdentifier(node);\n}\n\nexport function cloneIdentifier(node: any): any {\n  // We don't need to clone `typeAnnotations` and `optional`: because\n  // cloneIdentifier is only used in object shorthand and named import/export.\n  // Neither of them allow type annotations after the identifier or optional identifier\n  const { type, start, end, loc, range, extra, name } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\n\nexport function cloneStringLiteral(node: any): any {\n  const { type, start, end, loc, range, extra } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    // estree set node.raw instead of node.extra\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\n\nexport type Undone<T extends NodeType> = Omit<T, \"type\">;\n\nexport abstract class NodeUtils extends UtilParser {\n  startNode<T extends NodeType>(): Undone<T> {\n    // @ts-expect-error\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt<T extends NodeType>(pos: number, loc: Position): Undone<T> {\n    // @ts-expect-error\n    return new Node(this, pos, loc);\n  }\n\n  /** Start a new node with a previous node's location. */\n  startNodeAtNode<T extends NodeType>(type: Undone<NodeType>): Undone<T> {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  finishNode<T extends NodeType>(node: Undone<T>, type: T[\"type\"]): T {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n\n  // Finish node at given position\n\n  finishNodeAt<T extends NodeType>(\n    node: Omit<T, \"type\">,\n    type: T[\"type\"],\n    endLoc: Position,\n  ): T {\n    if (process.env.NODE_ENV !== \"production\" && node.end > 0) {\n      throw new Error(\n        \"Do not call finishNode*() twice on the same node.\" +\n          \" Instead use resetEndLocation() or change type directly.\",\n      );\n    }\n    // @ts-expect-error migrate to Babel types AST typings\n    node.type = type;\n    // @ts-expect-error migrate to Babel types AST typings\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node as T);\n    return node as T;\n  }\n\n  resetStartLocation(node: NodeBase, start: number, startLoc: Position): void {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(\n    node: NodeBase,\n    endLoc: Position = this.state.lastTokEndLoc,\n  ): void {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n\n  /**\n   * Reset the start location of node to the start location of locationNode\n   */\n  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n}\n"],"mappings":"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"}