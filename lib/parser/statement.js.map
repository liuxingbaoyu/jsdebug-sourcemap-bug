{"version":3,"names":["loopLabel","kind","switchLabel","FUNC_NO_FLAGS","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","loneSurrogate","keywordRelationalOperator","babel7CompatTokens","tokens","input","i","length","token","type","process","env","BABEL_8_BREAKING","loc","start","value","end","hashEndPos","hashEndLoc","createPositionWithColumnOffset","splice","Token","getExportedToken","startLoc","endLoc","tokenIsTemplate","backquoteEnd","backquoteEndLoc","startToken","charCodeAt","templateValue","templateElementEnd","templateElementEndLoc","endToken","slice","StatementParser","ExpressionParser","parseTopLevel","file","program","parseProgram","comments","state","options","finishNode","sourceType","interpreter","parseInterpreterDirective","parseBlockBody","inModule","allowUndeclaredExports","scope","undefinedExports","size","localName","at","Array","from","raise","Errors","ModuleExportUndefined","stmtToDirective","stmt","directive","expression","directiveLiteral","expressionValue","raw","val","addExtra","match","node","startNode","next","isLet","context","isContextual","isLetKeyword","nextTokenStart","nextCh","codePointAtPos","isIdentifierStart","lastIndex","test","endCh","isIdentifierChar","parseStatement","topLevel","parseDecorators","parseStatementContent","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","lookaheadCharCode","strict","StrictFunction","SloppyFunction","parseFunctionStatement","unexpected","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","UnexpectedLexicalDeclaration","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","nextTokenCharCode","allowImportExportEverywhere","UnexpectedImportExport","result","parseImport","importKind","sawUnambiguousESM","parseExport","exportKind","assertModuleNodeAllowed","isAsyncFunction","AsyncFunctionInSingleStatementContext","maybeName","expr","parseExpression","tokenIsIdentifier","eat","parseLabeledStatement","parseExpressionStatement","ImportOutsideModule","takeDecorators","decorators","decoratorStack","resetStartLocationFromNode","canHaveLeadingDecorator","allowExport","currentContextDecorators","decorator","parseDecorator","push","hasPlugin","getPluginOption","DecoratorExportClass","UnexpectedLeadingDecorator","expectOnePlugin","startPos","expect","wrapParenthesis","parseIdentifier","startNodeAt","object","property","computed","parseMaybeDecoratorArguments","pop","parseExprSubscripts","startNodeAtNode","callee","arguments","parseCallExpressionArguments","toReferencedList","isBreak","isLineTerminator","label","semicolon","verifyBreakContinue","labels","lab","name","IllegalBreakContinue","parseHeaderExpression","body","withSmartMixTopicForbiddingContext","awaitAt","isAwaitAllowed","eatContextual","lastTokStartLoc","enter","SCOPE_OTHER","parseFor","startsWithLet","initNode","parseVar","init","declarations","parseForIn","startsWithAsync","refExpressionErrors","ExpressionErrors","isForOf","ForOfLet","ForOfAsync","checkDestructuringPrivate","toAssignable","checkLVal","in","checkExpressionErrors","isAsync","declarationPosition","parseFunction","consequent","alternate","prodParam","hasReturn","allowReturnOutsideFunction","IllegalReturn","argument","discriminant","cases","cur","sawDefault","isCase","MultipleDefaultsInSwitch","exit","hasPrecedingLineBreak","NewlineAfterThrow","lastTokEndLoc","parseCatchClauseParam","param","parseBindingAtom","simple","SCOPE_SIMPLE_CATCH","binding","BIND_LEXICAL","allowingSloppyLetBinding","block","handler","clause","finalizer","NoCatchOrFinally","allowMissingInitializer","StrictWith","LabelRedeclaration","labelName","tokenIsLoop","statementStart","indexOf","allowDirectives","createNewLexicalScope","afterBlockParse","strictErrors","clear","isValidDirective","extra","parenthesized","directives","parseBlockOrModuleBlockBody","undefined","oldStrict","hasStrictModeDirective","parsedNonDirective","setStrict","call","update","isForIn","await","id","ForInOfLoopInitializer","InvalidLhs","ancestor","left","right","parseMaybeAssignAllowIn","isFor","decl","parseVarId","parseMaybeAssignDisallowIn","DeclarationMissingInitializer","BIND_VAR","statement","isStatement","isHangingStatement","requireId","initFunction","GeneratorInSingleStatementContext","generator","parseFunctionId","oldMaybeInArrowParameters","maybeInArrowParameters","SCOPE_FUNCTION","functionFlags","parseFunctionParams","parseFunctionBodyAndFinish","registerFunctionStatementId","allowModifiers","expressionScope","newParameterDeclarationScope","params","parseBindingList","declareName","async","treatFunctionsAsVar","BIND_FUNCTION","optionalId","parseClassId","parseClassSuper","parseClassBody","superClass","isClassProperty","isClassMethod","isNonstaticConstructor","method","static","key","hadSuperClass","classScope","hadConstructor","classBody","DecoratorSemicolon","member","parseClassMember","DecoratorConstructor","TrailingDecorator","parseClassMemberFromModifier","pushClassMethod","prop","parseClassProperty","resetPreviousNodeTrailingComments","isStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","publicMethod","privateMethod","publicProp","privateProp","accessorProp","publicMember","parsePropertyNamePrefixOperator","isPrivateName","parseClassElementName","pushClassPrivateMethod","ConstructorIsGenerator","containsEsc","isPrivate","maybeQuestionTokenStartLoc","parsePostMemberNameModifiers","isConstructor","allowsDirectSuper","DuplicateConstructor","override","OverrideOnConstructor","pushClassPrivateProperty","pushClassProperty","isGenerator","optional","ConstructorIsAsync","ConstructorIsAccessor","checkGetterSetterParams","expectPlugin","pushClassAccessorProperty","StaticPrototype","ConstructorClassPrivateField","parsePrivateName","parsePropertyName","SCOPE_CLASS","SCOPE_STATIC_BLOCK","SCOPE_SUPER","oldLabels","PARAM","DecoratorStaticBlock","ConstructorClassField","parseClassPrivateProperty","declarePrivateName","getPrivateNameSV","CLASS_ELEMENT_OTHER","parseClassAccessorProperty","parseMethod","CLASS_ELEMENT_STATIC_GETTER","CLASS_ELEMENT_INSTANCE_GETTER","CLASS_ELEMENT_STATIC_SETTER","CLASS_ELEMENT_INSTANCE_SETTER","declareClassPrivateMethodInScope","methodOrProp","parseInitializer","newExpressionScope","bindingType","BIND_CLASS","declareNameFromIdentifier","MissingClassName","hasDefault","maybeParseExportDefaultSpecifier","parseAfterDefault","hasStar","eatExportStar","hasNamespace","maybeParseExportNamespaceSpecifier","parseAfterNamespace","isFromRequired","parseExportFrom","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","checkExport","source","declaration","parseExportDefaultExpression","isExportDefaultSpecifier","specifier","exported","specifiers","lastTokStart","parseModuleExportName","isTypeExport","parseExportSpecifiers","assertions","shouldParseExportDeclaration","parseExportDeclaration","lineBreak","pos","isUnparsedContextual","DecoratorBeforeExport","UnsupportedDefaultExport","res","nextType","lookahead","hasFrom","nextAfterFrom","nextTokenStartSince","parseImportSource","maybeParseImportAssertions","checkJSONModuleImport","checkNames","isDefault","isFrom","checkDuplicateExports","ExportDefaultFromAsIdentifier","exportName","local","ExportBindingIsString","checkReservedWord","checkLocalExport","Error","checkDeclaration","UnsupportedDecoratorExport","properties","elem","elements","exportedIdentifiers","has","DuplicateDefaultExport","DuplicateExport","add","isInTypeExport","nodes","first","isMaybeTypeOnly","isString","parseExportSpecifier","cloneStringLiteral","cloneIdentifier","parseStringLiteral","surrogate","ModuleExportNameHasLoneSurrogate","surrogateCharCode","isJSONModuleImport","some","nonDefaultNamedSpecifier","find","imported","ImportJSONBindingNotDefault","maybeParseDefaultImportSpecifier","parseNext","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","expectContextual","attributes","maybeParseModuleAttributes","parseExprAtom","shouldParseDefaultImport","parseImportSpecifierLocal","finishImportSpecifier","parseAssertEntries","attrs","attrNames","Set","keyName","ModuleAttributesWithDuplicateKeys","ModuleAttributeInvalidValue","ModuleAttributeDifferentFromType","DestructureNamedImport","importedIsString","importSpecifier","parseImportSpecifier","isInTypeOnlyImport","ImportBindingIsString","importName","isThisParam"],"sources":["../../src/parser/statement.ts"],"sourcesContent":["import * as N from \"../types\";\nimport {\n  tokenIsIdentifier,\n  tokenIsLoop,\n  tokenIsTemplate,\n  tt,\n  type TokenType,\n  getExportedToken,\n} from \"../tokenizer/types\";\nimport ExpressionParser from \"./expression\";\nimport { Errors } from \"../parse-error\";\nimport { isIdentifierChar, isIdentifierStart } from \"../util/identifier\";\nimport { lineBreak } from \"../util/whitespace\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_CLASS,\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  SCOPE_CLASS,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n  SCOPE_SIMPLE_CATCH,\n  SCOPE_STATIC_BLOCK,\n  SCOPE_SUPER,\n  CLASS_ELEMENT_OTHER,\n  CLASS_ELEMENT_INSTANCE_GETTER,\n  CLASS_ELEMENT_INSTANCE_SETTER,\n  CLASS_ELEMENT_STATIC_GETTER,\n  CLASS_ELEMENT_STATIC_SETTER,\n  type BindingTypes,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { PARAM, functionFlags } from \"../util/production-parameter\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope\";\nimport type { SourceType } from \"../options\";\nimport { Token } from \"../tokenizer\";\nimport { Position, createPositionWithColumnOffset } from \"../util/location\";\nimport { cloneStringLiteral, cloneIdentifier, type Undone } from \"./node\";\nimport type Parser from \"./index\";\n\nconst loopLabel = { kind: \"loop\" } as const,\n  switchLabel = { kind: \"switch\" } as const;\n\nconst FUNC_NO_FLAGS = 0b000,\n  FUNC_STATEMENT = 0b001,\n  FUNC_HANGING_STATEMENT = 0b010,\n  FUNC_NULLABLE_ID = 0b100;\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\n/**\n * Convert tokens for backward Babel 7 compat.\n * tt.privateName => tt.hash + tt.name\n * tt.templateTail => tt.backquote/tt.braceR + tt.template + tt.backquote\n * tt.templateNonTail => tt.backquote/tt.braceR + tt.template + tt.dollarBraceL\n * For performance reasons this routine mutates `tokens`, it is okay\n * here since we execute `parseTopLevel` once for every file.\n * @param {*} tokens\n * @returns\n */\nfunction babel7CompatTokens(tokens: (Token | N.Comment)[], input: string) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const { type } = token;\n    if (typeof type === \"number\") {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (type === tt.privateName) {\n          const { loc, start, value, end } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(\n            i,\n            1,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.hash),\n              value: \"#\",\n              start: start,\n              end: hashEndPos,\n              startLoc: loc.start,\n              endLoc: hashEndLoc,\n            }),\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.name),\n              value: value,\n              start: hashEndPos,\n              end: end,\n              startLoc: hashEndLoc,\n              endLoc: loc.end,\n            }),\n          );\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const { loc, start, value, end } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === charCodes.graveAccent) {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          } else {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.braceR),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          }\n          let templateValue,\n            templateElementEnd,\n            templateElementEndLoc,\n            endToken;\n          if (type === tt.templateTail) {\n            // ends with '`'\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          } else {\n            // ends with `${`\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.dollarBraceL),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          }\n          tokens.splice(\n            i,\n            1,\n            startToken,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.template),\n              value: templateValue,\n              start: backquoteEnd,\n              end: templateElementEnd,\n              startLoc: backquoteEndLoc,\n              endLoc: templateElementEndLoc,\n            }),\n            endToken,\n          );\n          i += 2;\n          continue;\n        }\n      }\n      // @ts-expect-error: we manipulate `token` for performance reasons\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nexport default abstract class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(this: Parser, file: N.File, program: N.Program): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    this: Parser,\n    program: Undone<N.Program>,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (\n      this.inModule &&\n      !this.options.allowUndeclaredExports &&\n      this.scope.undefinedExports.size > 0\n    ) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, { at, localName });\n      }\n    }\n    return this.finishNode(program, \"Program\");\n  }\n\n  // TODO\n\n  /**\n   * cast a Statement to a Directive. This method mutates input statement.\n   *\n   * @param {N.Statement} stmt\n   * @returns {N.Directive}\n   * @memberof StatementParser\n   */\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const directive = stmt as any;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n\n    directiveLiteral.type = \"DirectiveLiteral\";\n\n    return directive;\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode<N.InterpreterDirective>();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context?: string | null): boolean {\n    if (!this.isContextual(tt._let)) {\n      return false;\n    }\n    return this.isLetKeyword(context);\n  }\n\n  /**\n   * Assuming we have seen a contextual `let`, check if it starts a variable declaration\n   so that `left` should be interpreted as a `let` keyword.\n   *\n   * @param {?string} context When `context` is non nullish, it will return early and _skip_ checking\n                              if the next token after `let` is `{` or a keyword relational operator\n   * @returns {boolean}\n   * @memberof StatementParser\n   */\n  isLetKeyword(context?: string | null): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    // Also, `let \\` is never valid as an expression so this must be a keyword.\n    if (\n      nextCh === charCodes.backslash ||\n      nextCh === charCodes.leftSquareBracket\n    ) {\n      return true;\n    }\n    if (context) return false;\n\n    if (nextCh === charCodes.leftCurlyBrace) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n      if (keywordRelationalOperator.test(this.input)) {\n        // We have seen `in` or `instanceof` so far, now check if the identfier\n        // ends here\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== charCodes.backslash) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatement(\n    this: Parser,\n    context?: string | null,\n    topLevel?: boolean,\n  ): N.Statement {\n    if (this.match(tt.at)) {\n      this.parseDecorators(true);\n    }\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(\n    this: Parser,\n    context?: string | null,\n    topLevel?: boolean | null,\n  ): N.Statement {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = tt._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case tt._break:\n        return this.parseBreakContinueStatement(node, /* isBreak */ true);\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, /* isBreak */ false);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node as Undone<N.DebuggerStatement>);\n      case tt._do:\n        return this.parseDoStatement(node as Undone<N.DoWhileStatement>);\n      case tt._for:\n        return this.parseForStatement(node as Undone<N.ForStatement>);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (context) {\n          if (this.state.strict) {\n            this.raise(Errors.StrictFunction, { at: this.state.startLoc });\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(Errors.SloppyFunction, { at: this.state.startLoc });\n          }\n        }\n        return this.parseFunctionStatement(\n          node as Undone<N.FunctionDeclaration>,\n          false,\n          !context,\n        );\n\n      case tt._class:\n        if (context) this.unexpected();\n        return this.parseClass(node as Undone<N.ClassDeclaration>, true);\n\n      case tt._if:\n        return this.parseIfStatement(node as Undone<N.IfStatement>);\n      case tt._return:\n        return this.parseReturnStatement(node as Undone<N.ReturnStatement>);\n      case tt._switch:\n        return this.parseSwitchStatement(node as Undone<N.SwitchStatement>);\n      case tt._throw:\n        return this.parseThrowStatement(node as Undone<N.ThrowStatement>);\n      case tt._try:\n        return this.parseTryStatement(node as Undone<N.TryStatement>);\n\n      case tt._const:\n      case tt._var:\n        kind = kind || this.state.value;\n        if (context && kind !== \"var\") {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          kind,\n        );\n\n      case tt._while:\n        return this.parseWhileStatement(node as Undone<N.WhileStatement>);\n      case tt._with:\n        return this.parseWithStatement(node as Undone<N.WithStatement>);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node as Undone<N.EmptyStatement>);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(Errors.UnexpectedImportExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (starttype === tt._import) {\n          result = this.parseImport(node as Undone<N.ImportDeclaration>);\n\n          if (\n            result.type === \"ImportDeclaration\" &&\n            (!result.importKind || result.importKind === \"value\")\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(\n            node as Undone<\n              | N.ExportAllDeclaration\n              | N.ExportDefaultDeclaration\n              | N.ExportDefaultDeclaration\n            >,\n          );\n\n          if (\n            (result.type === \"ExportNamedDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            (result.type === \"ExportAllDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            result.type === \"ExportDefaultDeclaration\"\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        }\n\n        this.assertModuleNodeAllowed(result);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (context) {\n            this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n              at: this.state.startLoc,\n            });\n          }\n          this.next();\n          return this.parseFunctionStatement(\n            node as Undone<N.FunctionDeclaration>,\n            true,\n            !context,\n          );\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      tokenIsIdentifier(starttype) &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(\n        node as Undone<N.LabeledStatement>,\n        maybeName,\n        // @ts-expect-error migrate to Babel types\n        expr,\n        context,\n      );\n    } else {\n      return this.parseExpressionStatement(\n        node as Undone<N.ExpressionStatement>,\n        expr,\n      );\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, { at: node });\n    }\n  }\n\n  takeDecorators(node: N.HasDecorators): void {\n    const decorators =\n      this.state.decoratorStack[this.state.decoratorStack.length - 1];\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(this: Parser, allowExport?: boolean): void {\n    const currentContextDecorators =\n      this.state.decoratorStack[this.state.decoratorStack.length - 1];\n    while (this.match(tt.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (\n        this.hasPlugin(\"decorators\") &&\n        !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\n      ) {\n        this.raise(Errors.DecoratorExportClass, { at: this.state.startLoc });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc,\n      });\n    }\n  }\n\n  parseDecorator(this: Parser): N.Decorator {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n    const node = this.startNode<N.Decorator>();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      // Every time a decorator class expression is evaluated, a new empty array is pushed onto the stack\n      // So that the decorators of any nested class expressions will be dealt with separately\n      this.state.decoratorStack.push([]);\n\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.match(tt.parenL)) {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        this.next(); // eat '('\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n        expr = this.wrapParenthesis(startPos, startLoc, expr);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(this: Parser, expr: N.Expression): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: true,\n  ): N.BreakStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: false,\n  ): N.ContinueStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ): N.BreakStatement | N.ContinueStatement {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, { at: node, type });\n    }\n  }\n\n  parseDebuggerStatement(\n    node: Undone<N.DebuggerStatement>,\n  ): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(this: Parser): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  parseDoStatement(\n    this: Parser,\n    node: Undone<N.DoWhileStatement>,\n  ): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body's body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(\"do\"),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(\n    this: Parser,\n    node: Undone<N.ForStatement | N.ForInOf>,\n  ): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = null;\n\n    if (this.isAwaitAllowed() && this.eatContextual(tt._await)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, null);\n    }\n\n    const startsWithLet = this.isContextual(tt._let);\n    const isLet = startsWithLet && this.isLetKeyword();\n    if (this.match(tt._var) || this.match(tt._const) || isLet) {\n      const initNode = this.startNode<N.VariableDeclaration>();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(initNode, true, kind);\n      const init = this.finishNode(initNode, \"VariableDeclaration\");\n\n      if (\n        (this.match(tt._in) || this.isContextual(tt._of)) &&\n        init.declarations.length === 1\n      ) {\n        return this.parseForIn(node as Undone<N.ForInOf>, init, awaitAt);\n      }\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, init);\n    }\n\n    // Check whether the first token is possibly a contextual keyword, so that\n    // we can forbid `for (async of` if this turns out to be a for-of loop.\n    const startsWithAsync = this.isContextual(tt._async);\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(tt._of);\n    if (isForOf) {\n      // Check for leading tokens that are forbidden in for-of loops:\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, { at: init });\n      }\n\n      if (\n        // `for await (async of []);` is allowed.\n        awaitAt === null &&\n        startsWithAsync &&\n        init.type === \"Identifier\"\n      ) {\n        // This catches the case where the `async` in `for (async of` was\n        // parsed as an identifier. If it was parsed as the start of an async\n        // arrow function (e.g. `for (async of => {} of []);`), the LVal check\n        // further down will raise a more appropriate error.\n        this.raise(Errors.ForOfAsync, { at: init });\n      }\n    }\n    if (isForOf || this.match(tt._in)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, /* isLHS */ true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, { in: { type } });\n      return this.parseForIn(\n        node as Undone<N.ForInStatement | N.ForOfStatement>,\n        // @ts-expect-error init has been transformed to an assignable\n        init,\n        awaitAt,\n      );\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node as Undone<N.ForStatement>, init);\n  }\n\n  parseFunctionStatement(\n    this: Parser,\n    node: Undone<N.FunctionDeclaration>,\n    isAsync?: boolean,\n    declarationPosition?: boolean,\n  ): N.FunctionDeclaration {\n    this.next();\n    return this.parseFunction(\n      node,\n      FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT),\n      isAsync,\n    );\n  }\n\n  parseIfStatement(this: Parser, node: Undone<N.IfStatement>) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(tt._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(this: Parser, node: Undone<N.ReturnStatement>) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, { at: this.state.startLoc });\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(this: Parser, node: Undone<N.SwitchStatement>) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases: N.SwitchStatement[\"cases\"] = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        // @ts-expect-error Fixme\n        cases.push((cur = this.startNode()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(this: Parser, node: Undone<N.ThrowStatement>) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, { at: this.state.lastTokEndLoc });\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(this: Parser): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, {\n      in: { type: \"CatchClause\" },\n      binding: BIND_LEXICAL,\n      allowingSloppyLetBinding: true,\n    });\n\n    return param;\n  }\n\n  parseTryStatement(\n    this: Parser,\n    node: Undone<N.TryStatement>,\n  ): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode<N.CatchClause>();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      // Parse the catch clause's body.\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withSmartMixTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, { at: node });\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    kind: \"var\" | \"let\" | \"const\",\n    allowMissingInitializer: boolean = false,\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(\n    this: Parser,\n    node: Undone<N.WhileStatement>,\n  ): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(\"while\"),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(\n    this: Parser,\n    node: Undone<N.WithStatement>,\n  ): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, { at: this.state.startLoc });\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    // Parse the statement body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(\"with\"),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: Undone<N.EmptyStatement>): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(\n    this: Parser,\n    node: Undone<N.LabeledStatement>,\n    maybeName: string,\n    expr: N.Identifier,\n    context?: string | null,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName,\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type)\n      ? \"loop\"\n      : this.match(tt._switch)\n      ? \"switch\"\n      : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start,\n    });\n    node.body = this.parseStatement(\n      context\n        ? context.indexOf(\"label\") === -1\n          ? context + \"label\"\n          : context\n        : \"label\",\n    );\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: Undone<N.ExpressionStatement>,\n    expr: N.Expression,\n  ) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    this: Parser,\n    allowDirectives: boolean = false,\n    createNewLexicalScope: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode<N.BlockStatement>();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    this: Parser,\n    node: Undone<N.BlockStatementLike>,\n    allowDirectives: boolean | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body: N.BlockStatementLike[\"body\"] = (node.body = []);\n    const directives: N.BlockStatementLike[\"directives\"] = (node.directives =\n      []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    this: Parser,\n    body: N.Statement[],\n    directives: N.Directive[] | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    this: Parser,\n    node: Undone<N.ForStatement>,\n    init?: N.VariableDeclaration | N.Expression | null,\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(\"for\"),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    this: Parser,\n    node: Undone<N.ForInOf>,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt?: Position | null,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\",\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: { type: \"ForStatement\" },\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(\"for\"),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\",\n    allowMissingInitializer: boolean = false,\n  ): Undone<N.VariableDeclaration> {\n    const declarations: N.VariableDeclarator[] = (node.declarations = []);\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode<N.VariableDeclarator>();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(tt.eq)\n        ? null\n        : isFor\n        ? this.parseMaybeAssignDisallowIn()\n        : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(tt._of)))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\",\n          });\n        } else if (\n          kind === \"const\" &&\n          !(this.match(tt._in) || this.isContextual(tt._of))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\",\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(\n    this: Parser,\n    decl: Undone<N.VariableDeclarator>,\n    kind: \"var\" | \"let\" | \"const\",\n  ): void {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, {\n      in: { type: \"VariableDeclarator\" },\n      binding: kind === \"var\" ? BIND_VAR : BIND_LEXICAL,\n    });\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseFunction<T extends N.NormalFunction>(\n    this: Parser,\n    node: Undone<T>,\n    statement: number = FUNC_NO_FLAGS,\n    isAsync: boolean = false,\n  ): T {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star) && isHangingStatement) {\n      this.raise(Errors.GeneratorInSingleStatementContext, {\n        at: this.state.startLoc,\n      });\n    }\n    node.generator = this.eat(tt.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* allowModifiers */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node as T);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node as T;\n  }\n\n  parseFunctionId(requireId?: boolean): N.Identifier | undefined | null {\n    return requireId || tokenIsIdentifier(this.state.type)\n      ? this.parseIdentifier()\n      : null;\n  }\n\n  parseFunctionParams(\n    this: Parser,\n    node: Undone<N.Function>,\n    allowModifiers?: boolean,\n  ): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      /* allowEmpty */ false,\n      allowModifiers,\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BIND_VAR\n          : BIND_LEXICAL\n        : BIND_FUNCTION,\n      node.id.loc.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T extends N.Class>(\n    this: Parser,\n    node: Undone<T>,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next();\n    this.takeDecorators(node);\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed &&\n      !method.static &&\n      (method.key.name === \"constructor\" || // Identifier\n        method.key.value === \"constructor\") // String literal\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(\n    this: Parser,\n    hadSuperClass: boolean,\n    oldStrict: boolean,\n  ): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      hadConstructor: false,\n      hadSuperClass,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody = this.startNode<N.ClassBody>();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the contents within the braces.\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc,\n            });\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode<N.ClassMember>();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          // @ts-expect-error Fixme\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          // @ts-expect-error Fixme\n          member.kind === \"constructor\" &&\n          // @ts-expect-error Fixme\n          member.decorators &&\n          // @ts-expect-error Fixme\n          member.decorators.length > 0\n        ) {\n          this.raise(Errors.DecoratorConstructor, { at: member });\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, { at: this.state.startLoc });\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = member as any;\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = member as any;\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(tt._static);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, member as any as N.StaticBlock);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod = member as N.ClassMethod;\n    const privateMethod = member as N.ClassPrivateMethod;\n    const publicProp = member as N.ClassProperty;\n    const privateProp = member as N.ClassPrivateProperty;\n    const accessorProp = member as N.ClassAccessorProperty;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      const isPrivateName = this.match(tt.privateName);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key,\n        });\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const isContextual =\n      tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(tt.privateName);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, { at: key });\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, { at: key });\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (\n      isContextual &&\n      key.name === \"async\" &&\n      !this.isLineTerminator()\n    ) {\n      // an async method\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, { at: publicMethod.key });\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      isContextual &&\n      (key.name === \"get\" || key.name === \"set\") &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, { at: publicMethod.key });\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (\n      isContextual &&\n      key.name === \"accessor\" &&\n      !this.isLineTerminator()\n    ) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n\n      // The so-called parsed name would have been \"accessor\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassElementName\n  parseClassElementName(\n    this: Parser,\n    member: Undone<N.ClassMember>,\n  ): N.Expression | N.Identifier {\n    const { type, value } = this.state;\n    if (\n      (type === tt.name || type === tt.string) &&\n      member.static &&\n      value === \"prototype\"\n    ) {\n      this.raise(Errors.StaticPrototype, { at: this.state.startLoc });\n    }\n\n    if (type === tt.privateName) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc,\n        });\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<\n      N.StaticBlock & {\n        decorators?: Array<N.Decorator>;\n      }\n    >,\n  ) {\n    // Start a new lexical scope\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(PARAM);\n    const body: N.Node[] = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(Errors.DecoratorStaticBlock, { at: member });\n    }\n  }\n\n  pushClassProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassProperty,\n  ) {\n    if (\n      !prop.computed &&\n      (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")\n    ) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(Errors.ConstructorClassField, { at: prop.key });\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: Undone<N.ClassPrivateProperty>,\n  ) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      CLASS_ELEMENT_OTHER,\n      node.key.loc.start,\n    );\n  }\n\n  pushClassAccessorProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassAccessorProperty,\n    isPrivate: boolean,\n  ) {\n    if (!isPrivate && !prop.computed) {\n      // Not private, so not node is not a PrivateName and we can safely cast\n      const key = prop.key as N.Expression;\n\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        // Non-computed field, which is either an identifier named \"constructor\"\n        // or a string literal named \"constructor\"\n        this.raise(Errors.ConstructorClassField, { at: key });\n      }\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(\n        this.getPrivateNameSV(node.key),\n        CLASS_ELEMENT_OTHER,\n        node.key.loc.start,\n      );\n    }\n  }\n\n  pushClassMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassPrivateMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_GETTER\n          : CLASS_ELEMENT_INSTANCE_GETTER\n        : node.kind === \"set\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_SETTER\n          : CLASS_ELEMENT_INSTANCE_SETTER\n        : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(\n    node: Undone<\n      N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod\n    >,\n    kind: number,\n  ) {\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      kind,\n      node.key.loc.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    methodOrProp: Undone<N.ClassMethod | N.ClassProperty>,\n  ): void {}\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    this: Parser,\n    node: Undone<N.ClassPrivateProperty>,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassProperty(this: Parser, node: N.ClassProperty): N.ClassProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(\n    this: Parser,\n    node: N.ClassAccessorProperty,\n  ): N.ClassAccessorProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-Initializer\n  parseInitializer(\n    this: Parser,\n    node: Undone<\n      N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty\n    >,\n  ): void {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: Undone<N.Class>,\n    isStatement: boolean,\n    optionalId?: boolean | null,\n    bindingType: BindingTypes = BIND_CLASS,\n  ): void {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, { at: this.state.startLoc });\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(this: Parser, node: Undone<N.Class>): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(\n    this: Parser,\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n  ): N.AnyExport {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar =\n      parseAfterDefault &&\n      this.eatExportStar(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const hasNamespace =\n      hasStar &&\n      this.maybeParseExportNamespaceSpecifier(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node as Undone<N.ExportNamedDeclaration>, true);\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n\n    if (\n      (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||\n      (hasNamespace && parseAfterNamespace && !hasSpecifiers)\n    ) {\n      throw this.unexpected(null, tt.braceL);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(\n        node as Undone<N.ExportNamedDeclaration>,\n        isFromRequired,\n      );\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(\n        node as Undone<N.ExportNamedDeclaration>,\n      );\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(\n        node as Undone<N.ExportNamedDeclaration>,\n        true,\n        false,\n        !!(node as Undone<N.ExportNamedDeclaration>).source,\n      );\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      // export default ...\n      (node as Undone<N.ExportDefaultDeclaration>).declaration =\n        this.parseExportDefaultExpression();\n      this.checkExport(node as Undone<N.ExportDefaultDeclaration>, true, true);\n\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, tt.braceL);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  eatExportStar(node: N.Node): boolean {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n    if (this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n    if (this.isContextual(tt._as)) {\n      if (!node.specifiers) node.specifiers = [];\n\n      const specifier = this.startNodeAt(\n        this.state.lastTokStart,\n        this.state.lastTokStartLoc,\n      );\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\n    if (this.match(tt.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n  ): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(tt._async)) return false;\n    const next = this.nextTokenStart();\n    return (\n      !lineBreak.test(this.input.slice(this.state.pos, next)) &&\n      this.isUnparsedContextual(next, \"function\")\n    );\n  }\n\n  parseExportDefaultExpression(this: Parser): N.Expression | N.Declaration {\n    const expr = this.startNode();\n\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(tt._function) || isAsync) {\n      this.next();\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(\n        expr as Undone<N.FunctionExpression>,\n        FUNC_STATEMENT | FUNC_NULLABLE_ID,\n        isAsync,\n      );\n    }\n\n    if (this.match(tt._class)) {\n      return this.parseClass(expr as Undone<N.ClassExpression>, true, true);\n    }\n\n    if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\n      ) {\n        this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc });\n      }\n      this.parseDecorators(false);\n      return this.parseClass(expr as Undone<N.ClassExpression>, true, true);\n    }\n\n    if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc,\n      });\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  parseExportDeclaration(\n    this: Parser,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    node: Undone<N.ExportNamedDeclaration>,\n  ): N.Declaration | undefined | null {\n    return this.parseStatement(null) as N.Declaration;\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    const { type } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if ((type === tt._async && !this.state.containsEsc) || type === tt._let) {\n        return false;\n      }\n      if (\n        (type === tt._type || type === tt._interface) &&\n        !this.state.containsEsc\n      ) {\n        const { type: nextType } = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (tokenIsIdentifier(nextType) && nextType !== tt._from) ||\n          nextType === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (tokenIsIdentifier(this.state.type) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n    expect?: boolean,\n  ): void {\n    if (this.eatContextual(tt._from)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n      if (assertions) {\n        node.assertions = assertions;\n        this.checkJSONModuleImport(node);\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    const { type } = this.state;\n    if (type === tt.at) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          throw this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return (\n      type === tt._var ||\n      type === tt._const ||\n      type === tt._function ||\n      type === tt._class ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: Undone<N.ExportNamedDeclaration | N.ExportDefaultDeclaration>,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = (node as any as N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration,\n            });\n          }\n        }\n        // @ts-expect-error node.specifiers may not exist\n      } else if (node.specifiers && node.specifiers.length) {\n        // Named exports\n        // @ts-expect-error node.specifiers may not exist\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName,\n              });\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (\n          node.declaration.type === \"FunctionDeclaration\" ||\n          node.declaration.type === \"ClassDeclaration\"\n        ) {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators =\n      this.state.decoratorStack[this.state.decoratorStack.length - 1];\n    // If node.declaration is a class, it will take all decorators in the current context.\n    // Thus we should throw if we see non-empty decorators here.\n    if (currentContextDecorators.length) {\n      throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      // @ts-expect-error migrate to Babel types\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node: Undone<\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier\n    >,\n    exportName: string,\n  ): void {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, { at: node });\n      } else {\n        this.raise(Errors.DuplicateExport, { at: node, exportName });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(isInTypeExport: boolean): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      const isString = this.match(tt.string);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(\n        this.parseExportSpecifier(\n          node,\n          isString,\n          isInTypeExport,\n          isMaybeTypeOnly,\n        ),\n      );\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(\n    node: any,\n    isString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    isInTypeExport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ExportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0),\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  isJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ): boolean {\n    if (node.assertions != null) {\n      return node.assertions.some(({ key, value }) => {\n        return (\n          value.value === \"json\" &&\n          (key.type === \"Identifier\"\n            ? key.name === \"type\"\n            : key.value === \"type\")\n        );\n      });\n    }\n    return false;\n  }\n\n  checkJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ) {\n    // @ts-expect-error Fixme: node.type must be undefined because they are undone\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      // @ts-expect-error\n      const { specifiers } = node;\n      // @ts-expect-error\n      if (node.specifiers != null) {\n        // @ts-expect-error refine specifier types\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\"\n              ? imported.name !== \"default\"\n              : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start,\n          });\n        }\n      }\n    }\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(this: Parser, node: Undone<N.ImportDeclaration>): N.AnyImport {\n    // import '...'\n    node.specifiers = [];\n    if (!this.match(tt.string)) {\n      // check if we have a default import like\n      // import React from \"react\";\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      /* we are checking if we do not have a default import, then it is obvious that we need named imports\n       * import { get } from \"axios\";\n       * but if we do have a default import\n       * we need to check if we have a comma after that and\n       * that is where this `|| this.eat` condition comes into play\n       */\n      const parseNext = !hasDefault || this.eat(tt.comma);\n      // if we do have to parse the next set of specifiers, we first check for star imports\n      // import React, * from \"react\";\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      // now we check if we need to parse the next imports\n      // but only if they are not importing * (everything)\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(tt._from);\n    }\n    node.source = this.parseImportSource();\n    // https://github.com/tc39/proposal-import-assertions\n    // parse module import assertions if the next token is `assert` or ignore\n    // and finish the ImportDeclaration node.\n    const assertions = this.maybeParseImportAssertions();\n    if (assertions) {\n      node.assertions = assertions;\n    } else if (!process.env.BABEL_8_BREAKING) {\n      const attributes = this.maybeParseModuleAttributes();\n      if (attributes) {\n        // @ts-expect-error attributes have been deprecated\n        node.attributes = attributes;\n      }\n    }\n    this.checkJSONModuleImport(node);\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(this: Parser): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom() as N.StringLiteral;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  shouldParseDefaultImport(node: Undone<N.ImportDeclaration>): boolean {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  parseImportSpecifierLocal<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    node: Undone<N.ImportDeclaration>,\n    specifier: Undone<T>,\n    type: T[\"type\"],\n  ): void {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(specifier: Undone<T>, type: T[\"type\"], bindingType = BIND_LEXICAL) {\n    this.checkLVal(specifier.local, {\n      // @ts-expect-error refine types\n      in: specifier,\n      binding: bindingType,\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-assertions/#prod-AssertEntries |AssertEntries}\n   * @returns {N.ImportAttribute[]}\n   * @memberof StatementParser\n   */\n  parseAssertEntries(): N.ImportAttribute[] {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName,\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(tt.string)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   * @returns\n   * @memberof StatementParser\n   */\n  maybeParseModuleAttributes() {\n    if (this.match(tt._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key,\n        });\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name,\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    // [no LineTerminator here] AssertClause\n    if (this.isContextual(tt._assert) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next(); // eat `assert`\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n    // https://tc39.es/proposal-import-assertions/#prod-AssertClause\n    this.eat(tt.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(tt.braceR);\n\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.shouldParseDefaultImport(node)) {\n      // import defaultObj, { x, y as z } from '...'\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode<N.ImportDefaultSpecifier>(),\n        \"ImportDefaultSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode<N.ImportNamespaceSpecifier>();\n      this.next();\n      this.expectContextual(tt._as);\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: Undone<N.ImportDeclaration>) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const specifier = this.startNode<N.ImportSpecifier>();\n      const importedIsString = this.match(tt.string);\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        node.importKind === \"type\" || node.importKind === \"typeof\",\n        isMaybeTypeOnly,\n      );\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(\n    specifier: Undone<N.ImportSpecifier>,\n    importedIsString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript and Flow parser */\n    isInTypeOnlyImport: boolean,\n    isMaybeTypeOnly: boolean,\n    bindingType?: BindingTypes,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ImportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: (imported as N.StringLiteral).value,\n        });\n      }\n      this.checkReservedWord(\n        (imported as N.Identifier).name,\n        specifier.loc.start,\n        true,\n        true,\n      );\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(\n      specifier,\n      \"ImportSpecifier\",\n      bindingType,\n    );\n  }\n\n  // This is used in flow and typescript plugin\n  // Determine whether a parameter is a this param\n  isThisParam(\n    param: N.Pattern | N.Identifier | N.TSParameterProperty,\n  ): boolean {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n"],"mappings":"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"}