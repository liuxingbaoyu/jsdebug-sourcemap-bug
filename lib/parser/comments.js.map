{"version":3,"names":["setTrailingComments","node","comments","trailingComments","undefined","unshift","setLeadingComments","leadingComments","setInnerComments","innerComments","adjustInnerComments","elements","commentWS","lastElement","i","length","start","CommentsParser","BaseParser","addComment","comment","filename","loc","state","push","processComment","commentStack","commentStackLength","lastCommentWS","end","leadingNode","nodeStart","commentEnd","containingNode","finalizeComment","splice","trailingNode","commentStart","input","charCodeAt","type","properties","arguments","params","specifiers","finalizeRemainingComments","resetPreviousNodeTrailingComments","takeSurroundingComments"],"sources":["../../src/parser/comments.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport BaseParser from \"./base\";\nimport type { Comment, Node } from \"../types\";\nimport * as charCodes from \"charcodes\";\nimport type { Undone } from \"./node\";\n\n/**\n * A whitespace token containing comments\n * @typedef CommentWhitespace\n * @type {object}\n * @property {number} start - the start of the whitespace token.\n * @property {number} end - the end of the whitespace token.\n * @property {Array<Comment>} comments - the containing comments\n * @property {Node | null} leadingNode - the immediately preceding AST node of the whitespace token\n * @property {Node | null} trailingNode - the immediately following AST node of the whitespace token\n * @property {Node | null} containingNode - the innermost AST node containing the whitespace\n *                                         with minimal size (|end - start|)\n */\nexport type CommentWhitespace = {\n  start: number;\n  end: number;\n  comments: Array<Comment>;\n  leadingNode: Node | null;\n  trailingNode: Node | null;\n  containingNode: Node | null;\n};\n\n/**\n * Merge comments with node's trailingComments or assign comments to be\n * trailingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n *\n * @param {Undone<Node>} node\n * @param {Array<Comment>} comments\n */\nfunction setTrailingComments(node: Undone<Node>, comments: Array<Comment>) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's leadingComments or assign comments to be\n * leadingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n *\n * @param {Undone<Node>} node\n * @param {Array<Comment>} comments\n */\nfunction setLeadingComments(node: Undone<Node>, comments: Array<Comment>) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's innerComments or assign comments to be\n * innerComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n *\n * @param {Undone<Node>} node\n * @param {Array<Comment>} comments\n */\nexport function setInnerComments(\n  node: Undone<Node>,\n  comments?: Array<Comment>,\n) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\n/**\n * Given node and elements array, if elements has non-null element,\n * merge comments to its trailingComments, otherwise merge comments\n * to node's innerComments\n *\n * @param {Undone<Node>} node\n * @param {Array<Node>} elements\n * @param {Array<Comment>} comments\n */\nfunction adjustInnerComments(\n  node: Undone<Node>,\n  elements: Array<Node>,\n  commentWS: CommentWhitespace,\n) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\n/** @class CommentsParser */\nexport default class CommentsParser extends BaseParser {\n  addComment(comment: Comment): void {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  /**\n   * Given a newly created AST node _n_, attach _n_ to a comment whitespace _w_ if applicable\n   * {@see {@link CommentWhitespace}}\n   *\n   * @param {Node} node\n   * @returns {void}\n   * @memberof CommentsParser\n   */\n  processComment(node: Node): void {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const { start: nodeStart } = node;\n    // invariant: for all 0 <= j <= i, let c = commentStack[j], c must satisfy c.end < node.end\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        // by definition of commentWhiteSpace, this implies commentWS.start > nodeStart\n        // so node can be a containingNode candidate. At this time we can finalize the comment\n        // whitespace, because\n        // 1) its leadingNode or trailingNode, if exists, will not change\n        // 2) its containingNode have been assigned and will not change because it is the\n        //    innermost minimal-sized AST node\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        // stop the loop when commentEnd <= nodeStart\n        break;\n      }\n    }\n  }\n\n  /**\n   * Assign the comments of comment whitespaces to related AST nodes.\n   * Also adjust innerComments following trailing comma.\n   *\n   * @memberof CommentsParser\n   */\n  finalizeComment(commentWS: CommentWhitespace) {\n    const { comments } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      /*:: invariant(commentWS.containingNode !== null) */\n      const { containingNode: node, start: commentStart } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === charCodes.comma) {\n        // If a commentWhitespace follows a comma and the containingNode allows\n        // list structures with trailing comma, merge it to the trailingComment\n        // of the last non-null list element\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default: {\n            setInnerComments(node, comments);\n          }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  /**\n   * Drains remaining commentStack and applies finalizeComment\n   * to each comment whitespace. Used only in parseExpression\n   * where the top level AST node is _not_ Program\n   * {@see {@link CommentsParser#finalizeComment}}\n   *\n   * @memberof CommentsParser\n   */\n  finalizeRemainingComments() {\n    const { commentStack } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n\n  /**\n   * Reset previous node trailing comments. Used in object / class\n   * property parsing. We parse `async`, `static`, `set` and `get`\n   * as an identifier but may reinterpret it into an async/static/accessor\n   * method later. In this case the identifier is not part of the AST and we\n   * should sync the knowledge to commentStacks\n   *\n   * For example, when parsing */\n  // async /* 1 */ function f() {}\n  /*\n   * the comment whitespace \"* 1 *\" has leading node Identifier(async). When\n   * we see the function token, we create a Function node and mark \"* 1 *\" as\n   * inner comments. So \"* 1 *\" should be detached from the Identifier node.\n   *\n   * @param {N.Node} node the last finished AST node _before_ current token\n   * @returns\n   * @memberof CommentsParser\n   */\n  resetPreviousNodeTrailingComments(node: Node) {\n    const { commentStack } = this.state;\n    const { length } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  /**\n   * Attach a node to the comment whitespaces right before/after\n   * the given range.\n   *\n   * This is used to properly attach comments around parenthesized\n   * expressions as leading/trailing comments of the inner expression.\n   *\n   * @param {Node} node\n   * @param {number} start\n   * @param {number} end\n   */\n  takeSurroundingComments(node: Node, start: number, end: number) {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\n"],"mappings":"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"}