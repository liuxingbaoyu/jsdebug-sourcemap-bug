{"version":3,"names":["getOwn","object","key","Object","hasOwnProperty","call","unwrapParenthesizedExpression","node","type","expression","LValParser","NodeUtils","toAssignable","isLHS","parenthesized","undefined","extra","expressionScope","recordArrowParemeterBindingError","Errors","InvalidParenthesizedAssignment","at","raise","i","length","properties","last","prop","isLast","toAssignableObjectExpressionProp","trailingCommaLoc","RestTrailingComma","value","isPrivateName","classScope","usePrivateName","getPrivateNameSV","loc","start","Error","toAssignableList","elements","operator","MissingEqInAssignment","left","end","kind","PatternHasAccessor","PatternHasMethod","arg","argument","checkToRestConversion","exprList","elt","isAssignable","isBinding","every","element","toReferencedList","isParenthesizedExpr","toReferencedListDeep","expr","parseSpread","refExpressionErrors","startNode","next","parseMaybeAssignAllowIn","finishNode","parseRestBinding","parseBindingAtom","state","parseBindingList","parseObjectLike","parseIdentifier","close","closeCharCode","allowEmpty","allowModifiers","elts","first","eat","expect","match","push","parseAssignableListItemTypes","checkCommaAfterRest","decorators","hasPlugin","UnsupportedParameterDecorator","startLoc","parseDecorator","parseAssignableListItem","parseBindingRestProperty","parseBindingProperty","startPos","expectPlugin","parsePrivateName","parsePropertyName","method","parseObjPropValue","parseMaybeDefault","param","startNodeAt","right","isValidLVal","isUnparenthesizedInAssign","binding","AssignmentPattern","RestElement","ObjectProperty","ParenthesizedExpression","ArrayPattern","ObjectPattern","checkLVal","in","ancestor","BIND_NONE","checkClashes","strictModeChanged","allowingSloppyLetBinding","BIND_SCOPE_LEXICAL","hasParenthesizedAncestor","isObjectMethod","InvalidPropertyBindingPattern","checkIdentifier","name","has","ParamDupe","add","validity","ParseErrorClass","InvalidLhs","InvalidLhsBinding","prefix","isParenthesizedExpression","Array","isArray","nextAncestor","child","concat","bindingType","allowLetBinding","strict","isStrictBindReservedWord","inModule","isStrictBindOnlyReservedWord","StrictEvalArguments","referenceName","StrictEvalArgumentsBinding","bindingName","LetInLexicalBinding","declareNameFromIdentifier","identifier","scope","declareName","allowPattern","InvalidRestAssignmentPattern","lookaheadCharCode","ElementAfterRest"],"sources":["../../src/parser/lval.ts"],"sourcesContent":["import * as charCodes from \"charcodes\";\nimport { tt, type TokenType } from \"../tokenizer/types\";\nimport type {\n  AssignmentPattern,\n  TSParameterProperty,\n  Decorator,\n  Expression,\n  Identifier,\n  Node,\n  Pattern,\n  RestElement,\n  SpreadElement,\n  ObjectOrClassMember,\n  ClassMember,\n  ObjectMember,\n  TsNamedTypeElementBase,\n  PrivateName,\n  ObjectExpression,\n  ObjectPattern,\n  ArrayExpression,\n  ArrayPattern,\n} from \"../types\";\nimport type { Pos, Position } from \"../util/location\";\nimport {\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n} from \"../util/identifier\";\nimport { NodeUtils, type Undone } from \"./node\";\nimport {\n  type BindingTypes,\n  BIND_NONE,\n  BIND_SCOPE_LEXICAL,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { Errors, type LValAncestor } from \"../parse-error\";\nimport type Parser from \"./index\";\n\nconst getOwn = <T extends {}>(object: T, key: keyof T) =>\n  Object.hasOwnProperty.call(object, key) && object[key];\n\nconst unwrapParenthesizedExpression = (node: Node): Node => {\n  return node.type === \"ParenthesizedExpression\"\n    ? unwrapParenthesizedExpression(node.expression)\n    : node;\n};\n\nexport default abstract class LValParser extends NodeUtils {\n  // Forward-declaration: defined in expression.js\n  abstract parseIdentifier(liberal?: boolean): Identifier;\n  abstract parseMaybeAssign(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: Pos | null,\n  ): Expression;\n\n  abstract parseMaybeAssignAllowIn(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: Pos | null,\n  ): Expression;\n\n  abstract parseObjectLike<T extends ObjectPattern | ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): T;\n  abstract parseObjPropValue(\n    prop: any,\n    startPos: number | null,\n    startLoc: Position | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void;\n  abstract parsePropertyName(\n    prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,\n  ): Expression | Identifier;\n  abstract parsePrivateName(): PrivateName;\n  // Forward-declaration: defined in statement.js\n  abstract parseDecorator(): Decorator;\n\n  /**\n   * Convert existing expression atom to assignable pattern\n   * if possible. Also checks invalid destructuring targets:\n\n   - Parenthesized Destructuring patterns\n   - RestElement is not the last element\n   - Missing `=` in assignment pattern\n\n   NOTE: There is a corresponding \"isAssignable\" method.\n   When this one is updated, please check if also that one needs to be updated.\n\n   * @param {Node} node The expression atom\n   * @param {boolean} [isLHS=false] Whether we are parsing a LeftHandSideExpression.\n   *                                If isLHS is `true`, the following cases are allowed: `[(a)] = [0]`, `[(a.b)] = [0]`\n   *                                If isLHS is `false`, we are in an arrow function parameters list.\n   * @memberof LValParser\n   */\n  toAssignable(node: Node, isLHS: boolean = false): void {\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || node.extra?.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        // an LHS can be reinterpreted to a binding pattern but not vice versa.\n        // therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression\n        // i.e. `([(a) = []] = []) => {}`\n        // see also `recordArrowParemeterBindingError` signature in packages/babel-parser/src/util/expression-scope.js\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParemeterBindingError(\n            Errors.InvalidParenthesizedAssignment,\n            { at: node },\n          );\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          // A parenthesized member expression can be in LHS but not in pattern.\n          // If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding\n          // i.e. `([(a.b) = []] = []) => {}`\n          this.raise(Errors.InvalidParenthesizedAssignment, { at: node });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, { at: node });\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (\n          let i = 0, length = node.properties.length, last = length - 1;\n          i < length;\n          i++\n        ) {\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (\n            isLast &&\n            prop.type === \"RestElement\" &&\n            node.extra?.trailingCommaLoc\n          ) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc,\n            });\n          }\n        }\n        break;\n\n      case \"ObjectProperty\": {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n        break;\n      }\n\n      case \"SpreadElement\": {\n        throw new Error(\n          \"Internal @babel/parser error (this is a bug, please report it).\" +\n            \" SpreadElement should be converted by .toAssignable's caller.\",\n        );\n      }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(\n          node.elements,\n          node.extra?.trailingCommaLoc,\n          isLHS,\n        );\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, { at: node.left.loc.end });\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        /*::invariant (parenthesized !== undefined) */\n        this.toAssignable(parenthesized, isLHS);\n        break;\n\n      default:\n      // We don't know how to deal with this node. It will\n      // be reported by a later call to checkLVal\n    }\n  }\n\n  toAssignableObjectExpressionProp(\n    prop: Node,\n    isLast: boolean,\n    isLHS: boolean,\n  ) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(\n        prop.kind === \"get\" || prop.kind === \"set\"\n          ? Errors.PatternHasAccessor\n          : Errors.PatternHasMethod,\n        { at: prop.key },\n      );\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, /* allowPattern */ false);\n      this.toAssignable(arg, isLHS);\n\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, { at: prop });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  toAssignableList(\n    exprList: Expression[],\n    trailingCommaLoc: Position | undefined | null,\n    isLHS: boolean,\n  ): void {\n    const end = exprList.length - 1;\n\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, /* allowPattern */ true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, { at: elt });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, { at: trailingCommaLoc });\n        }\n      }\n    }\n  }\n\n  isAssignable(node: Node, isBinding?: boolean): boolean {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return (node.properties as ObjectExpression[\"properties\"]).every(\n          (prop, i) => {\n            return (\n              prop.type !== \"ObjectMethod\" &&\n              (i === last || prop.type !== \"SpreadElement\") &&\n              this.isAssignable(prop)\n            );\n          },\n        );\n      }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return (node as ArrayExpression).elements.every(\n          element => element === null || this.isAssignable(element),\n        );\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  // Convert list of expression atoms to a list of\n\n  toReferencedList(\n    exprList: ReadonlyArray<Expression | undefined | null>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isParenthesizedExpr?: boolean,\n  ): ReadonlyArray<Expression | undefined | null> {\n    return exprList;\n  }\n\n  toReferencedListDeep(\n    exprList: ReadonlyArray<Expression | undefined | null>,\n    isParenthesizedExpr?: boolean,\n  ): void {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if (expr?.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  // Parses spread element.\n\n  parseSpread(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): SpreadElement {\n    const node = this.startNode<SpreadElement>();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(\n      refExpressionErrors,\n      undefined,\n    );\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  // https://tc39.es/ecma262/#prod-BindingRestElement\n  parseRestBinding(this: Parser): RestElement {\n    const node = this.startNode<RestElement>();\n    this.next(); // eat `...`\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  // Parses lvalue (assignable) atom.\n  parseBindingAtom(this: Parser): Pattern {\n    // https://tc39.es/ecma262/#prod-BindingPattern\n    switch (this.state.type) {\n      case tt.bracketL: {\n        const node = this.startNode<ArrayPattern>();\n        this.next();\n        // @ts-expect-error: Fixme: TSParameterProperty can not be assigned to node.elements\n        node.elements = this.parseBindingList(\n          tt.bracketR,\n          charCodes.rightSquareBracket,\n          true,\n        );\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n\n      case tt.braceL:\n        return this.parseObjectLike(tt.braceR, true);\n    }\n\n    // https://tc39.es/ecma262/#prod-BindingIdentifier\n    return this.parseIdentifier();\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElementList\n  parseBindingList(\n    this: Parser,\n    close: TokenType,\n    closeCharCode: typeof charCodes[keyof typeof charCodes],\n    allowEmpty?: boolean,\n    allowModifiers?: boolean,\n  ): Array<Pattern | TSParameterProperty> {\n    const elts: Array<Pattern | TSParameterProperty> = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n      }\n      if (allowEmpty && this.match(tt.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(tt.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc,\n          });\n        }\n        // invariant: hasPlugin(\"decorators-legacy\")\n        while (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n    return elts;\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  parseBindingRestProperty(\n    this: Parser,\n    prop: Undone<RestElement>,\n  ): RestElement {\n    this.next(); // eat '...'\n    // Don't use parseRestBinding() as we only allow Identifier here.\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(charCodes.rightCurlyBrace);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingProperty\n  parseBindingProperty(this: Parser): ObjectMember | RestElement {\n    const prop = this.startNode<ObjectMember | RestElement>();\n    const { type, start: startPos, startLoc } = this.state;\n    if (type === tt.ellipsis) {\n      return this.parseBindingRestProperty(prop as Undone<RestElement>);\n    } else if (type === tt.privateName) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      (prop as Undone<ObjectMember>).key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop as Undone<ObjectMember>);\n    }\n    (prop as Undone<ObjectMember>).method = false;\n    return this.parseObjPropValue(\n      prop as Undone<ObjectMember>,\n      startPos,\n      startLoc,\n      false /* isGenerator */,\n      false /* isAsync */,\n      true /* isPattern */,\n      false /* isAccessor */,\n    );\n  }\n\n  parseAssignableListItem(\n    this: Parser,\n    allowModifiers: boolean | undefined | null,\n    decorators: Decorator[],\n  ): Pattern | TSParameterProperty {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  // Used by flow/typescript plugin to add type annotations to binding elements\n  parseAssignableListItemTypes(param: Pattern): Pattern {\n    return param;\n  }\n\n  // Parses assignment pattern around given atom if possible.\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseMaybeDefault(\n    this: Parser,\n    startPos?: number | null,\n    startLoc?: Position | null,\n    left?: Pattern | null,\n  ): Pattern {\n    startLoc = startLoc ?? this.state.startLoc;\n    startPos = startPos ?? this.state.start;\n    left = left ?? this.parseBindingAtom();\n    if (!this.eat(tt.eq)) return left;\n\n    const node = this.startNodeAt<AssignmentPattern>(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  /**\n   * Return information use in determining whether a Node of a given type is an LVal,\n   * possibly given certain additional context information.\n   *\n   * Subclasser notes: This method has kind of a lot of mixed, but related,\n   * responsibilities. If we can definitively determine with the information\n   * provided that this either *is* or *isn't* a valid `LVal`, then the return\n   * value is easy: just return `true` or `false`. However, if it is a valid\n   * LVal *ancestor*, and thus it's descendents must be subsquently visited to\n   * continue the \"investigation\", then this method should return the relevant\n   * child key as a `string`. In some special cases, you additionally want to\n   * convey that this node should be treated as if it were parenthesized. In\n   * that case, a tuple of [key: string, parenthesized: boolean] is returned.\n   * The `string`-only return option is actually just a shorthand for:\n   * `[key: string, parenthesized: false]`.\n   *\n   * @param {NodeType} type A Node `type` string\n   * @param {boolean} isUnparenthesizedInAssign\n   *        Whether the node in question is unparenthesized and its parent\n   *        is either an assignment pattern or an assignment expression.\n   * @param {BindingTypes} binding\n   *        The binding operation that is being considered for this potential\n   *        LVal.\n   * @returns { boolean | string | [string, boolean] }\n   *          `true` or `false` if we can immediately determine whether the node\n   *          type in question can be treated as an `LVal`.\n   *          A `string` key to traverse if we must check this child.\n   *          A `[string, boolean]` tuple if we need to check this child and\n   *          treat is as parenthesized.\n   */\n  isValidLVal(\n    type: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isUnparenthesizedInAssign: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    binding: BindingTypes,\n  ): string | boolean {\n    return getOwn(\n      {\n        AssignmentPattern: \"left\",\n        RestElement: \"argument\",\n        ObjectProperty: \"value\",\n        ParenthesizedExpression: \"expression\",\n        ArrayPattern: \"elements\",\n        ObjectPattern: \"properties\",\n      },\n      // @ts-expect-error refine string to enum\n      type,\n    );\n  }\n\n  /**\n   * Verify that a target expression is an lval (something that can be assigned to).\n   *\n   * @param {Expression} expression The expression in question to check.\n   * @param {Object} options A set of options described below.\n   * @param {LValAncestor} options.in\n   *        The relevant ancestor to provide context information for the error\n   *        if the check fails.\n   * @param {BindingTypes} [options.binding=BIND_NONE]\n   *        The desired binding type. If the given expression is an identifier\n   *        and `binding` is not `BIND_NONE`, `checkLVal` will register binding\n   *        to the parser scope See also `src/util/scopeflags.js`\n   * @param {Set<string>|false} [options.checkClashes=false]\n   *        An optional string set to check if an identifier name is included.\n   *        `checkLVal` will add checked identifier name to `checkClashes` It is\n   *        used in tracking duplicates in function parameter lists. If it is\n   *        false, `checkLVal` will skip duplicate checks\n   * @param {boolean} [options.allowingSloppyLetBinding]\n   *        Whether an identifier named \"let\" should be allowed in sloppy mode.\n   *        Defaults to `true` unless lexical scope its being used. This property\n   *        is only relevant if the parser's state is in sloppy mode.\n   * @param {boolean} [options.strictModeChanged=false]\n   *        Whether an identifier has been parsed in a sloppy context but should\n   *        be reinterpreted as strict-mode. e.g. `(arguments) => { \"use strict \"}`\n   * @param {boolean} [options.hasParenthesizedAncestor=false]\n   *        This is only used internally during recursive calls, and you should\n   *        not have to set it yourself.\n   * @memberof LValParser\n   */\n\n  checkLVal(\n    expression: Expression | ObjectMember | RestElement,\n    {\n      in: ancestor,\n      binding = BIND_NONE,\n      checkClashes = false,\n      strictModeChanged = false,\n      allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),\n      hasParenthesizedAncestor = false,\n    }: {\n      in: LValAncestor;\n      binding?: BindingTypes;\n      checkClashes?: Set<string> | false;\n      strictModeChanged?: boolean;\n      allowingSloppyLetBinding?: boolean;\n      hasParenthesizedAncestor?: boolean;\n    },\n  ): void {\n    const type = expression.type;\n\n    // If we find here an ObjectMethod, it's because this was originally\n    // an ObjectExpression which has then been converted.\n    // toAssignable already reported this error with a nicer message.\n    if (this.isObjectMethod(expression)) return;\n\n    if (type === \"MemberExpression\") {\n      if (binding !== BIND_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, { at: expression });\n      }\n      return;\n    }\n\n    if (expression.type === \"Identifier\") {\n      this.checkIdentifier(\n        expression as Identifier,\n        binding,\n        strictModeChanged,\n        allowingSloppyLetBinding,\n      );\n\n      const { name } = expression as Identifier;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, { at: expression });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(\n      expression.type,\n      !(hasParenthesizedAncestor || expression.extra?.parenthesized) &&\n        ancestor.type === \"AssignmentExpression\",\n      binding,\n    );\n\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass =\n        binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n\n      this.raise(ParseErrorClass, {\n        at: expression,\n        ancestor:\n          ancestor.type === \"UpdateExpression\"\n            ? { type: \"UpdateExpression\", prefix: ancestor.prefix }\n            : { type: ancestor.type },\n      });\n      return;\n    }\n\n    const [key, isParenthesizedExpression] = Array.isArray(validity)\n      ? validity\n      : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor =\n      expression.type === \"ArrayPattern\" ||\n      expression.type === \"ObjectPattern\" ||\n      expression.type === \"ParenthesizedExpression\"\n        ? expression\n        : ancestor;\n\n    // Flow has difficulty tracking `key` and `expression`, but only if we use\n    // null-proto objects. If we use normal objects, everything works fine.\n    // @ts-expect-error\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          // @ts-expect-error: refine types\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          allowingSloppyLetBinding,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression,\n        });\n      }\n    }\n  }\n\n  checkIdentifier(\n    at: Identifier,\n    bindingType: BindingTypes,\n    strictModeChanged: boolean = false,\n    allowLetBinding: boolean = !(bindingType & BIND_SCOPE_LEXICAL),\n  ) {\n    if (\n      this.state.strict &&\n      (strictModeChanged\n        ? isStrictBindReservedWord(at.name, this.inModule)\n        : isStrictBindOnlyReservedWord(at.name))\n    ) {\n      if (bindingType === BIND_NONE) {\n        this.raise(Errors.StrictEvalArguments, { at, referenceName: at.name });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name,\n        });\n      }\n    }\n\n    if (!allowLetBinding && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, { at });\n    }\n\n    if (!(bindingType & BIND_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier: Identifier, binding: BindingTypes) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node: Node, allowPattern: boolean): void {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      /* falls through */\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, { at: node });\n    }\n  }\n\n  checkCommaAfterRest(\n    close: typeof charCodes[keyof typeof charCodes],\n  ): boolean {\n    if (!this.match(tt.comma)) {\n      return false;\n    }\n\n    this.raise(\n      this.lookaheadCharCode() === close\n        ? Errors.RestTrailingComma\n        : Errors.ElementAfterRest,\n      { at: this.state.startLoc },\n    );\n\n    return true;\n  }\n}\n"],"mappings":"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"}