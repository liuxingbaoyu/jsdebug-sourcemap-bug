{"version":3,"names":["BaseParser","sawUnambiguousESM","ambiguousScriptDifferentAst","hasPlugin","pluginConfig","plugins","has","pluginName","pluginOptions","actualOptions","get","key","Object","keys","getPluginOption","plugin","name"],"sources":["../../src/parser/base.ts"],"sourcesContent":["import type { Options } from \"../options\";\nimport type State from \"../tokenizer/state\";\nimport type { PluginsMap } from \"./index\";\nimport type ScopeHandler from \"../util/scope\";\nimport type ExpressionScopeHandler from \"../util/expression-scope\";\nimport type ClassScopeHandler from \"../util/class-scope\";\nimport type ProductionParameterHandler from \"../util/production-parameter\";\nimport type {\n  ParserPluginWithOptions,\n  PluginConfig,\n  PluginOptions,\n} from \"../typings\";\n\nexport default class BaseParser {\n  // Properties set by constructor in index.js\n  declare options: Options;\n  declare inModule: boolean;\n  declare scope: ScopeHandler<any>;\n  declare classScope: ClassScopeHandler;\n  declare prodParam: ProductionParameterHandler;\n  declare expressionScope: ExpressionScopeHandler;\n  declare plugins: PluginsMap;\n  declare filename: string | undefined | null;\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n  declare exportedIdentifiers: Set<string>;\n  sawUnambiguousESM: boolean = false;\n  ambiguousScriptDifferentAst: boolean = false;\n\n  // Initialized by Tokenizer\n  declare state: State;\n  // input and length are not in state as they are constant and we do\n  // not want to ever copy them, which happens if state gets cloned\n  declare input: string;\n  declare length: number;\n\n  // This method accepts either a string (plugin name) or an array pair\n  // (plugin name and options object). If an options object is given,\n  // then each value is non-recursively checked for identity with that\n  // pluginâ€™s actual option value.\n  hasPlugin(pluginConfig: PluginConfig): boolean {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(\n        pluginOptions,\n      ) as (keyof typeof pluginOptions)[]) {\n        if (actualOptions?.[key] !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  getPluginOption<\n    PluginName extends ParserPluginWithOptions[0],\n    OptionName extends keyof PluginOptions<PluginName>,\n  >(plugin: PluginName, name: OptionName) {\n    return (this.plugins.get(plugin) as null | PluginOptions<PluginName>)?.[\n      name\n    ];\n  }\n}\n"],"mappings":";;;;;;;AAae,MAAMA,UAAN,CAAiB;EAa9BC,iBAAiB,GAAY,KAAZ;EACjBC,2BAA2B,GAAY,KAAZ;;EAa3BC,SAAS,CAACC,YAAD,EAAsC;IAC7C,IAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;MACpC,OAAO,KAAKC,OAAL,CAAaC,GAAb,CAAiBF,YAAjB,CAAP;IACD,CAFD,MAEO;MACL,MAAM,CAACG,UAAD,EAAaC,aAAb,IAA8BJ,YAApC;;MACA,IAAI,CAAC,KAAKD,SAAL,CAAeI,UAAf,CAAL,EAAiC;QAC/B,OAAO,KAAP;MACD;;MACD,MAAME,aAAa,GAAG,KAAKJ,OAAL,CAAaK,GAAb,CAAiBH,UAAjB,CAAtB;;MACA,KAAK,MAAMI,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAChBL,aADgB,CAAlB,EAEqC;QACnC,IAAIC,aAAa,GAAGE,GAAH,CAAb,KAAyBH,aAAa,CAACG,GAAD,CAA1C,EAAiD;UAC/C,OAAO,KAAP;QACD;MACF;;MACD,OAAO,IAAP;IACD;EACF;;EAEDG,eAAe,CAGbC,MAHa,EAGOC,IAHP,EAGyB;IACtC,OAAQ,KAAKX,OAAL,CAAaK,GAAb,CAAiBK,MAAjB,CAAD,GACLC,IADK,CAAP;EAGD;;AAtD6B"}